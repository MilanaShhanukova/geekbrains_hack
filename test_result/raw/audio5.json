{
    "text": " you you you you Всем привет! Сегодня мы продолжаем изучать веб-скрейпинг и перейдем к разбору Python-модуля LXML и языка XPath. В одном из предыдущих уроков мы познакомились с BeautifulSoup и использовали его для скрейпинга HTML-страниц. В текущем же уроке будем работать с модулем LXML. BeautifulSoup богаче с точки зрения функциональных возможностей, но для выполнения простых задач можно использовать LXML, а сегодня наша задача научиться писать выражения XPath, которые используются для скрейпинга нужных частей информации. В первой половине урока мы займемся теоретическим разбором инструментов, а во второй части урока применим на практике полученные знания и выполним скрейпинг сайта IMDB. Я советую вам по ходу лекции повторять все, что я делаю, то есть откройте VS Code и воспроизводите тот же код, что и в лекции. Итак, сегодня на уроке мы разберем основы LXML, XPath, поработаем с XPath в рамках LXML, поговорим о том, что такое CSS селекторы, ну и наконец выполним скрейпинг веб-сайта с помощью XPath. Основы LXML. Начнем с определения. LXML – это библиотека Python для обработки документов XML и HTML. Она предоставляет быстрый и эффективный API для парсинга, манипулирования и сериализации данных XML и HTML. Основные возможности LXML включают поддержку XPath и работу с деревом элементов. Давайте перейдем в нашу среду разработки Visual Studio Code и продолжим работать там. Мы находимся в VS Code и для начала нужно установить LXML. Установка LXML стандартная посредством pip install lxml. У меня эта библиотека уже установлена, поэтому продолжаем работу дальше. Чтобы начать работу с LXML, давайте возьмем элементарную HTML-страницу и посмотрим на ее структуру. Как видно, тело страницы содержит один параграф Hello Geekbrains, один список, внутри которого находятся элементы, и второй из элементов содержит тег гиперссылки. Можно запустить этот файл прямо из среды разработки. Для этого нужно установить расширение, которое называется Live Server. Для этого перейдем на вкладку «Расширение». В строке поиска напишем «Live Server». У меня это расширение уже установлено. После установки расширения возвращаемся на нашу страницу, жмем правую кнопку мышки и выбираем Open with Live Server. Нажимаем и наша HTML-страница откроется в браузере. Пока что мы работаем с игрушечным примером, но это нужно для учебных целей. Позже мы будем работать с настоящим сайтом. Сейчас, чтобы остановить сервер, нужно кликнуть в правом нижнем углу на вот этом значке Port. Сервер остановлен. Теперь давайте создадим новый Python файл в нашем корневом каталоге и назовем его app.py. Что мы сейчас будем делать?отеки LXML. Импортируем E3. Модуль E3 имеет функцию parse, которая принимает в качестве аргумента источник, который может быть файлом или частью файла. Так что в качестве аргумента мы указываем относительный путь к нашему HTML файлу. И давайте создадим переменную E3, в которой сохраним результат. сохраним результат. В качестве аргумента указываем путь к файлу нашему веб-пейдж, он у меня находится в директории src. И давайте выведем значение переменной, сохраним наш скрипт и запустим его в терминале функция parse как вы видите возвращает объект который называется элемент 3 что произошло функция parse берет html файл и преобразует его в дерево о дереве html мы говорили с вами во второй лекции. Сейчас возвращаемся к этой теме. С нашей точки зрения, HTML файл – это текст с определенным синтаксисом внутри. В то же время, XML или HTML может быть рассмотрено как дерево элементов. Давайте посмотрим на нашем примере и выведем элементы дерева. Чтобы вывести элементы дерева, воспользуемся уже готовым скриптом. У меня он называется Parse3. Давайте его запустим. Я не буду сейчас погружаться в детали кода. Вы можете, используя конспект лекции, разобраться, поскольку сейчас это не является целью нашей лекции. Запустим скрипт. Итак, что мы получили? Мы получили древовидную структуру, в которой все теги преобразованы в объекты элемент. В этой древовидной структуре элемент HTML является корневым элементом. И у него есть два дочерних элемента head и body. Элемент head имеет один дочерний элемент title. Элемент body имеет два дочерний элемент, title. Элемент body имеет два дочерних элемента, p и ul. Элемент ul, в свою очередь, имеет два дочерних элемента, это элементы li. Первый элемент li имеет атрибут id, установленный на myid. И второй элемент li имеет атрибут class, установленный в myClass, и содержит один дочерний элемент, элемент a. В общем, в древовидной структуре HTML элемент считается родительским, если он имеет один или несколько дочерних элементов, а дочерний элемент это элемент вложенный в другой элемент. Итак, давайте представим, что мы хотим извлечь или сделать скрепинг заголовка нашей HTML страницы. Мы можем это сделать, потому что теперь у нас есть дерево элементов и существует метод, который позволяет извлечь заголовок из нашей веб-страницы. У нашего объекта Element3 есть метод find, который принимает в качестве аргумента путь к элементу или тегу, который мы хотим извлечь. В нашей HTML-разметке мы знаем, что заголовок находится внутри тега head. Поэтому в методе find мы вводим строковое значение путь к заголовку headTitle. Давайте создадим новую переменную. Назовем ее titleElement и используем метод find. В качестве аргумента укажем путь к заголовку. Укажем путь к заголовку. И на этот раз выведем значение переменной titleElement. Сохраним скрипт и запустим его еще раз. Это выражение вернет элемент title. Объект элемент типа title. Если теперь мы хотим вывести фактическое значение заголовка, то можем вызвать свойство текст элемента title. Давайте допишем в код. Точка текст. Сохраним скрипт. Очистим терминал. И запустим скрипт еще раз. Пожалуйста, мы получили текстовое значение элемента title. Thank you. И так далее. на этот вопрос, давайте посмотрим еще раз код нашей веб-страницы. И здесь видно, что тег title находится внутри тега head, а тег head находится внутри тега html. Мы всегда должны начинать с одного из прямых дочерних элементов. Например, если мы хотим выбрать тег абзаца p,hello.geekbrains, мы должны начать с тега body, потому что body является прямым дочерним элементом тега HTML. Выведите текст абзаца p.hello.geekbrains, используя метод find. Сейчас поставьте видео на паузу и возвращайтесь с результатом. Итак, чтобы вывести содержимое тега p, мы воспользуемся все тем же методом 3.Find, но только изменим путь к тегу абзаца. Путь будет body и наш целевой тег p. Сохраним скрипт. Запустим его в терминале. Пожалуйста, мы получили текст тега p. В качестве альтернативы методу find у нас есть другой метод findAll. Аналогично тому, как мы изучали с beautiful soup. По его названию понятно, что он будет находить все совпадающие теги и возвращать их в виде списка. Например, чтобы выбрать все элементы списка, которые находятся внутри тега ul, давайте посмотрим в нашем html коде. Итак, мы хотим выбрать все элементы списка внутри ul, мы должны использовать метод findAll, потому что если мы используем метод find, то получим только первый элемент списка. Давайте попробуем извлечь элементы li или элементы списка. Вернемся в наш скрипт и создадим переменную listItem и используем на этот раз метод findAll. И в качестве пути укажем body, список, ul и элементы.li. И выведем наш список элементов. Список UL и элементы LI. И выведем наш список элементов. Сохраняем скрипт. Запускаем его. Мы получили список из двух элементов типа li. Чтобы извлечь текстовое содержимое, нужно обратиться к каждому элементу списка отдельно, поэтому нам придется создать цикл for и в цикле проходим по каждому элементу и выводим его. И выведем текстовое содержимое. Сохраняем скрипт, запускаем его. Обратите внимание, что для первого элемента списка мы получили полное текстовое значение. Однако для второго элемента списка мы не видим содержимого тега a. Причина здесь в том, что в методе findAll мы указали, что хотим получить все элементы списка и нас не интересует, есть ли внутри него тег a. Чтобы решить эту проблему, нужно внутри цикла создать переменную или что-то еще. Поэтому одно быстрое решение, которое мы можем применить, это осуществить поиск внутри цикла for. Давайте создадим переменную еще одну внутри цикла, назовем ее a, и внутри элемента li используем метод find для поиска тега a. Так как у нас только один элемент содержит тег a, то используем оператор if, и если a не равно non, значит внутри элемента списка есть тег a, содержимое которого мы соответственно и выведем. Если А из нот нон, иными словами, если А существует, то выведем его в текстовое содержимое. Здесь мы это должны заключить в фигурные скобки. В противном значении просто выводим текстовое содержимое элемента a. Этот принт нам больше не нужен, сохраняем. Я здесь не указал кавычки. Сохраняем и запускаем скрипт Обратите внимание, что теперь мы получили текстовое содержимое тега a со словом developer Но перед словом developer есть большой пробел Это связано с нашей HTML разметкой, где есть пробелы перед словом developer Чтобы очистить вывод, мы можем использовать метод python.strip. Добавим в код strip, сохраняем и запускаем наш скрипт еще раз. На этот раз все в порядке. Одним из недостатков LXML является то, что он не богат в плане методов, которые открываются нам через объекты Element3. Более того, каждый раз, когда мы хотим выбрать тег из разметки HTML, мы должны указать абсолютный путь до тега. Если мы имеем дело с большой HTML-страницей, это может быть проблемой. Чтобы решить эту проблему, существует более эффективный метод выбора тегов с помощью XPath. Переходим к следующей теме. Что такое XPath? XPath означает XML Path Language, язык запросов к элементам XML документа. Язык Xpath используется для уникальной идентификации или адресации частей XML документа. Выражение Xpath можно использовать для поиска в XML документе и извлечения информации из любой части документа. информации из любой части документа. Например, элемента или атрибута. В XML он называется узлом или node. Но это, конечно, не означает, что мы не можем использовать его для запроса и выбора элементов или тегов из HTML-страницы. Мы начнем изучение XPath с выражений. XPath expressions. xpath с выражений. xpath expressions. Выражение, определяющее шаблон для выбора узлов. Как мы уже обсуждали, HTML документ рассматривается как дерево узлов. В xpath мы можем выбрать элемент, используя двойной слэш и затем имя элемента. Например, если вы хотите выбрать все div на HTML-странице, мы используем двойной слэш div. Также мы можем выбрать элементы по их атрибуту, ID или классу, добавляя две квадратные скобки, следующие за именем элемента, а затем значение атрибута. Мы можем выбрать элемент на основе его позиции. Например, если вы хотите выбрать первый элемент списка ul, то в квадратных скобках указываем 1. Если мы хотим выбрать первый и второй элемент списка, мы должны использовать функцию position плюс логический оператор. Например, li и в квадратных скобках указываем position равно 1 или position равно 2. Чтобы выбрать только первый элемент списка, и этот первый элемент списка должен содержать текст hello, то мы используем функцию contains. В xpath все, что мы пишем в квадратных скобках, называется предикатом или условием. У XPath есть еще одно полезное свойство. Это возможность перемещаться в дереве HTML вверх или вниз, используя то, что называется оси XPath. В XPath оси – это способ выбора элементов, которые находятся относительно текущего элемента в иерархии документа. Ось – это именованная связь между элементами, которая определяет направление и набор узлов для выбора. Например, ось предков выбирает все элементы предки, то есть элементы расположенные выше в иерархии документа, а ось потомков выбирает все элементы потомки, которые идут после текущего элемента. Синтаксис на слайде. Мы указываем имя оси, двойное двоеточие и затем целевой элемент, который мы ищем. Для перехода вверх по дереву HTML есть 4 оси. Первая называется parent, которая возвращает родителя указанного узла. Вторая ancestor, чтобы получить всех предков определенного узла. Третья ось Preceding выбирает все узлы, которые появляются перед текущим узлом за исключением предков, узлов, атрибутов и пространства имя. Четвертая Preceding Sibling возвращает братьев определенного элемента, то есть все элементы одного уровня до текущего узла. Для перехода вниз по дереву HTML существуют следующие оси. Ось Child, которая будет получать дочерние элементы потомков определенного узла. Ось Following вернет все элементы, находящиеся после закрывающего тега определенного узла. Ось Following Sibling возвращает все элементы одного уровня после текущего узла. И наконец ось Descendant возвращает всех потомков текущего узла. Перейдем к следующей части и посмотрим как на практике применять xpath в рамках LXML. Итак, возвращаемся в VS Code. Удалим лишние строки, которые нам сейчас не нужны. Оставим только дерево элементов. Для выбора тегов с помощью XPath в LXML мы можем заменить наш метод find, который мы ранее использовали, методом XPath. Метод XPath принимает в качестве аргумента путь к целевому тегу, точно так же, как и метод find. Но особенность его состоит в том, что нам не нужно указывать полный путь для тега. Давайте попробуем выполнить парсинг заголовка. Создадим переменную titleElement, возьмем наше дерево и на этот раз вместо метода качестве аргумента просто указываем тег title и выведем его на печать. Метод xpath возвращает список, поэтому чтобы получить доступ к свойству текст нам нужно получить доступ к первому элементу списка, поэтому выведем title элемент и используем первый элемент списка и возьмем текст. Сохраняем скрипт и запустим. Мы получили текстовое содержимое тега title. Далее xpav позволяет нам получить доступ к тексту без использования свойства текста, связанного с lxml, то есть без вот этого свойства. И получить тот же результат. Выполняется это следующим образом. тот же результат. Выполняется это следующим образом. Мы используем функцию текст прямо в xpath выражения и также получаем доступ к первому его элементу. Соответственно, вот эта часть кода нам не нужна. выводим только содержимое значения переменной titleElement. Давайте очистим терминал и запустим еще раз наш скрипт. Мы получили тот же самый результат. задание. Попробуйте самостоятельно получить доступ к тексту тгп и вывести текст Hello Geek Brains. Поставьте видео на паузу и возвращайтесь, когда сделаете задание. Возвращаемся в VS Code. Давайте теперь получим данные из списка в HTML документе с помощью XPath. Только на этот раз не будем использовать функцию текст, а воспользуемся методом toString. Создадим переменную listItems. Используем метод xPath для выбора всех элементов li. Далее в цикле for для каждого listItems выведем его значение, используя метод toString. В качестве аргумента используем li. Сохраняем скрипт и запускаем. Сохраняем скрипт и запускаем. После выполнения кода мы увидим, что получили два списка элементов, содержащих полную HTML-разметку. Чтобы получить текст, который находится внутри элементов списка, давайте создадим переменную в цикле, которая будет применять функцию XPathText к каждому элементу списка. Создадим переменную text, которая будет брать каждый элемент li, применять к нему метод xpath и, И используя функцию текст, извлекать текст. И выводим значение переменной текст в каждой итерации. Очистим экран терминала и еще раз запускаем. После выполнения кода мы снова получаем два списка. и еще раз запускаем. После выполнения кода мы снова получаем два списка, однако все еще мы получаем текст со всеми специальными символами, находящимися в HTML коде. Чтобы это исправить, нужно всего лишь добавить точку перед двойным слэшем функции текст. То есть здесь мы просто ставим точку, То есть здесь мы просто ставим точку, сохраняем, запускаем скрипт еще раз. На этот раз получаем только текст двух тегов li. Пока что мы получили два списка, первый из которых содержит только один элемент с текстом, а второй содержит три элемента, но все еще содержит пробелы. Давайте избавимся от этих лишних символов. Для этого мы можем использовать метод map, который принимает в качестве первого аргумента функцию, которая будет применена к каждому элементу списка. И используем стрип, чтобы удалить все пробелы и n, символы переноса строки. Дополним наш код. Используем map и применим стрип к каждому элементу. Далее преобразуем в список наш вывод, очистим терминал и запускаем скрипт еще раз. Наконец, чтобы код возвращал не списки, а только код текст, мы можем использовать другую функцию Python. Python.join. И здесь, в свою очередь, нам уже список больше не нужен. Выводим значение переменной текст, сохраняем скрипт и запускаем его в терминале. Мы получили чистый текст. Наконец, давайте посмотрим пример работы с осями XP. Выберем все элементы li, которые являются потомками элемента ul. Если я говорю немного непонятно, возвращайтесь к HTML коду и сверяйтесь с исходным HTML кодом. Итак, меняем выражение XPath, чтобы выбрать всех потомков тега UL. Для этого используется слово descendant li. Сохраняем, запускаем скрипт. Вы можете свериться с HTML и убедиться, что мы выбрали все элементы li, которые являются потомками элемента ul. Таким образом, XPath это мощный инструмент для выбора и навигации по элементам в документах XML и HTML, который особенно полезен для задач веб-скрейпинга и извлечения данных. В этой части лекции мы рассмотрели основы использования XPub в LXML для выбора и извлечения данных из HTML документов. А сейчас давайте познакомимся с еще одним инструментом для извлечения данных из HTML-кода, это CSS-селектора. Как вы знаете, CSS служит для стилизации HTML-страниц. Идея состоит в том, что для скрейпинга мы можем использовать LXML вместе с CSS-селекторами для скрейпинга тега или элемента стилизации веб-страниц. Для использования CSS-селекторов нам нужно установить модуль под названием CSS-селект. установить модуль под названием css select. Устанавливается он в терминале посредством pip css select. Здесь ничего особенного, у меня он уже установлен. Теперь в нашем коде мы можем использовать метод CSS Select, который принимает в качестве аргумента CSS Selector. Например, чтобы выбрать заголовок из HTML страницы, все, что нам Давайте в очередной раз перепишем наш скрипт. Создадим переменную titleElement и на этот раз используем метод CSSSelect. В качестве аргумента указываем title и выведем значение, которое также будет представлено в виде списка, поэтому берем только нулевой элемент или первый элемент, сохраняем скрипт и запускаем наш код. Если выполнить файл в таком виде, то мы, как вы видите, получили ошибку attributeError. Это связано с тем, что CSS Select работает непосредственно с HTML элементами, а не с объектом Element3, как это делает XPub. Поэтому предварительно нужно конвертировать Element3. Создадим для этого новую переменную, назовем ее html и воспользуемся функцией getRoot. Эта функция конвертирует объект дерева в HTML элемент. Сохраняем наш скрипт, очистим терминал и запускаем скрипт. И здесь я снова получил ошибку attributeError. У объекта нет атрибута CSS Select. с с с select это связано с тем что здесь нужно 3 поменять на html исправляем сохраняем и запускаем еще раз на этот раз все в порядке мы получили текстовое содержимое тега тайт задание. используйте метод css selector вместо xpav и выберите тег абзаца. поставьте видео на паузу и после выполнения возвращайтесь. Итак, CSS Select и XPath – это два разных языка запросов, используемых для извлечения данных из документов HTML и XML. Хотя оба языка служат схожим целям, у них есть несколько ключевых различий, которые делают их подходящими для разных случаев использования. XPath – более мощный и гибкий язык запросов, чем CSS Select, поскольку он позволяет использовать более сложные выражения и поддерживает более широкий спектр типов данных и функций. XPath также поддерживает оси, которые позволяют перемещаться по иерархии дерева и выбирать элементы на основе их связи с другими элементами. CSS Select, с другой стороны, является более простым и лаконичным языком запросов. CSS Select может быть полезен для задач веб-скрейпинга, связанных с выбором элементов на основе их класса, ID или других CSS-селекторов, и часто для таких задач его просто проще понимать и использовать чем экспо одним из основных преимуществ ссср select перед экспо является то что он может быть быстрее и эффективнее для определенных типов выбора особенно при выборе на основе атрибутов класса или айди однако важно отметить что экспо в целом является более мощным и гибким языком запросов и лучше подходит для более сложных задач извлечения данных, которые включают выбор элементов на основе их текстового содержимого, структуры и других атрибутов. В целом, выбор языка зависит от конкретных требований задачи извлечения данных. А сейчас давайте перейдем к скрейпингу веб-сайта с помощью XPath. Мы переходим к следующему разделу лекции и займемся скрейпингом сайта IMDb, а именно страницы с топ наиболее популярных фильмов. Познакомимся с некоторыми хитростями, которые помогут вам скрейпить веб-страницы, избавимся от ненужных классов, внедренных в JavaScript, а также сохраним скрипированные данные в базе данных MongoDB. Давайте напишем код, который будет извлекать из приведенной таблицы название, место в рейтинге, изменение в место в рейтинге на странице наиболее популярных фильмов. Как вы знаете, большинство сайтов используют JavaScript. И проблема состоит в том, что библиотека Requests из Python, с которой мы уже знакомы, не понимает, не видит JavaScript. Поэтому высоки шансы, что мы не получим ту же самую информацию, которую видим при отображении страницы в браузере. Поэтому, чтобы исключить JavaScript из разметки, можно использовать следующий способ. В Chrome нажимаем три вертикальных кнопки в правом верхнем углу, переходим в настройки и в настройках нужно найти в поиске элемент с названием JavaScript или просто можно написать Java. Здесь находим настройки сайтов, переходим в настройки. И в настройках ищем контент и в нем раздел JavaScript. Переходим в него. И здесь мы видим переключатель, который позволяет разрешить сайтом использовать JavaScript, либо запретить сайтом использовать JavaScript. Сейчас мы запрещаем использовать JavaScript. Возвращаемся к нашей целевой странице, и ее нужно обновить. После обновления мы видим, что некоторые элементы пропали, например, ваш рейтинг. И в общем-то это тот контент, который видит библиотека requests.python. Давайте перейдем в нашу среду разработки. В среде разработки создадим новый файл, назовем его, например, app2.py. И давайте для начала выполним запрос get к нашему целевому сайту. Для этого для начала импортируем библиотеку requests. Создадим переменную с ответом, назовем ее resp. И воспользуемся методом get, который принимает аргументы URL с значением URL адреса нашего целевого сайта. Скопируем адрес, возвращаемся в s-код, вставляем сюда адрес и давайте укажем еще один аргумент. Это будет заголовок и в фигурных скобках укажем user agent или агент пользователя где взять агент пользователя ну одним из самых простых способов является просто загуглить его давайте вернемся в chrome и прежде чем получить наш агент пользователя, нужно разрешить сайтам использовать JavaScript. И в поиске просто пишем myuseragent. И в Chrome отображается наш агент пользователя. Копируем его отсюда, возвращаемся в scode и указываем его в аргументе header. Указание вашего агента пользователя в аргументе запроса является хорошим тоном по ряду причин. Во-первых, некоторые веб-сайты могут блокировать запросы, которые не имеют действительного агента-пользователя или имеют необычный агент-пользователя. Во-вторых, некоторые сайты могут предоставлять различное содержимое или различную HTML-разметку в зависимости от пользовательского агента, личную HTML-разметку в зависимости от пользовательского агента, запрашивающего браузера. Наконец, некоторые сайты могут иметь соглашение об использовании, которое запрещает скрейпинг или извлечение данных. Указывая действительный пользовательский агент в строке запроса, вы идентифицируете себя как законного пользователя сайта, а не скрейпера или бота, который может нарушать условия обслуживания. И давайте выведем значение ответа сервера, а точнее статус код, чтобы проверить, что мы получили ответ от сервера. ответ от сервера. Сохраняем скрипт, запустим его и здесь мы получили ошибку в связи с тем, что опечатка в аргументе headers. Добавим s, сохраняем и запускаем еще раз. Итак, мы получили ответ 200, то есть успешный ответ сервера. Давайте начнем с построения дерева. Для этого нам нужно импортировать HTML из LXML. И теперь попробуем получить переменную дерева. Назовем ее 3. Используем функцию fromString и в качестве аргумента используем свойства контент нашего get ответа от сервера. Данная строка создает парсинг дерева l.xml из содержимого объекта ответа. Метод fromString используется для создания нового объекта Element из HTML содержимого ответа, который хранится в атрибуте Content. Сохраним. И сейчас давайте вернемся к сайту. Для начала убедимся, что JavaScript отключен. Теперь кликаем правой кнопкой мышки на странице, выбираем просмотреть код и переходим к инструменту разработчика. Давайте для начала найдем название первого фильма. Для этого выберем инструмент поиска, наводим на название первого фильма и давайте посмотрим на HTML-код. Как вы видите, тег A находится внутри тела таблицы, который в свою очередь находится внутри таблицы. Тейбл, который содержит два класса, chartFullWith и datacolorName. chart full width и datacolor name. Нам нужно получить доступ вот к этому тексту, к названию фильма, поэтому давайте начнем писать XPath выражение. Нажимаем Ctrl F и в появившейся строке поиска вводим XPath выражение. Двойной слэш. Сначала нам нужно получить доступ к таблице, к тегу table. Пишем table. Далее, в квадратных скобках мы указываем значение атрибутов. Если щелкнуть дважды на значение атрибута, можно его скопировать и перенести в строку поиска. Итак, мы хотим найти значение DataColorName равным. Вставляем скопированное значение, а именно ChartMovimeter. И как видите, здесь в строке поиска нам указывают, какое количество элементов с такими характеристиками было найдено в HTML коде. В нашем случае 1. 1, потому что таблица у нас одна. Далее, внутри этой таблицы ищем следующий тег, а именно tbody. Тоже найден один элемент. Как видите, мы не должны указывать весь полностью путь. Мы указываем только те дочерние элементы, которые содержат целевой наш тег с названием фильма. Следующий элемент у нас TR. TR – это строка. И сейчас, как вы видите, у нас найдено 100 таких элементов. 100, потому что на этой странице указано 100 наиболее популярных фильмов, что соответствует нашему запросу. Давайте скопируем это выражение xpath и вернемся обратно в VS Code. В нашем коде давайте создадим новую переменную, назовем ее movies. И используя наше дерево элементов и метод xpath, в качестве аргумента укажем наше xpath выражение в кавычках. Сохраняем. Значит эта переменная представляет собой список, который будет содержать все элементы типа tr, из которых нам нужно получить содержимое. Давайте сейчас создадим цикл, в котором будем проходить по всему списку. Для каждого фильма в списке фильмов. Это у нас заготовка. Теперь нам нужно опять вернуться в хром. В хроме здесь у нас первый тд элемент, наводим на него мышкой и видим, что подсвечивается первый столбец в таблице. Второй элемент тд это второй элемент или второй столбец в таблице. в таблице. Внутри второго тега td есть тег a, который, кроме прочего, и содержит текстовое значение, а именно название фильма. Давайте получим к нему доступ с помощью expa. Дописываем наше выражение. Следующий тег после tr у нас td. Нам нужен элемент td, значение атрибута класса которого равно title.column. Поэтому в квадратных скобках указываем класс и его значение. В нашем случае это title-column, можно его скопировать. Мы получили 100 таких элементов, нам же нужен один. Мы получили 100 таких элементов, нам же нужен один. Поэтому внутри этого элемента находим тег A и из него можем извлечь текст. Копируем наше XPath выражение и возвращаемся в VS Code. Теперь внутри цикла добавим ключ. Мы извлекаем название фильма, поэтому назовем его name. И находим внутри каждой переменной movie с помощью xpath название фильма. Но поскольку нам не нужен уже здесь полный путь, так как мы его сейчас прописывали в хроме, его сюда конечно можем скопировать но на самом деле часть и из этого пути уже содержится в самом movie поэтому мы оставляем только ту часть которая идет после tr то есть начиная с тега Т.Д. Все предыдущее можно удалить. Ставим здесь точку перед двумя слэшами. И нам нужно получить доступ только к первому элементу списка. Сохраняем. Возвращаемся дальше в Chrome. Теперь нам нужно получить год выпуска фильма. Воспользуемся инструментом поиска. Наведем на год выпуска, щелкаем по нему. Наведем на год выпуска, щелкаем по нему. И, как видите, год выпуска содержится в теге span. Пропишем xpath до года выпуска. Итак, у нас год выпуска находится в tbody, tr. находится в т-body, но начиная с td мы должны изменить xpath выражение и обратиться к тегу span, найти тег span, как видите их много давайте еще раз посмотрим на него. Нам нужен текст-план, значение атрибута класса которого равно secondaryInfo. Поэтому в квадратных скобках пишем class равно secondaryInfo. Все, мы получили доступ к году выпуска фильма. Выделяем и копируем XPath выражение и возвращаемся обратно в код. В коде создадим новый ключ. Назовем его «releaseEA». Также обращаемся к movie с помощью метода «xpath» и прописываем «xpath» выражение, которое мы скопировали. Давайте его отредактируем аналогичным образом. То есть мы начинаем поиск, начиная с тега td. Здесь не забываем ставить точку. И обращаемся только к нулевому элементу. Да, мы не создали словарь, поэтому давайте сейчас это сделаем и все наши данные будем записывать в словарь. Назовем его просто m и все, что мы написали, завернем в фигурные скобки. Те же действия нам нужно повторить и для остальных элементов на в именно позицию в рейтинге, изменение позиции в рейтинге и также значение title метра. Сейчас я вернусь на страницу и покажу что это. Значение title метра на этой странице это вот эта стрелочка, которая указывает в какую сторону изменился рейтинг, вверх или вниз. Давайте воспользуемся инструментом поиска, наведем на него. И в коде мы видим, что здесь title.meter.up, то есть рейтинг вырос. Давайте посмотрим, что в других элементах. Здесь title-meter-down. Попробуйте извлечь и само слово down из этого элемента. Итак, ставьте видео на паузу и возвращайтесь через некоторое время. через некоторое время. Итак, надеюсь у вас все получилось. Вы можете свериться с кодом, приведенным на экране или в конспекте коллекции. Теперь давайте создадим пустой список, назовем его All Movies, который будет содержать все наши данные и в цикле будем записывать в этот список словари. И на этом пока все. Давайте выведем наш спист и запустим его. Запускаем. Итак, мы получили список словарей и общую длину элементов списка равную 100, что соответствует количеству фильмов на целевой странице. некоторые поля содержат специальные символы, некоторые поля могут содержать какую-то лишнюю информацию. Поэтому дальнейшая ваша задача, следующий шаг – это выполнить парсинг элементов с помощью тех методов, которые мы уже изучали на том уроке, когда проходили Beautiful Soup и на семинарах. Поэтому сейчас я не буду останавливаться подробно на том, как извлекать информацию из каждого элемента списка и приведу сразу готовый код. Итак, я вам, конечно, рекомендую самостоятельно выполнить парсинг каждого элемента для извлечения точно той информации, которая вам нужна. Здесь же, в частности, например, год выпуска преобразован в тип int, в целое число. Здесь позиция также преобразована в целое число. Также мы извлекаем только ту информацию, которая нам нужна. Наконец, следующий этап – это добавление данных в MongoDB. Давайте напишем функцию для добавления полученных данных в локальное хранилище mango db для этого импортируем манга client из пойманга И напишем функцию, назовем ее insertToDB, в которую будем передавать список фильмов. Подключаемся к локальному клиенту. Далее создаем в нашей базе данных новую базу, назовем ее TopMovies. И, наконец, воспользуемся методом insertMany для добавления нашего списка. И, наконец, закроем клиент. После цикла вызовем нашу функцию и передадим ей список, который мы получили в результате скрейпинга. Вывод в терминал удалим, он нам больше не нужен. Сохраняем скрипт. Очистим терминал. И прежде всего давайте перейдем в Mango Compass, чтобы посмотреть, что там в настоящее время базы данных нет. Вам нужно локально запустить Mango DB. Вы можете убедиться, что сейчас базы данных с названием imdbmovies у нас нет. И, в общем-то, наша задача сейчас сюда перенести данные. Вернемся в код. Наконец, прежде чем мы запустим наш скрипт, я хотел бы обратить ваше внимание еще на две функции, которые я сюда добавил. Первая из этих функций извлекает изменение title метра, то есть повысился рейтинг фильма или повысился рейтинг фильма или понизился рейтинг фильма, или остался без изменений. И вторая функция получает изменение позиции, то есть на сколько пунктов изменился рейтинг. Итак, пробуем запускать скрипт. Ждем ответ сервера. Скрипт выполнился. И давайте перейдем в MongoDB. Мы можем обновить список баз данных, если вновь созданная база данных все еще не отображается у вас в списке. Видим, что у нас появилась АМДБ Movies, наша новая база данных. Можем развернуть ее, внутри увидеть коллекцию Top Movies. Давайте войдем в нее. Здесь мы видим, что у нас имеется 100 элементов, что соответствует количеству фильмов на целевой странице. И, конечно, все элементы, которые мы заполучили с рейтинга IMDB, представлены в базе данных. В заключение я хочу сказать, что парсинг и скрейпинг HTML с помощью LXML и XPath это мощная техника извлечения данных с веб-сайтов. Библиотека LXML предоставляет быстрый и эффективный способ парсинга HTML, а XPath позволяет гибко и точно выбирать элементы и атрибуты в подобных документах. Комбинируя эти инструменты с Python и другими библиотеками анализа данных, можно собирать и обрабатывать большие объемы данных из интернета для использования в исследованиях, анализе или других приложениях. На этом урок окончен и до встречи на следующей лекции. you",
    "chunks": [
        {
            "timestamp": [
                0.0,
                96.84
            ],
            "text": " you you you you Всем привет!"
        },
        {
            "timestamp": [
                97.62,
                100.76
            ],
            "text": " Сегодня мы продолжаем изучать веб-скрейпинг и перейдем"
        },
        {
            "timestamp": [
                100.76,
                104.86
            ],
            "text": " к разбору Python-модуля LXML и языка XPath."
        },
        {
            "timestamp": [
                105.02,
                108.68
            ],
            "text": " В одном из предыдущих уроков мы познакомились с BeautifulSoup"
        },
        {
            "timestamp": [
                108.68,
                112.86
            ],
            "text": " и использовали его для скрейпинга HTML-страниц."
        },
        {
            "timestamp": [
                113.52,
                117.56
            ],
            "text": " В текущем же уроке будем работать с модулем LXML."
        },
        {
            "timestamp": [
                117.96,
                121.54
            ],
            "text": " BeautifulSoup богаче с точки зрения функциональных возможностей,"
        },
        {
            "timestamp": [
                121.86,
                127.2
            ],
            "text": " но для выполнения простых задач можно использовать LXML, а сегодня наша задача"
        },
        {
            "timestamp": [
                127.2,
                131.18
            ],
            "text": " научиться писать выражения XPath, которые используются"
        },
        {
            "timestamp": [
                131.18,
                134.16
            ],
            "text": " для скрейпинга нужных частей информации."
        },
        {
            "timestamp": [
                134.16,
                137.62
            ],
            "text": " В первой половине урока мы займемся теоретическим"
        },
        {
            "timestamp": [
                137.62,
                140.52
            ],
            "text": " разбором инструментов, а во второй части урока"
        },
        {
            "timestamp": [
                140.52,
                144.7
            ],
            "text": " применим на практике полученные знания и выполним скрейпинг"
        },
        {
            "timestamp": [
                144.7,
                146.0
            ],
            "text": " сайта IMDB."
        },
        {
            "timestamp": [
                146.0,
                150.46
            ],
            "text": " Я советую вам по ходу лекции повторять все, что я делаю,"
        },
        {
            "timestamp": [
                150.46,
                154.0
            ],
            "text": " то есть откройте VS Code и воспроизводите тот же код,"
        },
        {
            "timestamp": [
                154.0,
                155.0
            ],
            "text": " что и в лекции."
        },
        {
            "timestamp": [
                155.0,
                160.6
            ],
            "text": " Итак, сегодня на уроке мы разберем основы LXML, XPath,"
        },
        {
            "timestamp": [
                160.6,
                164.64
            ],
            "text": " поработаем с XPath в рамках LXML, поговорим о том, что"
        },
        {
            "timestamp": [
                164.64,
                171.38
            ],
            "text": " такое CSS селекторы, ну и наконец выполним скрейпинг веб-сайта с помощью XPath."
        },
        {
            "timestamp": [
                171.72,
                174.72
            ],
            "text": " Основы LXML. Начнем с определения."
        },
        {
            "timestamp": [
                175.48,
                186.52
            ],
            "text": " LXML – это библиотека Python для обработки документов XML и HTML. Она предоставляет быстрый и эффективный API для парсинга,"
        },
        {
            "timestamp": [
                186.52,
                192.18
            ],
            "text": " манипулирования и сериализации данных XML и HTML."
        },
        {
            "timestamp": [
                192.18,
                196.32
            ],
            "text": " Основные возможности LXML включают поддержку XPath"
        },
        {
            "timestamp": [
                196.32,
                198.7
            ],
            "text": " и работу с деревом элементов."
        },
        {
            "timestamp": [
                198.7,
                203.12
            ],
            "text": " Давайте перейдем в нашу среду разработки Visual Studio"
        },
        {
            "timestamp": [
                203.12,
                210.08
            ],
            "text": " Code и продолжим работать там. Мы находимся в VS Code и для начала"
        },
        {
            "timestamp": [
                210.08,
                231.18
            ],
            "text": " нужно установить LXML. Установка LXML стандартная посредством pip install lxml. У меня эта библиотека уже установлена, поэтому продолжаем работу дальше."
        },
        {
            "timestamp": [
                231.18,
                240.58
            ],
            "text": " Чтобы начать работу с LXML, давайте возьмем элементарную HTML-страницу и посмотрим на ее структуру."
        },
        {
            "timestamp": [
                256.86,
                257.48
            ],
            "text": " Как видно, тело страницы содержит один параграф Hello Geekbrains, один список, внутри которого находятся элементы, и второй из элементов содержит тег гиперссылки."
        },
        {
            "timestamp": [
                260.48,
                260.88
            ],
            "text": " Можно запустить этот файл прямо из среды разработки."
        },
        {
            "timestamp": [
                265.24,
                265.7
            ],
            "text": " Для этого нужно установить расширение, которое называется Live Server."
        },
        {
            "timestamp": [
                270.0,
                270.76
            ],
            "text": " Для этого перейдем на вкладку «Расширение»."
        },
        {
            "timestamp": [
                276.0,
                277.52
            ],
            "text": " В строке поиска напишем «Live Server»."
        },
        {
            "timestamp": [
                280.0,
                281.62
            ],
            "text": " У меня это расширение уже установлено."
        },
        {
            "timestamp": [
                294.36,
                295.36
            ],
            "text": " После установки расширения возвращаемся на нашу страницу, жмем правую кнопку мышки и выбираем Open with Live Server."
        },
        {
            "timestamp": [
                300.58,
                302.2
            ],
            "text": " Нажимаем и наша HTML-страница откроется в браузере."
        },
        {
            "timestamp": [
                307.54,
                313.08
            ],
            "text": " Пока что мы работаем с игрушечным примером, но это нужно для учебных целей. Позже мы будем работать с настоящим сайтом. Сейчас, чтобы остановить сервер, нужно кликнуть"
        },
        {
            "timestamp": [
                313.08,
                333.72
            ],
            "text": " в правом нижнем углу на вот этом значке Port. Сервер остановлен. Теперь давайте создадим новый Python файл в нашем корневом каталоге и назовем его app.py."
        },
        {
            "timestamp": [
                336.04,
                352.08
            ],
            "text": " Что мы сейчас будем делать?отеки LXML."
        },
        {
            "timestamp": [
                360.98,
                361.46
            ],
            "text": " Импортируем E3."
        },
        {
            "timestamp": [
                369.9,
                375.72
            ],
            "text": " Модуль E3 имеет функцию parse, которая принимает в качестве аргумента источник, который может быть файлом или частью файла. Так что в качестве аргумента мы указываем относительный путь к нашему HTML файлу."
        },
        {
            "timestamp": [
                376.26,
                382.78
            ],
            "text": " И давайте создадим переменную E3, в которой сохраним результат."
        },
        {
            "timestamp": [
                393.8,
                400.5
            ],
            "text": " сохраним результат. В качестве аргумента указываем путь к файлу нашему веб-пейдж, он у меня находится в директории src."
        },
        {
            "timestamp": [
                420.86,
                425.0
            ],
            "text": " И давайте выведем значение переменной, сохраним наш скрипт и запустим его в терминале"
        },
        {
            "timestamp": [
                425.0,
                427.86
            ],
            "text": " функция parse как вы видите"
        },
        {
            "timestamp": [
                427.86,
                429.84
            ],
            "text": " возвращает объект"
        },
        {
            "timestamp": [
                429.84,
                431.46
            ],
            "text": " который называется"
        },
        {
            "timestamp": [
                431.46,
                433.52
            ],
            "text": " элемент 3"
        },
        {
            "timestamp": [
                433.52,
                435.26
            ],
            "text": " что произошло"
        },
        {
            "timestamp": [
                435.26,
                438.9
            ],
            "text": " функция parse берет html файл"
        },
        {
            "timestamp": [
                438.9,
                441.94
            ],
            "text": " и преобразует его в дерево"
        },
        {
            "timestamp": [
                441.94,
                444.28
            ],
            "text": " о дереве html мы говорили с вами во"
        },
        {
            "timestamp": [
                444.28,
                445.32
            ],
            "text": " второй лекции."
        },
        {
            "timestamp": [
                445.32,
                447.44
            ],
            "text": " Сейчас возвращаемся к этой теме."
        },
        {
            "timestamp": [
                447.44,
                451.86
            ],
            "text": " С нашей точки зрения, HTML файл – это текст с определенным"
        },
        {
            "timestamp": [
                451.86,
                453.18
            ],
            "text": " синтаксисом внутри."
        },
        {
            "timestamp": [
                453.18,
                458.82
            ],
            "text": " В то же время, XML или HTML может быть рассмотрено"
        },
        {
            "timestamp": [
                458.82,
                461.0
            ],
            "text": " как дерево элементов."
        },
        {
            "timestamp": [
                461.0,
                466.5
            ],
            "text": " Давайте посмотрим на нашем примере и выведем элементы дерева."
        },
        {
            "timestamp": [
                466.54,
                472.22
            ],
            "text": " Чтобы вывести элементы дерева, воспользуемся уже готовым скриптом."
        },
        {
            "timestamp": [
                473.14,
                475.18
            ],
            "text": " У меня он называется Parse3."
        },
        {
            "timestamp": [
                476.66,
                481.68
            ],
            "text": " Давайте его запустим. Я не буду сейчас погружаться в детали кода."
        },
        {
            "timestamp": [
                482.64,
                486.76
            ],
            "text": " Вы можете, используя конспект лекции, разобраться, поскольку сейчас это не"
        },
        {
            "timestamp": [
                486.76,
                507.56
            ],
            "text": " является целью нашей лекции. Запустим скрипт. Итак, что мы получили? Мы получили древовидную структуру, в которой все теги преобразованы в объекты элемент."
        },
        {
            "timestamp": [
                508.32,
                514.98
            ],
            "text": " В этой древовидной структуре элемент HTML является корневым элементом."
        },
        {
            "timestamp": [
                515.36,
                519.84
            ],
            "text": " И у него есть два дочерних элемента head и body."
        },
        {
            "timestamp": [
                519.84,
                524.0
            ],
            "text": " Элемент head имеет один дочерний элемент title."
        },
        {
            "timestamp": [
                524.4,
                529.72
            ],
            "text": " Элемент body имеет два дочерний элемент, title. Элемент body имеет два дочерних элемента, p и ul."
        },
        {
            "timestamp": [
                530.62,
                536.66
            ],
            "text": " Элемент ul, в свою очередь, имеет два дочерних элемента, это элементы li."
        },
        {
            "timestamp": [
                536.66,
                543.2
            ],
            "text": " Первый элемент li имеет атрибут id, установленный на myid."
        },
        {
            "timestamp": [
                543.98,
                548.82
            ],
            "text": " И второй элемент li имеет атрибут class, установленный в myClass,"
        },
        {
            "timestamp": [
                548.82,
                557.34
            ],
            "text": " и содержит один дочерний элемент, элемент a. В общем, в древовидной структуре HTML элемент"
        },
        {
            "timestamp": [
                557.34,
                567.56
            ],
            "text": " считается родительским, если он имеет один или несколько дочерних элементов, а дочерний элемент это элемент вложенный в другой элемент."
        },
        {
            "timestamp": [
                567.56,
                577.32
            ],
            "text": " Итак, давайте представим, что мы хотим извлечь или сделать скрепинг заголовка нашей HTML страницы."
        },
        {
            "timestamp": [
                577.32,
                586.7
            ],
            "text": " Мы можем это сделать, потому что теперь у нас есть дерево элементов и существует метод, который позволяет извлечь заголовок из нашей"
        },
        {
            "timestamp": [
                586.7,
                587.7
            ],
            "text": " веб-страницы."
        },
        {
            "timestamp": [
                587.7,
                595.2
            ],
            "text": " У нашего объекта Element3 есть метод find, который принимает"
        },
        {
            "timestamp": [
                595.2,
                599.26
            ],
            "text": " в качестве аргумента путь к элементу или тегу, который"
        },
        {
            "timestamp": [
                599.26,
                600.5
            ],
            "text": " мы хотим извлечь."
        },
        {
            "timestamp": [
                600.5,
                607.48
            ],
            "text": " В нашей HTML-разметке мы знаем, что заголовок находится внутри тега head."
        },
        {
            "timestamp": [
                608.04,
                615.8
            ],
            "text": " Поэтому в методе find мы вводим строковое значение путь к заголовку headTitle."
        },
        {
            "timestamp": [
                615.98,
                619.56
            ],
            "text": " Давайте создадим новую переменную."
        },
        {
            "timestamp": [
                620.72,
                635.54
            ],
            "text": " Назовем ее titleElement и используем метод find."
        },
        {
            "timestamp": [
                637.54,
                643.64
            ],
            "text": " В качестве аргумента укажем путь к заголовку."
        },
        {
            "timestamp": [
                643.68,
                645.54
            ],
            "text": " Укажем путь к заголовку."
        },
        {
            "timestamp": [
                652.38,
                656.68
            ],
            "text": " И на этот раз выведем значение переменной titleElement."
        },
        {
            "timestamp": [
                661.94,
                666.92
            ],
            "text": " Сохраним скрипт и запустим его еще раз. Это выражение вернет элемент title."
        },
        {
            "timestamp": [
                667.28,
                669.84
            ],
            "text": " Объект элемент типа title."
        },
        {
            "timestamp": [
                670.78,
                674.84
            ],
            "text": " Если теперь мы хотим вывести фактическое значение заголовка,"
        },
        {
            "timestamp": [
                674.84,
                678.58
            ],
            "text": " то можем вызвать свойство текст элемента title."
        },
        {
            "timestamp": [
                678.92,
                680.24
            ],
            "text": " Давайте допишем в код."
        },
        {
            "timestamp": [
                681.26,
                682.66
            ],
            "text": " Точка текст."
        },
        {
            "timestamp": [
                683.46,
                686.86
            ],
            "text": " Сохраним скрипт."
        },
        {
            "timestamp": [
                688.68,
                689.56
            ],
            "text": " Очистим терминал."
        },
        {
            "timestamp": [
                691.2,
                765.08
            ],
            "text": " И запустим скрипт еще раз. Пожалуйста, мы получили текстовое значение элемента title. Thank you. И так далее. на этот вопрос, давайте посмотрим еще раз код нашей веб-страницы."
        },
        {
            "timestamp": [
                769.68,
                773.56
            ],
            "text": " И здесь видно, что тег title находится внутри тега head, а тег head находится внутри тега html."
        },
        {
            "timestamp": [
                774.74,
                779.82
            ],
            "text": " Мы всегда должны начинать с одного из прямых дочерних"
        },
        {
            "timestamp": [
                779.82,
                780.6
            ],
            "text": " элементов."
        },
        {
            "timestamp": [
                781.1,
                794.34
            ],
            "text": " Например, если мы хотим выбрать тег абзаца p,hello.geekbrains, мы должны начать с тега body, потому что body является прямым дочерним элементом тега HTML."
        },
        {
            "timestamp": [
                795.02,
                801.32
            ],
            "text": " Выведите текст абзаца p.hello.geekbrains, используя метод find."
        },
        {
            "timestamp": [
                801.66,
                806.48
            ],
            "text": " Сейчас поставьте видео на паузу и возвращайтесь с результатом."
        },
        {
            "timestamp": [
                806.48,
                826.0
            ],
            "text": " Итак, чтобы вывести содержимое тега p, мы воспользуемся все тем же методом 3.Find, но только изменим путь к тегу абзаца."
        },
        {
            "timestamp": [
                832.12,
                834.12
            ],
            "text": " Путь будет body и наш целевой тег p."
        },
        {
            "timestamp": [
                835.7,
                837.18
            ],
            "text": " Сохраним скрипт."
        },
        {
            "timestamp": [
                838.96,
                840.5
            ],
            "text": " Запустим его в терминале."
        },
        {
            "timestamp": [
                844.12,
                844.46
            ],
            "text": " Пожалуйста, мы получили текст тега p."
        },
        {
            "timestamp": [
                849.68,
                850.28
            ],
            "text": " В качестве альтернативы методу find у нас есть другой метод findAll."
        },
        {
            "timestamp": [
                854.0,
                854.46
            ],
            "text": " Аналогично тому, как мы изучали с beautiful soup."
        },
        {
            "timestamp": [
                860.7,
                861.38
            ],
            "text": " По его названию понятно, что он будет находить все совпадающие теги и возвращать их в виде списка."
        },
        {
            "timestamp": [
                868.34,
                875.76
            ],
            "text": " Например, чтобы выбрать все элементы списка, которые находятся внутри тега ul, давайте посмотрим в нашем html коде. Итак, мы хотим выбрать все элементы списка внутри ul,"
        },
        {
            "timestamp": [
                875.76,
                885.86
            ],
            "text": " мы должны использовать метод findAll, потому что если мы используем метод find, то получим только первый элемент списка."
        },
        {
            "timestamp": [
                891.38,
                912.08
            ],
            "text": " Давайте попробуем извлечь элементы li или элементы списка. Вернемся в наш скрипт и создадим переменную listItem и используем на этот раз метод findAll."
        },
        {
            "timestamp": [
                912.08,
                924.0
            ],
            "text": " И в качестве пути укажем body, список, ul и элементы.li."
        },
        {
            "timestamp": [
                924.94,
                925.28
            ],
            "text": " И выведем наш список элементов. Список UL и элементы LI."
        },
        {
            "timestamp": [
                929.14,
                935.76
            ],
            "text": " И выведем наш список элементов."
        },
        {
            "timestamp": [
                938.6,
                939.34
            ],
            "text": " Сохраняем скрипт."
        },
        {
            "timestamp": [
                940.3,
                949.1
            ],
            "text": " Запускаем его. Мы получили список из двух элементов типа li. Чтобы извлечь текстовое содержимое,"
        },
        {
            "timestamp": [
                949.1,
                975.18
            ],
            "text": " нужно обратиться к каждому элементу списка отдельно, поэтому нам придется создать цикл for и в цикле проходим по каждому элементу и выводим его."
        },
        {
            "timestamp": [
                980.18,
                983.4
            ],
            "text": " И выведем текстовое содержимое."
        },
        {
            "timestamp": [
                984.04,
                986.66
            ],
            "text": " Сохраняем скрипт, запускаем его."
        },
        {
            "timestamp": [
                987.26,
                993.62
            ],
            "text": " Обратите внимание, что для первого элемента списка мы получили полное текстовое значение."
        },
        {
            "timestamp": [
                994.44,
                998.9
            ],
            "text": " Однако для второго элемента списка мы не видим содержимого тега a."
        },
        {
            "timestamp": [
                998.9,
                1006.76
            ],
            "text": " Причина здесь в том, что в методе findAll мы указали, что хотим получить все элементы списка и нас не интересует,"
        },
        {
            "timestamp": [
                1007.24,
                1013.76
            ],
            "text": " есть ли внутри него тег a. Чтобы решить эту проблему, нужно внутри цикла создать переменную"
        },
        {
            "timestamp": [
                1013.76,
                1029.72
            ],
            "text": " или что-то еще. Поэтому одно быстрое решение, которое мы можем применить, это осуществить поиск внутри цикла for. Давайте создадим переменную еще одну внутри цикла, назовем ее a,"
        },
        {
            "timestamp": [
                1029.72,
                1057.0
            ],
            "text": " и внутри элемента li используем метод find для поиска тега a. Так как у нас только один элемент содержит тег a, то используем оператор if, и если a не равно non, значит внутри элемента списка есть тег a, содержимое которого мы соответственно и выведем."
        },
        {
            "timestamp": [
                1083.32,
                1085.08
            ],
            "text": " Если А из нот нон, иными словами, если А существует, то выведем его в текстовое содержимое."
        },
        {
            "timestamp": [
                1090.38,
                1098.38
            ],
            "text": " Здесь мы это должны заключить в фигурные скобки."
        },
        {
            "timestamp": [
                1108.18,
                1112.6
            ],
            "text": " В противном значении просто выводим текстовое содержимое элемента a."
        },
        {
            "timestamp": [
                1112.6,
                1115.0
            ],
            "text": " Этот принт нам больше не нужен, сохраняем."
        },
        {
            "timestamp": [
                1115.0,
                1120.0
            ],
            "text": " Я здесь не указал кавычки."
        },
        {
            "timestamp": [
                1120.0,
                1132.18
            ],
            "text": " Сохраняем и запускаем скрипт Обратите внимание, что теперь мы получили текстовое содержимое тега a со словом developer"
        },
        {
            "timestamp": [
                1132.18,
                1135.72
            ],
            "text": " Но перед словом developer есть большой пробел"
        },
        {
            "timestamp": [
                1135.72,
                1142.04
            ],
            "text": " Это связано с нашей HTML разметкой, где есть пробелы перед словом developer"
        },
        {
            "timestamp": [
                1142.04,
                1146.16
            ],
            "text": " Чтобы очистить вывод, мы можем использовать метод"
        },
        {
            "timestamp": [
                1146.16,
                1154.56
            ],
            "text": " python.strip."
        },
        {
            "timestamp": [
                1154.56,
                1163.88
            ],
            "text": " Добавим в код strip, сохраняем и запускаем наш скрипт еще"
        },
        {
            "timestamp": [
                1163.88,
                1164.88
            ],
            "text": " раз."
        },
        {
            "timestamp": [
                1164.88,
                1166.24
            ],
            "text": " На этот раз все в порядке."
        },
        {
            "timestamp": [
                1166.68,
                1172.06
            ],
            "text": " Одним из недостатков LXML является то, что он не богат в плане методов,"
        },
        {
            "timestamp": [
                1172.24,
                1175.24
            ],
            "text": " которые открываются нам через объекты Element3."
        },
        {
            "timestamp": [
                1175.76,
                1180.0
            ],
            "text": " Более того, каждый раз, когда мы хотим выбрать тег из разметки HTML,"
        },
        {
            "timestamp": [
                1180.38,
                1182.76
            ],
            "text": " мы должны указать абсолютный путь до тега."
        },
        {
            "timestamp": [
                1182.98,
                1187.96
            ],
            "text": " Если мы имеем дело с большой HTML-страницей, это может быть проблемой."
        },
        {
            "timestamp": [
                1188.08,
                1195.06
            ],
            "text": " Чтобы решить эту проблему, существует более эффективный метод выбора тегов с помощью XPath."
        },
        {
            "timestamp": [
                1195.52,
                1197.0
            ],
            "text": " Переходим к следующей теме."
        },
        {
            "timestamp": [
                1197.68,
                1199.16
            ],
            "text": " Что такое XPath?"
        },
        {
            "timestamp": [
                1200.0,
                1207.88
            ],
            "text": " XPath означает XML Path Language, язык запросов к элементам XML документа."
        },
        {
            "timestamp": [
                1208.2,
                1214.66
            ],
            "text": " Язык Xpath используется для уникальной идентификации или адресации частей XML документа."
        },
        {
            "timestamp": [
                1214.66,
                1223.0
            ],
            "text": " Выражение Xpath можно использовать для поиска в XML документе и извлечения информации из любой части документа."
        },
        {
            "timestamp": [
                1229.24,
                1235.14
            ],
            "text": " информации из любой части документа. Например, элемента или атрибута. В XML он называется узлом или node. Но это, конечно, не означает, что мы не можем использовать его для запроса и выбора"
        },
        {
            "timestamp": [
                1235.14,
                1243.28
            ],
            "text": " элементов или тегов из HTML-страницы. Мы начнем изучение XPath с выражений. XPath expressions."
        },
        {
            "timestamp": [
                1241.42,
                1241.8
            ],
            "text": " xpath с выражений."
        },
        {
            "timestamp": [
                1243.28,
                1243.96
            ],
            "text": " xpath expressions."
        },
        {
            "timestamp": [
                1248.02,
                1248.48
            ],
            "text": " Выражение, определяющее шаблон для выбора узлов."
        },
        {
            "timestamp": [
                1252.18,
                1253.94
            ],
            "text": " Как мы уже обсуждали, HTML документ рассматривается как дерево узлов."
        },
        {
            "timestamp": [
                1254.2,
                1259.48
            ],
            "text": " В xpath мы можем выбрать элемент, используя двойной слэш и"
        },
        {
            "timestamp": [
                1259.48,
                1261.5
            ],
            "text": " затем имя элемента."
        },
        {
            "timestamp": [
                1261.5,
                1268.9
            ],
            "text": " Например, если вы хотите выбрать все div на HTML-странице, мы используем двойной"
        },
        {
            "timestamp": [
                1268.9,
                1278.32
            ],
            "text": " слэш div. Также мы можем выбрать элементы по их атрибуту, ID или классу, добавляя две квадратные"
        },
        {
            "timestamp": [
                1278.32,
                1288.0
            ],
            "text": " скобки, следующие за именем элемента, а затем значение атрибута. Мы можем выбрать элемент на основе его позиции."
        },
        {
            "timestamp": [
                1288.0,
                1292.0
            ],
            "text": " Например, если вы хотите выбрать первый элемент списка ul,"
        },
        {
            "timestamp": [
                1292.0,
                1296.0
            ],
            "text": " то в квадратных скобках указываем 1."
        },
        {
            "timestamp": [
                1296.0,
                1300.0
            ],
            "text": " Если мы хотим выбрать первый и второй элемент списка,"
        },
        {
            "timestamp": [
                1300.0,
                1305.5
            ],
            "text": " мы должны использовать функцию position плюс логический оператор."
        },
        {
            "timestamp": [
                1305.5,
                1309.72
            ],
            "text": " Например, li и в квадратных скобках указываем position"
        },
        {
            "timestamp": [
                1309.72,
                1312.38
            ],
            "text": " равно 1 или position равно 2."
        },
        {
            "timestamp": [
                1312.38,
                1316.52
            ],
            "text": " Чтобы выбрать только первый элемент списка, и этот первый"
        },
        {
            "timestamp": [
                1316.52,
                1321.1
            ],
            "text": " элемент списка должен содержать текст hello, то мы используем"
        },
        {
            "timestamp": [
                1321.1,
                1322.5
            ],
            "text": " функцию contains."
        },
        {
            "timestamp": [
                1322.5,
                1330.14
            ],
            "text": " В xpath все, что мы пишем в квадратных скобках, называется предикатом или условием."
        },
        {
            "timestamp": [
                1330.48,
                1333.78
            ],
            "text": " У XPath есть еще одно полезное свойство."
        },
        {
            "timestamp": [
                1333.78,
                1339.14
            ],
            "text": " Это возможность перемещаться в дереве HTML вверх или вниз,"
        },
        {
            "timestamp": [
                1339.56,
                1342.92
            ],
            "text": " используя то, что называется оси XPath."
        },
        {
            "timestamp": [
                1343.2,
                1347.8
            ],
            "text": " В XPath оси – это способ выбора элементов, которые находятся"
        },
        {
            "timestamp": [
                1347.8,
                1353.62
            ],
            "text": " относительно текущего элемента в иерархии документа. Ось – это именованная связь между"
        },
        {
            "timestamp": [
                1353.62,
                1362.0
            ],
            "text": " элементами, которая определяет направление и набор узлов для выбора. Например, ось предков"
        },
        {
            "timestamp": [
                1362.0,
                1365.68
            ],
            "text": " выбирает все элементы предки,"
        },
        {
            "timestamp": [
                1365.68,
                1370.06
            ],
            "text": " то есть элементы расположенные выше в иерархии документа,"
        },
        {
            "timestamp": [
                1370.06,
                1375.32
            ],
            "text": " а ось потомков выбирает все элементы потомки,"
        },
        {
            "timestamp": [
                1375.32,
                1378.12
            ],
            "text": " которые идут после текущего элемента."
        },
        {
            "timestamp": [
                1378.12,
                1380.42
            ],
            "text": " Синтаксис на слайде."
        },
        {
            "timestamp": [
                1380.42,
                1388.44
            ],
            "text": " Мы указываем имя оси, двойное двоеточие и затем целевой элемент, который мы ищем."
        },
        {
            "timestamp": [
                1388.48,
                1392.86
            ],
            "text": " Для перехода вверх по дереву HTML есть 4 оси."
        },
        {
            "timestamp": [
                1393.3,
                1398.56
            ],
            "text": " Первая называется parent, которая возвращает родителя указанного узла."
        },
        {
            "timestamp": [
                1398.78,
                1407.26
            ],
            "text": " Вторая ancestor, чтобы получить всех предков определенного узла. Третья ось Preceding выбирает все узлы,"
        },
        {
            "timestamp": [
                1407.44,
                1411.94
            ],
            "text": " которые появляются перед текущим узлом за исключением предков,"
        },
        {
            "timestamp": [
                1412.66,
                1414.9
            ],
            "text": " узлов, атрибутов и пространства имя."
        },
        {
            "timestamp": [
                1415.46,
                1420.2
            ],
            "text": " Четвертая Preceding Sibling возвращает братьев определенного элемента,"
        },
        {
            "timestamp": [
                1420.32,
                1423.4
            ],
            "text": " то есть все элементы одного уровня до текущего узла."
        },
        {
            "timestamp": [
                1423.72,
                1428.34
            ],
            "text": " Для перехода вниз по дереву HTML существуют следующие оси."
        },
        {
            "timestamp": [
                1428.64,
                1434.68
            ],
            "text": " Ось Child, которая будет получать дочерние элементы потомков определенного узла."
        },
        {
            "timestamp": [
                1435.26,
                1441.38
            ],
            "text": " Ось Following вернет все элементы, находящиеся после закрывающего тега определенного узла."
        },
        {
            "timestamp": [
                1442.08,
                1445.94
            ],
            "text": " Ось Following Sibling возвращает все элементы одного уровня"
        },
        {
            "timestamp": [
                1445.94,
                1452.42
            ],
            "text": " после текущего узла. И наконец ось Descendant возвращает всех потомков"
        },
        {
            "timestamp": [
                1452.42,
                1459.0
            ],
            "text": " текущего узла. Перейдем к следующей части и посмотрим как на практике применять"
        },
        {
            "timestamp": [
                1459.0,
                1465.3
            ],
            "text": " xpath в рамках LXML. Итак, возвращаемся в VS Code."
        },
        {
            "timestamp": [
                1466.32,
                1470.08
            ],
            "text": " Удалим лишние строки, которые нам сейчас не нужны."
        },
        {
            "timestamp": [
                1470.54,
                1472.44
            ],
            "text": " Оставим только дерево элементов."
        },
        {
            "timestamp": [
                1473.64,
                1477.54
            ],
            "text": " Для выбора тегов с помощью XPath в LXML"
        },
        {
            "timestamp": [
                1477.54,
                1480.74
            ],
            "text": " мы можем заменить наш метод find,"
        },
        {
            "timestamp": [
                1480.86,
                1484.32
            ],
            "text": " который мы ранее использовали, методом XPath."
        },
        {
            "timestamp": [
                1484.82,
                1489.68
            ],
            "text": " Метод XPath принимает в качестве аргумента путь к целевому тегу,"
        },
        {
            "timestamp": [
                1489.8,
                1491.66
            ],
            "text": " точно так же, как и метод find."
        },
        {
            "timestamp": [
                1492.08,
                1497.5
            ],
            "text": " Но особенность его состоит в том, что нам не нужно указывать полный путь для тега."
        },
        {
            "timestamp": [
                1497.88,
                1501.38
            ],
            "text": " Давайте попробуем выполнить парсинг заголовка."
        },
        {
            "timestamp": [
                1502.38,
                1531.28
            ],
            "text": " Создадим переменную titleElement, возьмем наше дерево и на этот раз вместо метода качестве аргумента просто указываем тег title и выведем его на печать."
        },
        {
            "timestamp": [
                1531.28,
                1538.06
            ],
            "text": " Метод xpath возвращает список, поэтому чтобы получить доступ к свойству текст"
        },
        {
            "timestamp": [
                1538.06,
                1552.48
            ],
            "text": " нам нужно получить доступ к первому элементу списка, поэтому выведем title элемент и используем первый элемент"
        },
        {
            "timestamp": [
                1552.48,
                1568.38
            ],
            "text": " списка и возьмем текст. Сохраняем скрипт и запустим. Мы получили текстовое содержимое тега title."
        },
        {
            "timestamp": [
                1568.38,
                1578.26
            ],
            "text": " Далее xpav позволяет нам получить доступ к тексту без использования свойства текста, связанного с lxml, то есть без вот этого свойства."
        },
        {
            "timestamp": [
                1579.12,
                1581.1
            ],
            "text": " И получить тот же результат."
        },
        {
            "timestamp": [
                1581.46,
                1584.24
            ],
            "text": " Выполняется это следующим образом."
        },
        {
            "timestamp": [
                1584.24,
                1586.24
            ],
            "text": " тот же результат. Выполняется это следующим образом."
        },
        {
            "timestamp": [
                1594.72,
                1599.4
            ],
            "text": " Мы используем функцию текст прямо в xpath выражения и также получаем доступ к первому его элементу. Соответственно,"
        },
        {
            "timestamp": [
                1599.4,
                1609.42
            ],
            "text": " вот эта часть кода нам не нужна. выводим только содержимое значения переменной titleElement."
        },
        {
            "timestamp": [
                1609.42,
                1617.82
            ],
            "text": " Давайте очистим терминал и запустим еще раз наш скрипт. Мы получили тот же самый результат."
        },
        {
            "timestamp": [
                1617.82,
                1627.5
            ],
            "text": " задание. Попробуйте самостоятельно получить доступ к тексту тгп и вывести текст Hello Geek Brains."
        },
        {
            "timestamp": [
                1627.5,
                1630.82
            ],
            "text": " Поставьте видео на паузу и возвращайтесь, когда сделаете"
        },
        {
            "timestamp": [
                1630.82,
                1631.82
            ],
            "text": " задание."
        },
        {
            "timestamp": [
                1631.82,
                1640.18
            ],
            "text": " Возвращаемся в VS Code."
        },
        {
            "timestamp": [
                1640.18,
                1644.24
            ],
            "text": " Давайте теперь получим данные из списка в HTML документе"
        },
        {
            "timestamp": [
                1644.24,
                1645.24
            ],
            "text": " с помощью XPath."
        },
        {
            "timestamp": [
                1645.24,
                1651.28
            ],
            "text": " Только на этот раз не будем использовать функцию текст, а воспользуемся методом toString."
        },
        {
            "timestamp": [
                1652.1,
                1658.14
            ],
            "text": " Создадим переменную listItems."
        },
        {
            "timestamp": [
                1670.52,
                1695.9
            ],
            "text": " Используем метод xPath для выбора всех элементов li. Далее в цикле for для каждого listItems выведем его значение, используя метод toString."
        },
        {
            "timestamp": [
                1695.9,
                1699.34
            ],
            "text": " В качестве аргумента используем li."
        },
        {
            "timestamp": [
                1700.26,
                1702.92
            ],
            "text": " Сохраняем скрипт и запускаем."
        },
        {
            "timestamp": [
                1702.92,
                1703.48
            ],
            "text": " Сохраняем скрипт и запускаем."
        },
        {
            "timestamp": [
                1712.3,
                1712.84
            ],
            "text": " После выполнения кода мы увидим, что получили два списка элементов, содержащих полную HTML-разметку."
        },
        {
            "timestamp": [
                1731.7,
                1747.04
            ],
            "text": " Чтобы получить текст, который находится внутри элементов списка, давайте создадим переменную в цикле, которая будет применять функцию XPathText к каждому элементу списка. Создадим переменную text, которая будет брать каждый элемент li, применять к нему метод xpath и, И используя функцию текст, извлекать текст."
        },
        {
            "timestamp": [
                1749.94,
                1755.9
            ],
            "text": " И выводим значение переменной текст в каждой итерации."
        },
        {
            "timestamp": [
                1758.4,
                1761.28
            ],
            "text": " Очистим экран терминала и еще раз запускаем."
        },
        {
            "timestamp": [
                1761.62,
                1764.62
            ],
            "text": " После выполнения кода мы снова получаем два списка."
        },
        {
            "timestamp": [
                1766.8,
                1774.22
            ],
            "text": " и еще раз запускаем. После выполнения кода мы снова получаем два списка, однако все еще мы получаем текст со всеми специальными символами, находящимися в HTML коде. Чтобы это исправить, нужно всего"
        },
        {
            "timestamp": [
                1774.22,
                1783.68
            ],
            "text": " лишь добавить точку перед двойным слэшем функции текст. То есть здесь мы просто ставим точку,"
        },
        {
            "timestamp": [
                1788.86,
                1789.3
            ],
            "text": " То есть здесь мы просто ставим точку, сохраняем, запускаем скрипт еще раз."
        },
        {
            "timestamp": [
                1792.84,
                1793.16
            ],
            "text": " На этот раз получаем только текст двух тегов li."
        },
        {
            "timestamp": [
                1798.22,
                1798.34
            ],
            "text": " Пока что мы получили два списка, первый из которых содержит только один элемент с текстом,"
        },
        {
            "timestamp": [
                1801.86,
                1802.34
            ],
            "text": " а второй содержит три элемента, но все еще содержит пробелы."
        },
        {
            "timestamp": [
                1805.24,
                1807.46
            ],
            "text": " Давайте избавимся от этих лишних символов. Для этого мы можем использовать метод map,"
        },
        {
            "timestamp": [
                1807.7,
                1810.68
            ],
            "text": " который принимает в качестве первого аргумента функцию,"
        },
        {
            "timestamp": [
                1811.12,
                1813.84
            ],
            "text": " которая будет применена к каждому элементу списка."
        },
        {
            "timestamp": [
                1814.48,
                1818.64
            ],
            "text": " И используем стрип, чтобы удалить все пробелы и n,"
        },
        {
            "timestamp": [
                1818.92,
                1820.14
            ],
            "text": " символы переноса строки."
        },
        {
            "timestamp": [
                1821.38,
                1822.74
            ],
            "text": " Дополним наш код."
        },
        {
            "timestamp": [
                1850.16,
                1855.14
            ],
            "text": " Используем map и применим стрип к каждому элементу. Далее преобразуем в список наш вывод,"
        },
        {
            "timestamp": [
                1858.54,
                1859.26
            ],
            "text": " очистим терминал и запускаем скрипт еще раз."
        },
        {
            "timestamp": [
                1863.46,
                1866.3
            ],
            "text": " Наконец, чтобы код возвращал не списки, а только код текст, мы можем использовать другую функцию Python."
        },
        {
            "timestamp": [
                1866.3,
                1867.36
            ],
            "text": " Python.join."
        },
        {
            "timestamp": [
                1874.36,
                1878.58
            ],
            "text": " И здесь, в свою очередь, нам уже список больше не нужен."
        },
        {
            "timestamp": [
                1879.64,
                1885.22
            ],
            "text": " Выводим значение переменной текст, сохраняем скрипт и запускаем его в терминале."
        },
        {
            "timestamp": [
                1886.56,
                1889.06
            ],
            "text": " Мы получили чистый текст."
        },
        {
            "timestamp": [
                1889.4,
                1893.86
            ],
            "text": " Наконец, давайте посмотрим пример работы с осями XP."
        },
        {
            "timestamp": [
                1894.9,
                1900.92
            ],
            "text": " Выберем все элементы li, которые являются потомками элемента ul."
        },
        {
            "timestamp": [
                1908.32,
                1912.24
            ],
            "text": " Если я говорю немного непонятно, возвращайтесь к HTML коду и сверяйтесь с исходным HTML кодом."
        },
        {
            "timestamp": [
                1912.24,
                1933.5
            ],
            "text": " Итак, меняем выражение XPath, чтобы выбрать всех потомков тега UL. Для этого используется слово descendant"
        },
        {
            "timestamp": [
                1933.5,
                1951.44
            ],
            "text": " li. Сохраняем, запускаем скрипт. Вы можете свериться с HTML и убедиться, что мы выбрали все элементы li, которые являются потомками элемента ul."
        },
        {
            "timestamp": [
                1951.66,
                1959.48
            ],
            "text": " Таким образом, XPath это мощный инструмент для выбора и навигации по элементам в документах XML и HTML,"
        },
        {
            "timestamp": [
                1959.84,
                1968.78
            ],
            "text": " который особенно полезен для задач веб-скрейпинга и извлечения данных. В этой части лекции мы рассмотрели основы использования XPub в LXML"
        },
        {
            "timestamp": [
                1968.78,
                1972.94
            ],
            "text": " для выбора и извлечения данных из HTML документов."
        },
        {
            "timestamp": [
                1973.14,
                1976.18
            ],
            "text": " А сейчас давайте познакомимся с еще одним инструментом"
        },
        {
            "timestamp": [
                1976.18,
                1981.08
            ],
            "text": " для извлечения данных из HTML-кода, это CSS-селектора."
        },
        {
            "timestamp": [
                1981.08,
                1986.3
            ],
            "text": " Как вы знаете, CSS служит для стилизации HTML-страниц."
        },
        {
            "timestamp": [
                1986.3,
                1997.48
            ],
            "text": " Идея состоит в том, что для скрейпинга мы можем использовать LXML вместе с CSS-селекторами для скрейпинга тега или элемента стилизации веб-страниц."
        },
        {
            "timestamp": [
                1997.64,
                2003.42
            ],
            "text": " Для использования CSS-селекторов нам нужно установить модуль под названием CSS-селект."
        },
        {
            "timestamp": [
                2008.82,
                2028.34
            ],
            "text": " установить модуль под названием css select. Устанавливается он в терминале посредством pip css select. Здесь ничего особенного, у меня он уже установлен. Теперь в нашем коде мы можем использовать метод CSS Select, который принимает"
        },
        {
            "timestamp": [
                2028.34,
                2045.0
            ],
            "text": " в качестве аргумента CSS Selector. Например, чтобы выбрать заголовок из HTML страницы, все, что нам Давайте в очередной раз перепишем наш скрипт."
        },
        {
            "timestamp": [
                2048.14,
                2061.92
            ],
            "text": " Создадим переменную titleElement и на этот раз используем метод CSSSelect."
        },
        {
            "timestamp": [
                2061.92,
                2092.32
            ],
            "text": " В качестве аргумента указываем title и выведем значение, которое также будет представлено в виде списка, поэтому берем только нулевой элемент или первый элемент, сохраняем скрипт"
        },
        {
            "timestamp": [
                2092.32,
                2097.48
            ],
            "text": " и запускаем наш код."
        },
        {
            "timestamp": [
                2097.48,
                2101.68
            ],
            "text": " Если выполнить файл в таком виде, то мы, как вы видите,"
        },
        {
            "timestamp": [
                2101.68,
                2103.68
            ],
            "text": " получили ошибку attributeError."
        },
        {
            "timestamp": [
                2103.68,
                2110.14
            ],
            "text": " Это связано с тем, что CSS Select работает непосредственно с HTML элементами,"
        },
        {
            "timestamp": [
                2110.38,
                2113.78
            ],
            "text": " а не с объектом Element3, как это делает XPub."
        },
        {
            "timestamp": [
                2114.16,
                2118.2
            ],
            "text": " Поэтому предварительно нужно конвертировать Element3."
        },
        {
            "timestamp": [
                2118.82,
                2135.28
            ],
            "text": " Создадим для этого новую переменную, назовем ее html и воспользуемся функцией"
        },
        {
            "timestamp": [
                2135.28,
                2139.12
            ],
            "text": " getRoot."
        },
        {
            "timestamp": [
                2139.12,
                2154.0
            ],
            "text": " Эта функция конвертирует объект дерева в HTML элемент. Сохраняем наш скрипт, очистим терминал и запускаем скрипт."
        },
        {
            "timestamp": [
                2154.0,
                2173.68
            ],
            "text": " И здесь я снова получил ошибку attributeError. У объекта нет атрибута CSS Select. с с с select это связано с тем что здесь нужно 3 поменять на html исправляем сохраняем и запускаем"
        },
        {
            "timestamp": [
                2173.68,
                2190.86
            ],
            "text": " еще раз на этот раз все в порядке мы получили текстовое содержимое тега тайт задание. используйте метод css selector вместо xpav и выберите тег абзаца."
        },
        {
            "timestamp": [
                2190.86,
                2208.38
            ],
            "text": " поставьте видео на паузу и после выполнения возвращайтесь. Итак, CSS Select и XPath – это два разных языка запросов,"
        },
        {
            "timestamp": [
                2208.38,
                2212.14
            ],
            "text": " используемых для извлечения данных из документов HTML"
        },
        {
            "timestamp": [
                2212.14,
                2213.46
            ],
            "text": " и XML."
        },
        {
            "timestamp": [
                2213.46,
                2217.68
            ],
            "text": " Хотя оба языка служат схожим целям, у них есть несколько"
        },
        {
            "timestamp": [
                2217.68,
                2221.08
            ],
            "text": " ключевых различий, которые делают их подходящими"
        },
        {
            "timestamp": [
                2221.08,
                2223.38
            ],
            "text": " для разных случаев использования."
        },
        {
            "timestamp": [
                2223.38,
                2227.24
            ],
            "text": " XPath – более мощный и гибкий язык запросов, чем CSS Select,"
        },
        {
            "timestamp": [
                2227.64,
                2230.86
            ],
            "text": " поскольку он позволяет использовать более сложные выражения"
        },
        {
            "timestamp": [
                2230.86,
                2234.62
            ],
            "text": " и поддерживает более широкий спектр типов данных и функций."
        },
        {
            "timestamp": [
                2235.0,
                2241.52
            ],
            "text": " XPath также поддерживает оси, которые позволяют перемещаться по иерархии дерева"
        },
        {
            "timestamp": [
                2241.52,
                2246.0
            ],
            "text": " и выбирать элементы на основе их связи с другими элементами."
        },
        {
            "timestamp": [
                2246.0,
                2251.6
            ],
            "text": " CSS Select, с другой стороны, является более простым и лаконичным языком запросов."
        },
        {
            "timestamp": [
                2251.6,
                2256.62
            ],
            "text": " CSS Select может быть полезен для задач веб-скрейпинга, связанных с выбором"
        },
        {
            "timestamp": [
                2256.62,
                2262.4
            ],
            "text": " элементов на основе их класса, ID или других CSS-селекторов, и часто для таких"
        },
        {
            "timestamp": [
                2262.4,
                2267.24
            ],
            "text": " задач его просто проще понимать и использовать чем экспо одним из основных преимуществ"
        },
        {
            "timestamp": [
                2268.22,
                2273.18
            ],
            "text": " ссср select перед экспо является то что он может быть быстрее и эффективнее"
        },
        {
            "timestamp": [
                2273.74,
                2279.64
            ],
            "text": " для определенных типов выбора особенно при выборе на основе атрибутов класса или айди"
        },
        {
            "timestamp": [
                2279.92,
                2296.96
            ],
            "text": " однако важно отметить что экспо в целом является более мощным и гибким языком запросов и лучше подходит для более сложных задач извлечения данных, которые включают выбор элементов на основе их текстового содержимого, структуры и других атрибутов."
        },
        {
            "timestamp": [
                2297.24,
                2301.86
            ],
            "text": " В целом, выбор языка зависит от конкретных требований задачи извлечения данных."
        },
        {
            "timestamp": [
                2302.18,
                2306.18
            ],
            "text": " А сейчас давайте перейдем к скрейпингу веб-сайта"
        },
        {
            "timestamp": [
                2306.18,
                2308.08
            ],
            "text": " с помощью XPath."
        },
        {
            "timestamp": [
                2308.08,
                2310.64
            ],
            "text": " Мы переходим к следующему разделу лекции и займемся"
        },
        {
            "timestamp": [
                2310.64,
                2314.38
            ],
            "text": " скрейпингом сайта IMDb, а именно страницы с топ"
        },
        {
            "timestamp": [
                2314.38,
                2316.32
            ],
            "text": " наиболее популярных фильмов."
        },
        {
            "timestamp": [
                2316.32,
                2318.7
            ],
            "text": " Познакомимся с некоторыми хитростями, которые помогут"
        },
        {
            "timestamp": [
                2318.7,
                2322.88
            ],
            "text": " вам скрейпить веб-страницы, избавимся от ненужных классов,"
        },
        {
            "timestamp": [
                2322.88,
                2325.6
            ],
            "text": " внедренных в JavaScript, а также сохраним скрипированные"
        },
        {
            "timestamp": [
                2325.6,
                2333.48
            ],
            "text": " данные в базе данных MongoDB. Давайте напишем код, который будет извлекать из приведенной таблицы"
        },
        {
            "timestamp": [
                2333.48,
                2347.1
            ],
            "text": " название, место в рейтинге, изменение в место в рейтинге на странице наиболее популярных фильмов. Как вы знаете, большинство сайтов используют JavaScript."
        },
        {
            "timestamp": [
                2348.28,
                2352.54
            ],
            "text": " И проблема состоит в том, что библиотека Requests из Python,"
        },
        {
            "timestamp": [
                2352.68,
                2356.24
            ],
            "text": " с которой мы уже знакомы, не понимает, не видит JavaScript."
        },
        {
            "timestamp": [
                2356.84,
                2360.96
            ],
            "text": " Поэтому высоки шансы, что мы не получим ту же самую информацию,"
        },
        {
            "timestamp": [
                2361.2,
                2363.88
            ],
            "text": " которую видим при отображении страницы в браузере."
        },
        {
            "timestamp": [
                2363.88,
                2368.78
            ],
            "text": " Поэтому, чтобы исключить JavaScript из разметки, можно"
        },
        {
            "timestamp": [
                2368.78,
                2371.38
            ],
            "text": " использовать следующий способ."
        },
        {
            "timestamp": [
                2371.38,
                2376.86
            ],
            "text": " В Chrome нажимаем три вертикальных кнопки в правом верхнем"
        },
        {
            "timestamp": [
                2376.86,
                2384.56
            ],
            "text": " углу, переходим в настройки и в настройках нужно найти"
        },
        {
            "timestamp": [
                2384.56,
                2390.64
            ],
            "text": " в поиске элемент с названием JavaScript или просто можно написать Java."
        },
        {
            "timestamp": [
                2391.26,
                2394.84
            ],
            "text": " Здесь находим настройки сайтов, переходим в настройки."
        },
        {
            "timestamp": [
                2396.14,
                2402.66
            ],
            "text": " И в настройках ищем контент и в нем раздел JavaScript."
        },
        {
            "timestamp": [
                2403.38,
                2405.42
            ],
            "text": " Переходим в него."
        },
        {
            "timestamp": [
                2410.66,
                2411.02
            ],
            "text": " И здесь мы видим переключатель, который позволяет разрешить сайтом использовать JavaScript,"
        },
        {
            "timestamp": [
                2413.92,
                2414.3
            ],
            "text": " либо запретить сайтом использовать JavaScript."
        },
        {
            "timestamp": [
                2416.66,
                2417.9
            ],
            "text": " Сейчас мы запрещаем использовать JavaScript."
        },
        {
            "timestamp": [
                2422.68,
                2430.86
            ],
            "text": " Возвращаемся к нашей целевой странице, и ее нужно обновить. После обновления мы видим, что некоторые элементы пропали, например,"
        },
        {
            "timestamp": [
                2430.86,
                2452.02
            ],
            "text": " ваш рейтинг. И в общем-то это тот контент, который видит библиотека requests.python. Давайте перейдем в нашу среду разработки. В среде разработки создадим новый файл, назовем его, например, app2.py."
        },
        {
            "timestamp": [
                2454.12,
                2460.24
            ],
            "text": " И давайте для начала выполним запрос get к нашему целевому сайту."
        },
        {
            "timestamp": [
                2460.24,
                2470.34
            ],
            "text": " Для этого для начала импортируем библиотеку requests."
        },
        {
            "timestamp": [
                2474.74,
                2479.44
            ],
            "text": " Создадим переменную с ответом, назовем ее resp."
        },
        {
            "timestamp": [
                2496.66,
                2508.56
            ],
            "text": " И воспользуемся методом get, который принимает аргументы URL с значением URL адреса нашего целевого сайта. Скопируем адрес, возвращаемся в s-код, вставляем сюда адрес и давайте укажем"
        },
        {
            "timestamp": [
                2508.56,
                2510.14
            ],
            "text": " еще один аргумент."
        },
        {
            "timestamp": [
                2510.14,
                2518.92
            ],
            "text": " Это будет заголовок и в фигурных скобках укажем"
        },
        {
            "timestamp": [
                2518.92,
                2531.12
            ],
            "text": " user agent или агент пользователя где взять агент пользователя ну одним из"
        },
        {
            "timestamp": [
                2531.12,
                2541.44
            ],
            "text": " самых простых способов является просто загуглить его давайте вернемся в chrome и"
        },
        {
            "timestamp": [
                2542.16,
                2546.5
            ],
            "text": " прежде чем получить наш агент пользователя, нужно"
        },
        {
            "timestamp": [
                2546.5,
                2549.6
            ],
            "text": " разрешить сайтам использовать JavaScript."
        },
        {
            "timestamp": [
                2549.6,
                2555.76
            ],
            "text": " И в поиске просто пишем myuseragent."
        },
        {
            "timestamp": [
                2555.76,
                2563.32
            ],
            "text": " И в Chrome отображается наш агент пользователя."
        },
        {
            "timestamp": [
                2563.32,
                2568.04
            ],
            "text": " Копируем его отсюда, возвращаемся в scode и"
        },
        {
            "timestamp": [
                2568.04,
                2582.76
            ],
            "text": " указываем его в аргументе header. Указание вашего агента пользователя в аргументе запроса является"
        },
        {
            "timestamp": [
                2582.76,
                2585.92
            ],
            "text": " хорошим тоном по ряду причин. Во-первых,"
        },
        {
            "timestamp": [
                2586.06,
                2591.9
            ],
            "text": " некоторые веб-сайты могут блокировать запросы, которые не имеют действительного агента-пользователя"
        },
        {
            "timestamp": [
                2591.9,
                2597.9
            ],
            "text": " или имеют необычный агент-пользователя. Во-вторых, некоторые сайты могут предоставлять"
        },
        {
            "timestamp": [
                2597.9,
                2604.46
            ],
            "text": " различное содержимое или различную HTML-разметку в зависимости от пользовательского агента,"
        },
        {
            "timestamp": [
                2606.06,
                2606.34
            ],
            "text": " личную HTML-разметку в зависимости от пользовательского агента, запрашивающего браузера."
        },
        {
            "timestamp": [
                2610.1,
                2610.26
            ],
            "text": " Наконец, некоторые сайты могут иметь соглашение об использовании,"
        },
        {
            "timestamp": [
                2613.2,
                2613.3
            ],
            "text": " которое запрещает скрейпинг или извлечение данных."
        },
        {
            "timestamp": [
                2617.64,
                2621.98
            ],
            "text": " Указывая действительный пользовательский агент в строке запроса, вы идентифицируете себя как законного пользователя сайта,"
        },
        {
            "timestamp": [
                2622.24,
                2625.92
            ],
            "text": " а не скрейпера или бота, который может нарушать условия обслуживания."
        },
        {
            "timestamp": [
                2625.92,
                2641.7
            ],
            "text": " И давайте выведем значение ответа сервера, а точнее статус код, чтобы проверить, что мы получили ответ от сервера."
        },
        {
            "timestamp": [
                2651.28,
                2661.84
            ],
            "text": " ответ от сервера. Сохраняем скрипт, запустим его и здесь мы получили ошибку в связи с тем, что опечатка в аргументе headers. Добавим s, сохраняем и запускаем еще раз. Итак,"
        },
        {
            "timestamp": [
                2661.84,
                2666.86
            ],
            "text": " мы получили ответ 200, то есть успешный ответ сервера."
        },
        {
            "timestamp": [
                2666.98,
                2669.86
            ],
            "text": " Давайте начнем с построения дерева."
        },
        {
            "timestamp": [
                2670.8,
                2675.92
            ],
            "text": " Для этого нам нужно импортировать HTML из LXML."
        },
        {
            "timestamp": [
                2682.92,
                2689.0
            ],
            "text": " И теперь попробуем получить переменную дерева."
        },
        {
            "timestamp": [
                2691.0,
                2693.26
            ],
            "text": " Назовем ее 3."
        },
        {
            "timestamp": [
                2698.26,
                2713.68
            ],
            "text": " Используем функцию fromString и в качестве аргумента"
        },
        {
            "timestamp": [
                2715.02,
                2729.28
            ],
            "text": " используем свойства контент нашего get ответа от сервера. Данная строка создает парсинг дерева l.xml из содержимого"
        },
        {
            "timestamp": [
                2729.28,
                2731.08
            ],
            "text": " объекта ответа."
        },
        {
            "timestamp": [
                2731.08,
                2734.46
            ],
            "text": " Метод fromString используется для создания нового объекта"
        },
        {
            "timestamp": [
                2734.46,
                2739.24
            ],
            "text": " Element из HTML содержимого ответа, который хранится"
        },
        {
            "timestamp": [
                2739.24,
                2742.04
            ],
            "text": " в атрибуте Content."
        },
        {
            "timestamp": [
                2742.04,
                2743.04
            ],
            "text": " Сохраним."
        },
        {
            "timestamp": [
                2743.04,
                2746.7
            ],
            "text": " И сейчас давайте вернемся к сайту."
        },
        {
            "timestamp": [
                2746.7,
                2754.38
            ],
            "text": " Для начала убедимся, что JavaScript отключен."
        },
        {
            "timestamp": [
                2754.38,
                2759.16
            ],
            "text": " Теперь кликаем правой кнопкой мышки на странице, выбираем"
        },
        {
            "timestamp": [
                2759.16,
                2764.6
            ],
            "text": " просмотреть код и переходим к инструменту разработчика."
        },
        {
            "timestamp": [
                2764.6,
                2767.8
            ],
            "text": " Давайте для начала найдем название первого фильма."
        },
        {
            "timestamp": [
                2768.22,
                2771.3
            ],
            "text": " Для этого выберем инструмент поиска,"
        },
        {
            "timestamp": [
                2773.36,
                2775.92
            ],
            "text": " наводим на название первого фильма"
        },
        {
            "timestamp": [
                2775.92,
                2790.94
            ],
            "text": " и давайте посмотрим на HTML-код. Как вы видите, тег A находится внутри тела таблицы,"
        },
        {
            "timestamp": [
                2791.22,
                2795.42
            ],
            "text": " который в свою очередь находится внутри таблицы."
        },
        {
            "timestamp": [
                2795.42,
                2800.42
            ],
            "text": " Тейбл, который содержит два класса,"
        },
        {
            "timestamp": [
                2801.24,
                2804.48
            ],
            "text": " chartFullWith и datacolorName."
        },
        {
            "timestamp": [
                2804.46,
                2806.58
            ],
            "text": " chart full width и datacolor name."
        },
        {
            "timestamp": [
                2812.04,
                2812.24
            ],
            "text": " Нам нужно получить доступ вот к этому тексту, к названию фильма,"
        },
        {
            "timestamp": [
                2815.56,
                2816.32
            ],
            "text": " поэтому давайте начнем писать XPath выражение."
        },
        {
            "timestamp": [
                2822.32,
                2823.2
            ],
            "text": " Нажимаем Ctrl F и в появившейся строке поиска вводим XPath выражение."
        },
        {
            "timestamp": [
                2824.56,
                2825.92
            ],
            "text": " Двойной слэш."
        },
        {
            "timestamp": [
                2831.62,
                2832.28
            ],
            "text": " Сначала нам нужно получить доступ к таблице, к тегу table."
        },
        {
            "timestamp": [
                2833.1,
                2835.2
            ],
            "text": " Пишем table."
        },
        {
            "timestamp": [
                2843.42,
                2858.18
            ],
            "text": " Далее, в квадратных скобках мы указываем значение атрибутов. Если щелкнуть дважды на значение атрибута, можно его скопировать и перенести в строку поиска."
        },
        {
            "timestamp": [
                2859.76,
                2873.6
            ],
            "text": " Итак, мы хотим найти значение DataColorName равным."
        },
        {
            "timestamp": [
                2874.44,
                2891.06
            ],
            "text": " Вставляем скопированное значение, а именно ChartMovimeter. И как видите, здесь в строке поиска нам указывают, какое количество элементов с такими характеристиками было найдено в HTML коде."
        },
        {
            "timestamp": [
                2891.32,
                2895.12
            ],
            "text": " В нашем случае 1. 1, потому что таблица у нас одна."
        },
        {
            "timestamp": [
                2896.04,
                2900.92
            ],
            "text": " Далее, внутри этой таблицы ищем следующий тег, а именно tbody."
        },
        {
            "timestamp": [
                2906.24,
                2908.64
            ],
            "text": " Тоже найден один элемент."
        },
        {
            "timestamp": [
                2908.96,
                2914.76
            ],
            "text": " Как видите, мы не должны указывать весь полностью путь."
        },
        {
            "timestamp": [
                2914.76,
                2925.52
            ],
            "text": " Мы указываем только те дочерние элементы, которые содержат целевой наш тег с названием фильма."
        },
        {
            "timestamp": [
                2927.28,
                2932.32
            ],
            "text": " Следующий элемент у нас TR."
        },
        {
            "timestamp": [
                2932.66,
                2934.28
            ],
            "text": " TR – это строка."
        },
        {
            "timestamp": [
                2935.1,
                2939.94
            ],
            "text": " И сейчас, как вы видите, у нас найдено 100 таких элементов."
        },
        {
            "timestamp": [
                2939.94,
                2951.22
            ],
            "text": " 100, потому что на этой странице указано 100 наиболее популярных фильмов, что соответствует нашему запросу."
        },
        {
            "timestamp": [
                2952.56,
                2960.58
            ],
            "text": " Давайте скопируем это выражение xpath и вернемся обратно в VS Code."
        },
        {
            "timestamp": [
                2960.58,
                2968.06
            ],
            "text": " В нашем коде давайте создадим новую переменную, назовем ее movies."
        },
        {
            "timestamp": [
                2973.06,
                2986.2
            ],
            "text": " И используя наше дерево элементов и метод xpath, в качестве аргумента укажем наше xpath выражение в кавычках."
        },
        {
            "timestamp": [
                2987.14,
                2987.86
            ],
            "text": " Сохраняем."
        },
        {
            "timestamp": [
                2988.26,
                2997.3
            ],
            "text": " Значит эта переменная представляет собой список, который будет содержать все элементы типа tr, из которых нам нужно получить содержимое."
        },
        {
            "timestamp": [
                2997.3,
                3009.88
            ],
            "text": " Давайте сейчас создадим цикл, в котором будем проходить по всему списку."
        },
        {
            "timestamp": [
                3014.36,
                3017.62
            ],
            "text": " Для каждого фильма в списке фильмов."
        },
        {
            "timestamp": [
                3019.74,
                3020.26
            ],
            "text": " Это у нас заготовка."
        },
        {
            "timestamp": [
                3022.74,
                3034.54
            ],
            "text": " Теперь нам нужно опять вернуться в хром. В хроме здесь у нас первый тд элемент, наводим на него мышкой и видим, что подсвечивается первый столбец в таблице."
        },
        {
            "timestamp": [
                3035.2,
                3040.68
            ],
            "text": " Второй элемент тд это второй элемент или второй столбец в таблице."
        },
        {
            "timestamp": [
                3041.9,
                3049.24
            ],
            "text": " в таблице. Внутри второго тега td есть тег a, который, кроме прочего,"
        },
        {
            "timestamp": [
                3049.24,
                3054.36
            ],
            "text": " и содержит текстовое значение, а именно название фильма."
        },
        {
            "timestamp": [
                3054.36,
                3063.34
            ],
            "text": " Давайте получим к нему доступ с помощью expa."
        },
        {
            "timestamp": [
                3063.34,
                3066.4
            ],
            "text": " Дописываем наше выражение."
        },
        {
            "timestamp": [
                3071.02,
                3080.94
            ],
            "text": " Следующий тег после tr у нас td. Нам нужен элемент td, значение атрибута класса которого равно title.column."
        },
        {
            "timestamp": [
                3092.36,
                3097.1
            ],
            "text": " Поэтому в квадратных скобках указываем класс и его значение. В нашем случае это title-column, можно его скопировать."
        },
        {
            "timestamp": [
                3099.38,
                3104.52
            ],
            "text": " Мы получили 100 таких элементов, нам же нужен один."
        },
        {
            "timestamp": [
                3104.5,
                3115.66
            ],
            "text": " Мы получили 100 таких элементов, нам же нужен один. Поэтому внутри этого элемента находим тег A и из него можем извлечь текст."
        },
        {
            "timestamp": [
                3117.48,
                3125.4
            ],
            "text": " Копируем наше XPath выражение и возвращаемся в VS Code."
        },
        {
            "timestamp": [
                3127.1,
                3130.72
            ],
            "text": " Теперь внутри цикла добавим ключ."
        },
        {
            "timestamp": [
                3132.24,
                3136.28
            ],
            "text": " Мы извлекаем название фильма, поэтому назовем его name."
        },
        {
            "timestamp": [
                3136.28,
                3153.62
            ],
            "text": " И находим внутри каждой переменной movie с помощью xpath название фильма."
        },
        {
            "timestamp": [
                3153.62,
                3167.68
            ],
            "text": " Но поскольку нам не нужен уже здесь полный путь, так как мы его сейчас прописывали в хроме, его сюда конечно можем скопировать но на самом деле"
        },
        {
            "timestamp": [
                3167.68,
                3177.88
            ],
            "text": " часть и из этого пути уже содержится в самом movie поэтому мы оставляем только ту часть"
        },
        {
            "timestamp": [
                3177.88,
                3186.12
            ],
            "text": " которая идет после tr то есть начиная с тега Т.Д."
        },
        {
            "timestamp": [
                3186.46,
                3188.62
            ],
            "text": " Все предыдущее можно удалить."
        },
        {
            "timestamp": [
                3190.88,
                3194.22
            ],
            "text": " Ставим здесь точку перед двумя слэшами."
        },
        {
            "timestamp": [
                3194.22,
                3200.22
            ],
            "text": " И нам нужно получить доступ только к первому элементу списка."
        },
        {
            "timestamp": [
                3201.2,
                3202.16
            ],
            "text": " Сохраняем."
        },
        {
            "timestamp": [
                3202.82,
                3205.12
            ],
            "text": " Возвращаемся дальше в Chrome."
        },
        {
            "timestamp": [
                3206.24,
                3213.3
            ],
            "text": " Теперь нам нужно получить год выпуска фильма."
        },
        {
            "timestamp": [
                3216.06,
                3218.76
            ],
            "text": " Воспользуемся инструментом поиска."
        },
        {
            "timestamp": [
                3219.68,
                3223.4
            ],
            "text": " Наведем на год выпуска, щелкаем по нему."
        },
        {
            "timestamp": [
                3223.4,
                3225.02
            ],
            "text": " Наведем на год выпуска, щелкаем по нему."
        },
        {
            "timestamp": [
                3231.36,
                3231.86
            ],
            "text": " И, как видите, год выпуска содержится в теге span."
        },
        {
            "timestamp": [
                3237.04,
                3243.56
            ],
            "text": " Пропишем xpath до года выпуска. Итак, у нас год выпуска находится в tbody, tr."
        },
        {
            "timestamp": [
                3251.04,
                3260.04
            ],
            "text": " находится в т-body, но начиная с td мы должны изменить xpath выражение и обратиться к тегу span, найти тег span, как видите их много"
        },
        {
            "timestamp": [
                3260.04,
                3265.58
            ],
            "text": " давайте еще раз посмотрим на него."
        },
        {
            "timestamp": [
                3272.12,
                3273.06
            ],
            "text": " Нам нужен текст-план, значение атрибута класса которого равно secondaryInfo."
        },
        {
            "timestamp": [
                3282.8,
                3283.8
            ],
            "text": " Поэтому в квадратных скобках пишем class равно secondaryInfo."
        },
        {
            "timestamp": [
                3289.24,
                3290.98
            ],
            "text": " Все, мы получили доступ к году выпуска фильма."
        },
        {
            "timestamp": [
                3296.5,
                3298.82
            ],
            "text": " Выделяем и копируем XPath выражение и возвращаемся обратно в код. В коде создадим новый ключ."
        },
        {
            "timestamp": [
                3301.82,
                3305.0
            ],
            "text": " Назовем его «releaseEA»."
        },
        {
            "timestamp": [
                3312.4,
                3322.86
            ],
            "text": " Также обращаемся к movie с помощью метода «xpath» и прописываем «xpath» выражение, которое мы скопировали."
        },
        {
            "timestamp": [
                3323.38,
                3326.14
            ],
            "text": " Давайте его отредактируем аналогичным образом."
        },
        {
            "timestamp": [
                3326.62,
                3330.56
            ],
            "text": " То есть мы начинаем поиск, начиная с тега td."
        },
        {
            "timestamp": [
                3334.22,
                3336.64
            ],
            "text": " Здесь не забываем ставить точку."
        },
        {
            "timestamp": [
                3338.86,
                3342.5
            ],
            "text": " И обращаемся только к нулевому элементу."
        },
        {
            "timestamp": [
                3343.5,
                3347.06
            ],
            "text": " Да, мы не создали словарь, поэтому давайте сейчас"
        },
        {
            "timestamp": [
                3347.06,
                3352.82
            ],
            "text": " это сделаем и все наши данные будем записывать в словарь."
        },
        {
            "timestamp": [
                3352.82,
                3359.68
            ],
            "text": " Назовем его просто m и все, что мы написали, завернем"
        },
        {
            "timestamp": [
                3359.68,
                3361.8
            ],
            "text": " в фигурные скобки."
        },
        {
            "timestamp": [
                3361.8,
                3387.86
            ],
            "text": " Те же действия нам нужно повторить и для остальных элементов на в именно позицию в рейтинге, изменение позиции в рейтинге и"
        },
        {
            "timestamp": [
                3387.86,
                3396.06
            ],
            "text": " также значение title метра. Сейчас я вернусь на страницу и покажу что это."
        },
        {
            "timestamp": [
                3396.06,
                3408.06
            ],
            "text": " Значение title метра на этой странице это вот эта стрелочка, которая указывает в какую сторону изменился рейтинг, вверх или вниз."
        },
        {
            "timestamp": [
                3408.74,
                3412.86
            ],
            "text": " Давайте воспользуемся инструментом поиска, наведем на него."
        },
        {
            "timestamp": [
                3414.24,
                3422.76
            ],
            "text": " И в коде мы видим, что здесь title.meter.up, то есть рейтинг вырос."
        },
        {
            "timestamp": [
                3422.76,
                3428.64
            ],
            "text": " Давайте посмотрим, что в других элементах. Здесь"
        },
        {
            "timestamp": [
                3428.64,
                3437.22
            ],
            "text": " title-meter-down. Попробуйте извлечь и само слово down из этого элемента. Итак,"
        },
        {
            "timestamp": [
                3437.22,
                3442.76
            ],
            "text": " ставьте видео на паузу и возвращайтесь через некоторое время."
        },
        {
            "timestamp": [
                3441.0,
                3450.24
            ],
            "text": " через некоторое время. Итак, надеюсь у вас все получилось."
        },
        {
            "timestamp": [
                3450.24,
                3454.78
            ],
            "text": " Вы можете свериться с кодом, приведенным на экране или"
        },
        {
            "timestamp": [
                3454.78,
                3456.6
            ],
            "text": " в конспекте коллекции."
        },
        {
            "timestamp": [
                3456.6,
                3469.92
            ],
            "text": " Теперь давайте создадим пустой список, назовем его All Movies, который будет содержать все наши"
        },
        {
            "timestamp": [
                3469.92,
                3479.26
            ],
            "text": " данные и в цикле будем записывать в этот список словари."
        },
        {
            "timestamp": [
                3479.26,
                3487.72
            ],
            "text": " И на этом пока все."
        },
        {
            "timestamp": [
                3487.72,
                3509.82
            ],
            "text": " Давайте выведем наш спист и запустим его."
        },
        {
            "timestamp": [
                3509.82,
                3515.82
            ],
            "text": " Запускаем."
        },
        {
            "timestamp": [
                3515.82,
                3545.78
            ],
            "text": " Итак, мы получили список словарей и общую длину элементов списка равную 100, что соответствует количеству фильмов на целевой странице. некоторые поля содержат специальные символы, некоторые"
        },
        {
            "timestamp": [
                3545.78,
                3550.02
            ],
            "text": " поля могут содержать какую-то лишнюю информацию."
        },
        {
            "timestamp": [
                3550.36,
                3554.58
            ],
            "text": " Поэтому дальнейшая ваша задача, следующий шаг – это"
        },
        {
            "timestamp": [
                3554.58,
                3559.24
            ],
            "text": " выполнить парсинг элементов с помощью тех методов,"
        },
        {
            "timestamp": [
                3559.24,
                3563.58
            ],
            "text": " которые мы уже изучали на том уроке, когда проходили"
        },
        {
            "timestamp": [
                3563.58,
                3568.04
            ],
            "text": " Beautiful Soup и на семинарах."
        },
        {
            "timestamp": [
                3568.2,
                3572.02
            ],
            "text": " Поэтому сейчас я не буду останавливаться подробно на том,"
        },
        {
            "timestamp": [
                3572.2,
                3577.3
            ],
            "text": " как извлекать информацию из каждого элемента списка"
        },
        {
            "timestamp": [
                3577.3,
                3581.1
            ],
            "text": " и приведу сразу готовый код."
        },
        {
            "timestamp": [
                3581.1,
                3587.24
            ],
            "text": " Итак, я вам, конечно, рекомендую самостоятельно выполнить парсинг каждого элемента"
        },
        {
            "timestamp": [
                3587.24,
                3594.58
            ],
            "text": " для извлечения точно той информации, которая вам нужна. Здесь же, в частности, например,"
        },
        {
            "timestamp": [
                3594.72,
                3605.22
            ],
            "text": " год выпуска преобразован в тип int, в целое число. Здесь позиция также преобразована в целое число."
        },
        {
            "timestamp": [
                3606.3,
                3612.86
            ],
            "text": " Также мы извлекаем только ту информацию, которая нам нужна."
        },
        {
            "timestamp": [
                3613.18,
                3618.48
            ],
            "text": " Наконец, следующий этап – это добавление данных в MongoDB."
        },
        {
            "timestamp": [
                3618.48,
                3627.86
            ],
            "text": " Давайте напишем функцию для добавления полученных данных в локальное хранилище mango db для этого"
        },
        {
            "timestamp": [
                3627.86,
                3634.18
            ],
            "text": " импортируем манга client из пойманга"
        },
        {
            "timestamp": [
                3653.56,
                3712.54
            ],
            "text": " И напишем функцию, назовем ее insertToDB, в которую будем передавать список фильмов. Подключаемся к локальному клиенту. Далее создаем в нашей базе данных новую базу, назовем ее TopMovies."
        },
        {
            "timestamp": [
                3712.54,
                3726.26
            ],
            "text": " И, наконец, воспользуемся методом insertMany"
        },
        {
            "timestamp": [
                3726.26,
                3733.32
            ],
            "text": " для добавления нашего списка."
        },
        {
            "timestamp": [
                3736.68,
                3739.42
            ],
            "text": " И, наконец, закроем клиент."
        },
        {
            "timestamp": [
                3763.28,
                3767.28
            ],
            "text": " После цикла вызовем нашу функцию и передадим ей список, который мы получили в результате скрейпинга."
        },
        {
            "timestamp": [
                3771.12,
                3771.8
            ],
            "text": " Вывод в терминал удалим, он нам больше не нужен."
        },
        {
            "timestamp": [
                3773.04,
                3775.88
            ],
            "text": " Сохраняем скрипт."
        },
        {
            "timestamp": [
                3777.46,
                3778.16
            ],
            "text": " Очистим терминал."
        },
        {
            "timestamp": [
                3783.12,
                3783.98
            ],
            "text": " И прежде всего давайте перейдем в Mango Compass,"
        },
        {
            "timestamp": [
                3788.2,
                3793.36
            ],
            "text": " чтобы посмотреть, что там в настоящее время базы данных нет. Вам нужно локально запустить Mango DB."
        },
        {
            "timestamp": [
                3794.28,
                3801.0
            ],
            "text": " Вы можете убедиться, что сейчас базы данных с названием imdbmovies у нас нет."
        },
        {
            "timestamp": [
                3801.94,
                3805.0
            ],
            "text": " И, в общем-то, наша задача сейчас сюда перенести данные."
        },
        {
            "timestamp": [
                3805.34,
                3806.26
            ],
            "text": " Вернемся в код."
        },
        {
            "timestamp": [
                3806.54,
                3811.22
            ],
            "text": " Наконец, прежде чем мы запустим наш скрипт, я хотел бы обратить"
        },
        {
            "timestamp": [
                3811.22,
                3814.42
            ],
            "text": " ваше внимание еще на две функции, которые я сюда"
        },
        {
            "timestamp": [
                3814.42,
                3814.92
            ],
            "text": " добавил."
        },
        {
            "timestamp": [
                3816.22,
                3823.24
            ],
            "text": " Первая из этих функций извлекает изменение title метра, то есть"
        },
        {
            "timestamp": [
                3823.24,
                3825.6
            ],
            "text": " повысился рейтинг фильма или повысился рейтинг фильма"
        },
        {
            "timestamp": [
                3825.6,
                3829.6
            ],
            "text": " или понизился рейтинг фильма, или остался без изменений."
        },
        {
            "timestamp": [
                3830.26,
                3834.72
            ],
            "text": " И вторая функция получает изменение позиции,"
        },
        {
            "timestamp": [
                3834.96,
                3837.66
            ],
            "text": " то есть на сколько пунктов изменился рейтинг."
        },
        {
            "timestamp": [
                3839.84,
                3842.98
            ],
            "text": " Итак, пробуем запускать скрипт."
        },
        {
            "timestamp": [
                3846.32,
                3848.22
            ],
            "text": " Ждем ответ сервера."
        },
        {
            "timestamp": [
                3849.52,
                3850.9
            ],
            "text": " Скрипт выполнился."
        },
        {
            "timestamp": [
                3851.28,
                3853.44
            ],
            "text": " И давайте перейдем в MongoDB."
        },
        {
            "timestamp": [
                3855.12,
                3862.2
            ],
            "text": " Мы можем обновить список баз данных, если вновь созданная база данных все еще не отображается у вас в списке."
        },
        {
            "timestamp": [
                3862.2,
                3865.58
            ],
            "text": " Видим, что у нас появилась АМДБ Movies,"
        },
        {
            "timestamp": [
                3865.58,
                3867.44
            ],
            "text": " наша новая база данных."
        },
        {
            "timestamp": [
                3867.44,
                3870.06
            ],
            "text": " Можем развернуть ее, внутри увидеть"
        },
        {
            "timestamp": [
                3870.06,
                3872.08
            ],
            "text": " коллекцию Top Movies."
        },
        {
            "timestamp": [
                3872.08,
                3874.38
            ],
            "text": " Давайте войдем в нее."
        },
        {
            "timestamp": [
                3874.38,
                3875.88
            ],
            "text": " Здесь мы видим,"
        },
        {
            "timestamp": [
                3875.88,
                3878.56
            ],
            "text": " что у нас имеется 100 элементов,"
        },
        {
            "timestamp": [
                3878.56,
                3881.18
            ],
            "text": " что соответствует количеству"
        },
        {
            "timestamp": [
                3881.18,
                3884.0
            ],
            "text": " фильмов на целевой странице."
        },
        {
            "timestamp": [
                3884.0,
                3890.92
            ],
            "text": " И, конечно, все элементы, которые мы заполучили с рейтинга IMDB,"
        },
        {
            "timestamp": [
                3891.34,
                3892.92
            ],
            "text": " представлены в базе данных."
        },
        {
            "timestamp": [
                3893.18,
                3899.14
            ],
            "text": " В заключение я хочу сказать, что парсинг и скрейпинг HTML с помощью LXML и XPath"
        },
        {
            "timestamp": [
                3899.14,
                3902.48
            ],
            "text": " это мощная техника извлечения данных с веб-сайтов."
        },
        {
            "timestamp": [
                3902.78,
                3906.48
            ],
            "text": " Библиотека LXML предоставляет быстрый и эффективный способ"
        },
        {
            "timestamp": [
                3906.48,
                3910.8
            ],
            "text": " парсинга HTML, а XPath позволяет гибко и точно выбирать"
        },
        {
            "timestamp": [
                3910.8,
                3913.32
            ],
            "text": " элементы и атрибуты в подобных документах."
        },
        {
            "timestamp": [
                3913.52,
                3917.44
            ],
            "text": " Комбинируя эти инструменты с Python и другими библиотеками"
        },
        {
            "timestamp": [
                3917.44,
                3920.82
            ],
            "text": " анализа данных, можно собирать и обрабатывать большие"
        },
        {
            "timestamp": [
                3920.82,
                3924.86
            ],
            "text": " объемы данных из интернета для использования в исследованиях,"
        },
        {
            "timestamp": [
                3925.5,
                null
            ],
            "text": " анализе или других приложениях. На этом урок окончен и до встречи на следующей лекции. you"
        }
    ]
}