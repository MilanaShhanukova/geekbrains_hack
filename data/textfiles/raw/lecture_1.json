{
    "text": " Друзья, привет! С вами снова я, Денис. Рад вас приветствовать на лекции. Сегодня мы будем говорить о массивах. На прошлой лекции мы познакомились с языком программирования C-Sharp, с его основными характеристиками, а также решили блок базовых задач. На семинарах вы попрактиковались в разработке циклических условных конструкций, применяли арифметические операторы, а также операции ввода-вывода. Сегодня мы вспомним основные понятия, связанные с массивами, их характеристики, поговорим о том, в каких задачах массивы могут применяться. Познакомимся, как осуществляется операция создания, заполнения, а также вывода массивов на экран и решим блок задач на их обработку. Ближе к концу лекции мы познакомимся с двумя разновидностями циклов for и for each, а также, друзья, поговорим о таком важном аспекте, как изучение английского для программистов. Друзья, перед тем как приступить к практике и начать решать задачи, давайте вспомним, а что из себя представляет массив и какими характеристиками он обладает. Начнем с ключевого термина этой лекции – массив. Массив представляет собой структуру данных, которая предназначена для хранения элементов, как правило, одного типа. Массив может состоять из целых чисел, вещественных, может состоять из символов, а также, например, из строк. Если приводить примеры из реальной жизни, то массива мы можем назвать упорядоченный набор инструментов или же набор елочных игрушек, который также обладает характеристикой упорядоченности. Второй важный термин – это индекс элемента массива. Друзья, этот термин можно сформулировать по-разному. Приведем наиболее популярные формулировки. Итак, первое, да, это смещение элемента относительно начала массива. То есть, на сколько позиций элемент смещен, да, относительно его левой границы. Ну и вторая формулировка, наиболее простая, это просто позиция элемента в массиве. Друзья, напомню, что в большинстве языков программирования индекс массива начинается с нуля. Перейдем к основным характеристикам массивов. Первая характеристика это то, что массив должен иметь имя. Еще его называют идентификатор. С помощью имени мы осуществляем обращение к элементам массива. Если нам нужно изменить элемент или же просто его прочитать, то мы используем операцию обращения к элементам по индексу. Также, друзья, эту операцию называют индексация. В большинстве языков программирования она обозначается с помощью пары квадратных скобок. В примере приведен массив из пяти элементов и ниже вы можете видеть обращение к каждому его элементу с помощью оператора квадратные скобки. Отметим важную характеристику, которая определяет внутреннее устройство массивов. Друзья, элементы в массиве располагаются последовательно, то есть в памяти, да, они занимают ячейку за ячейкой. Ни в коем случае элементы в массиве не расположены хаотично или же в каком-либо другом порядке. Ну и в заключение добавим, что массивы имеют конечный размер, поскольку объем памяти у нас всегда ограничен. Итак, после небольшого экскурса в теорию давайте посмотрим, как будут выглядеть основные операции при работе с массивами на языке C-Sharp. Рассмотрим создание, заполнение и вывод массива на экран. В языке C-Sharp создание массива состоит из трех основных этапов. Первый этап – это указание типа данных для элемента массива. Также, друзья, мы указываем оператор квадратные скобки, чтобы показать, что у нас именно создается массив, а не обычная переменная. Второй этап – это указание идентификатора или же имени массива. В данном примере, друзья, мы пользуемся именем R, что является сокращением от Array. Друзья, рекомендую давать массивам осмысленные имена. В самом простом случае можно дать имя Array. Однако рекомендую задуматься над более осмысленным именованием. Как в приведенных примерах, если вы оперируете набором файлов, то такой массив можно назвать именем files. Если же вы оперируете набором среднесуточных температур, то подобный массив можно назвать averageDialedTemperatures или сократить до averageDialedTemps. Но здесь важно не злоупотреблять с сокращением в именовании переменных, Особенно, если эти имена становятся не общепринятыми и не общеизвестными. Имена array, ar вполне, друзья, допустимы для учебных задач, где мы делаем упор на демонстрацию той или иной техники по обработке массивов. То есть акцент делается не на конкретной предметной области. Следующий этап – это выделение памяти от элемента массива. На данном этапе мы указываем количество элементов, а также используем оператор new, который нам выделит фрагмент памяти для хранения будущих элементов. На этом три основные операции по созданию массива закончены, но также, друзья, можно выделить и четвертый этап. Он заключается в связывании участков памяти, которые мы выделили с помощью оператора new, с именем массива с помощью оператора присваивания. Работать сегодня мы будем в каталоге урок 2. Друзья, иерархия каталогов на сегодня у меня уже создана. Перейдем в каталог с заданием 1 и создадим там проект, знакомый вам командой.NET New Console. Перейдем в файл с исходным кодом program.cs Удалим код, который сгенерировался по умолчанию Итак, укажем тип данных, массив, целых чисел Далее дадим массиву имя, например, r Напомним сокращение от слова array И выделим память с помощью оператора new, допустим, на 5 целых чисел. вещественных чисел, то в этом случае мы слева от присваивания и справа от присваивания использовали бы тип данных double или же float. Друзья, после выполнения данной операции у нас будет создан массив на 5 целых чисел. Обращаться к нему мы можем, используя его имя. Отмечу, что в языке C-sharp элементы при создании массива имеют значение по умолчанию. Если это числовой массив, то элементами являются нули. Далее заполним массив произвольными целыми числами. Напомню, друзья, что для изменения элементов массива мы используем оператор индексации и в квадратных скобках указываем индекс элемента. Заполним его произвольными целыми числами. Для ускорения можно скопировать эти конструкции. И не забываем менять индексы массива. В данном случае они у нас изменяются от нулевого и до размера массива минус 1. Сделаем элементы массива относительно случайными. Проверим, действительно ли массив заполнен. Для этого выведем каждый его элемент на экран знакомым методом writeLine из модуля консоли. Для вывода элементов, для обращения мы также используем имя массива и операцию индексации с указанием индекса необходимого нам элемента. Для ускорения конструкцию вывода можно скопировать необходимое количество раз, заменив индексы на соответствующих позициях. Друзья, выполним наш код с помощью команды.NET RUN. На экране мы видим значения, которые были помещены в массив. Друзья, а как вы думаете, что произойдет, если мы обратимся к элементу с индексом 5, при том, что количество элементов в массиве равно 5? Давайте это проверим и попробуем вывести на экран элемент с индексом равным 5. Итак, воспользуемся все тем же методом консоли Brightline и выведем на экран массив с индексом равным 5. Сохраним исходный код и запустим наш проект еще раз. Друзья, обратите внимание, что на экране у нас вывелась ошибка, связанная с выходом за границы массива. То есть, таким образом, среда выполнения предупреждает нас о том, что недопустимо обращаться за границы памяти, которые мы выделили для массива. Закомментируем строчку с недопустимым обращением к массиву и давайте продолжим. Итак, друзья, мы создали массив на 5 элементов, заполнили его числами, вывели их на экран. Давайте рассмотрим способ заполнения массива сразу же при его создании. Для этого воспользуемся той же конструкцией, которую мы использовали, только с небольшим изменением. Все так же будем создавать массив целочисленный. Дадим ему имя r2, поскольку имя r уже занято. И после указания имени выделим память на все те же 5 элементов. Обязательно с указанием типа данных, и заполним их произвольными целыми числами сразу же при создании этого массива. Друзья, напомню, что редактор Visual Studio Code имеет инструменты форматирования кода. Для этого можно выделить необходимый участок, форматирования кода. Для этого можно выделить необходимый участок, нажать правой кнопкой мыши и выбрать пункт меню формат документ или сочетание горячих клавиш shift alt f. Отмечу, что в C-Sharp можно использовать упрощенный синтаксис для создания массива. Он заключается в том, что команду на выделение памяти, то есть new int и указание количества элементов, в некотор случае команду на выделение памяти мы можем не использовать, поскольку число элементов у нас фиксировано и мы их указываем сразу при создании массива. Способ достаточно удобный для создания небольших массивов, когда заранее известны их элементы. И, друзья, отмечу, что, вероятно, знакомый многим из вас язык программирования Python имеет схожий синтаксис создания массива. Выглядит он примерно следующим образом. И также отмечу, что тип данных у массива мы не указываем. Не забываем, друзья, форматировать наш код, чтобы повысить его читаемость. Сохраним наши наработки в репозитории git. Проиндексируем целиком каталог task1. Далее сформируем commit с указанием комментария о том, что мы добавили первую задачу в уроке 2. И отправим наши наработки на удаленный репозиторий. Друзья, перед тем как приступить к решению задач, давайте поговорим о том, а какие именно классы задач могут быть решены с помощью массивов, а также каким специальностям, навыкам работы с массивами и в целом знаниям основ программирования будет полезно. Один из самых простых вариантов использования – это хранение однотипных элементов и последующее обращение к ним. Например, в массиве мы можем сохранить набор целых чисел, чисел с плавающей точкой, символов или же набор строк, которые составляют некоторый текст. Также в массиве можем сохранить и более сложные объекты, например, файлы. Массивы часто используются для поиска элементов по какому-либо критерию. Например, знакомый вам поиск минимального и максимального значения среди набора целых чисел. Если же рассмотреть набор строк в виде имен файлов как массив, то в таком массиве мы можем осуществить поиск графических файлов, файлов с видеосодержимым или же, например, файлов с исходным кодом. В данном случае критерием будет расширение файла. В данном случае критерием будет расширение файла. Также отметим класс задач, в которых необходимо вычислить некоторую характеристику от всего набора элементов. Это может быть сумма значений, это может быть произведение или среднее значение. Друзья, в качестве примера можно рассмотреть вычисление суммарных затрат на предприятии. рассмотреть вычисления суммарных затрат на предприятии. В таком массиве элементами могут быть затраты предприятия за день, за неделю или же, например, за месяц. Друзья, вопрос на засыпку. А как вы думаете, какой тип данных может быть у элементов в подобном массиве? Свои предположения можете написать в чат. Второй пример – это нахождение средней температуры за год. В таком массиве элементами могут быть значения температур за месяц, из которых потом будет вычисляться среднегодовое значение. Друзья, перед тем как порешать конкретные задачки на обработку массивов, давайте обсудим еще такой вопрос, как применимость знаний о массивах, ну и в целом навыков программирования на конкретных специальностях. Наиболее очевидный случай это разработчик. Массивы являются достаточно простой и базовой структурой данных, с которой программисты знакомятся в первую очередь. После изучения массивов, а также получения навыков по их обработке, можно переходить к изучению таких структур данных, как стэк, очередь или же связный список. Следующая специальность, где навыки работы с массивами не будут лишними, это тестировщик программного обеспечения. На старте профессии умение программировать, вероятно, вам не понадобится, особенно если речь идет о ручном тестировании. Однако, если вам понадобится освоить автоматизированное тестирование, то здесь уже, друзья, без навыков программирования не обойтись. В частности, понимание массивов, а также навыки работы с ними существенно ускорят изучение языка программирования высокого уровня. К специальностям аналитик, продакт, а также project manager высоких требований в плане владения конкретным языком программирования не предъявляется. Однако умение программировать и в том числе навыки работы с массивами будут достаточно полезны аналитику, особенно если в круг его задач входит работа с большими объемами данных. Product и Project Manager понимание основ программирования будет достаточно полезно для взаимодействия с командой разработки. В частности, чтобы вести диалог с программистами на одном языке. Итак, друзья, давайте перейдем к первой задаче. В ней требуется заполнить массив целыми числами от 1 до n, где n некоторое целое число, и вывести этот массив на экран. Давайте перечислим основные этапы в решении этой задачи, затем сформируем с вами блок-схему и запрограммируем на языке C-sharp. Первым шагом нам необходимо понять, а какой размер будет иметь создаваемый массив. Для этого, друзья, введем натуральное число n, после чего вторым шагом можем создать массив на n элементов, выделив под него память. Третьим этапом можно заполнить массив конкретными числами, после чего вывести его на экран. Для создания блок-схемы давайте вспомним задачу с предыдущего урока на вывод чисел от 1 до n. Друзья, обратите внимание, что эта задача очень похожа на текущую, поскольку в ней формируются числа от 1 до n и затем выводятся на экран. Давайте посмотрим, как можно модифицировать эту схему для решения нашей задачи. Первый этап у нас уже выполнен. Ввод числа n в схеме уже присутствует. Добавим создание массива в блоке инициализации переменных до запуска цикла. Друзья, обратите внимание, что создание массива у меня выделено желтым цветом. И напомню вам, что под созданием массива мы понимаем выделение участка памяти для размещения элементов. Далее добавим основное действие, которое позволит заполнить массив. Для этого поместим значение счетчика на очередную позицию массива. Друзья, обратите внимание, что переменная счетчик изначально равна нулю, поэтому мы помещаем в массив число на единицу больше, то есть, как видно из схемы i плюс 1. Таким образом, друзья, в массив мы будем помещать числа 1, 2, 3 и так далее до числа n. Вывод элемента массива можно разместить в этом же цикле, но, друзья, сделать это нужно после помещения очередного значения в массив, иначе мы будем выводить элементы массива до их формирования. Также отмечу, что вывод элементов можно сделать и в отдельном цикле. То есть сначала у нас будет идти цикл по формированию элементов массива и ниже точно такой же цикл для их вывода. Итак, наша блок-схема готова. Давайте посмотрим, как этот алгоритм будет выглядеть на языке C-Sharp. Перейдем в каталог с заданием 2 и создадим там проект командой.NET New Console. Перейдем в файл со сходным кодом, удалим код сгенерированный по умолчанию и, согласно нашей блок-схеме, создадим целочисленную переменную n, равную 10. Друзья, поскольку число элементов в массиве заранее неизвестно, то мы будем пользоваться стандартным синтаксисом создания массива с указанием оператора new, типа данных и количества элементов, для которых мы будем создавать массив. Создадим переменную счетчик i, изначально равную нулю. Для заполнения и вывода мы используем цикл, поскольку будем повторять одни и те же действия, пока не дойдем до конца массива. Создадим цикл while с условием i строго меньше, чем количество элементов в массиве. В теле цикла сформируем очередной элемент массива i плюс 1 и поместим его на требуемую позицию в массиве r. Давайте выведем сразу его на экран с помощью инструкции консоли в райт. Друзья, чтобы элементы у нас не слипались при выводе, добавим пробел после каждого элемента. То есть продублируем инструкцию консоли в райт, только вместо элемента мы укажем символ пробела. И не забываем перейти к следующему значению счетчика путем увеличения его на единицу. Друзья, обратите внимание на вывод элементов на экран. его на единицу. Друзья, обратите внимание на вывод элементов на экран. Давайте оформим это более изящно и в одну строку. Воспользуемся средством C-Sharp, которое позволяет выводить на экран строку и помещать в нее переменную. Для этого воспользуемся все тем же методом консоли в write. Только перед строкой мы поставим значок доллара и в самой строке значение очередного элемента массива array с индексом i поместим, обратите внимание, в фигурные скобки и добавим знак пробел. Друзья, в этом случае то, что было помещено в фигурные скобки, будет рассматриваться как значение элемента массива или же, например, переменная, и будет выведено на экран именно то, что находится в памяти, то есть сам элемент массива. Итак, давайте запустим наш код командой.NET RUN. На экране мы видим приветственное сообщение hello world, однако, друзья, такого кода в файле, да, в нашем program.cs нет. Такая ситуация часто возникает, если мы забываем сохранить изменения в исходном файле. Давайте сохраним изменения путем нажатия комбинации клавиш Ctrl-S и запустим наш код еще раз. На экране мы видим последовательность чисел от 1 до 10. Следовательно, для этого набора элементов алгоритм работает верно. Друзья, обращу ваше внимание, что вместо использования переменной n, которая хранит количество элементов массива, мы можем воспользоваться свойством массива. свойства массива. Для этого обратимся по его имени, поставим точку и будет предложен набор методов и свойств, которыми располагает объект массив. Друзья, нам здесь из этого многообразия понадобится только свойство Length, которое как раз таки хранит количество элементов, под которые выделена память. То есть, Length в данном случае будет равен 10. Можно пользоваться как этим свойством, так же можно пользоваться и переменной. Друзья, давайте сделаем небольшую паузу, отдохнем от решения задач и рассмотрим два подхода к изучению программирования. Основная идея первого подхода заключается в постепенном повышении сложности решаемых задач. Друзья, наше знакомство с языком C-Sharp мы начали с таких тематик, как переменные, типы данных, арифметика и затем перешли к условным и циклическим конструкциям. Друзья, рекомендую начинаать знакомство с программированием, с решением базовых и простых задач. Например, нарешивать их некоторое количество, 5, 10, 15 штук, и переходить к более сложным. Более сложной задачей очень часто является комбинация из набора простых задач. Друзья, не рекомендую сразу браться за сложные и комбинированные задачи, особенно если у вас возникают сложности на базовых задачах. А рассмотренный подход, друзья, носит название «От простого к сложному». Второй подход заключается в том, что количество решенных вами простых и базовых задач будет постепенно переходить в качество. То есть вы будете формировать свое алгоритмическое мышление, которое позволит вам решать более сложные задачи и строить более сложные алгоритмы. Таким образом, вы сможете опираться на некоторый фундамент из множества решенных вами базовых и простых задач. Двигаемся далее и давайте рассмотрим типовую задачу на поиск элементов в массиве, которые удовлетворяют некоторым условиям. Пусть у нас имеется массив на некоторое количество целых чисел, допустим на 10 штук. Требуется найти в нем четные числа и вывести их на экран. Друзья, напомню, что число является четным, если оно делится на цело на 2. Примеры четных чисел это 0, 2, 4, 6 и так далее. Давайте для этой задачи перечислим основные этапы, сформируем ее блок-схему и реализуем эту схему на языке C-sharp. Итак, в этой задаче можно выделить следующие этапы. Первое. Создать и заполнить массив на 10 целых чисел. Вторым этапом можно выделить проход по элементам, то есть просмотр каждого элемента. Третий этап – это проверка элемента на условия того, является ли он четным. Ну и четвертый этап, друзья, это вывести этот элемент на экран, если указанное условие выполняется. Перейдем в блок схеме. Обращу ваше внимание, друзья, что цикл прохода по элементам массива мы можем целиком взять из предыдущей задачи. Этот цикл будет одинаковым для всех задач, где требуется перебрать или же просмотреть элементы. Массив мы заполним с клавиатуры сразу же при его создании. Я обращу ваше внимание, что цикл в этом случае можно не использовать, поскольку число элементов заранее известно, напомню их 10 штук, и оно невелико. Далее, в цикл прохода по элементам массива нам необходимо добавить проверку очередного элемента на четность. Если же этого мы не будем делать, то на экран будет выведены все элементы, включая нечетные. Обратите внимание, условие разместил в блоке решения и написал там array с индексом i из even, что переводится как четный ли элемент с индексом i. Друзья, такая формулировка условия вполне подходит в использовании блок-схемы. Однако при переносе блок-схемы на конкретный язык программирования могут возникнуть существенные сложности. могут возникнуть существенные сложности. Дело в том, что языкам программирования непонятна такая формулировка условия, которая вполне понятна человеку и допускается в использовании блок-схем. Попытка перенести такое условие в язык программирования приведет к синтаксической ошибке. Друзья, к счастью, у этой проблемы есть решение. И заключается оно в использовании операторов сравнения и арифметических операторов при построении условий. Эти операторы языки программирования вполне хорошо воспринимают. В данной задаче нам поможет оператор вычисления остатка отделения. Во многих современных языках программирования он обозначается либо с помощью значка % либо с помощью ключевого слова mod, что от английского в переводе с модула означает деление по модулю. И для проверки на равенство мы будем использовать двойной знак равно. И, друзья, напомню, что одинарный значок равно обозначает другую операцию. Итак, скорректируем наши условия и применим арифметический оператор остаток отделения и проверки на равенство. Если остаток отделения на 2 равен 0, это мы пишем в блоке решения, он у меня подсвечен оранжевым цветом, то это значит, что очередной элемент массива делится на 2 нацело. То есть, он четный и мы его будем выводить на экран ниже, друзья, с помощью блока ввод-вывод, который обозначается в виде параллелограммы. В нем мы напишем то, что вывести очередной элемент массива array с индексом i. Итак, блок-схема нашего логаритма готова. Давайте посмотрим, как он будет выглядеть на языке C Sharp. Перейдем в каталог с заданием 3 и создадим там проект. Перейдем в файл с исходным кодом, удалим сгенерированный по умолчанию. Согласно нашей блок-схеме создадим целочисленную переменную n, равную 10, и массив на 10 целых чисел. Друзья, предлагаю использовать упрощенный синтаксис создания массива, поскольку число элементов заранее известно и оно невелико. Создадим массив из 10 произвольных целых чисел, четных, а также добавим нечетные. Не забываем про форматирование кода. Не забываем про форматирование кода. Создадим переменную счетчик i, изначально равную 0, и оформим цикл while с условием счетчик строго меньше, чем количество элементов n. На каждой итерации будем проверять четность очередного элемента с помощью условной конструкции if. Обратимся к конкретному элементу по индексу i. Разделим его с остатком на 2 и проверим, равен ли этот остаток 0. Если это так, друзья, то значит, что элемент четный и нам нужно вывести его на экран. Давайте это сделаем с помощью метода write. Друзья, предлагаю использовать метод вывода переменной сразу же в строке. То есть, напомню, используем символ доллара и затем затем в строке, в фигурных скобочках, пишем элемент, который хотим вывести на экран. В данном случае это просто очередной элемент массива. И добавим пробел, чтобы элементы не слепались. Давайте запустим наш код. Друзья, на экране мы видим, что алгоритм у нас зациклился и значение первого элемента, двойка, выводится в бесконечном цикле. Как вы думаете, почему так вышло? Я установлю вывод комбинацией клавиши Ctrl-C. Друзья, все дело в том, что мы с вами забыли увеличить значение переменной i, то есть перейти к следующему элементу массива. Без этого мы будем обрабатывать каждый раз первый элемент массива и проверять его. То, что мы видим. То есть проверили, вывели, проверили, вывели. И если не переходить к следующему элементу, то мы зациклим наш цикл. Итак, сохраним изменения и запустим еще раз. еще раз. На экране мы видим четные числа, которые являются элементами этого массива. Друзья, рекомендую проверить правильность работы этого алгоритма на различных входных данных. Например, массив можно задать целиком из четных чисел, из нечетных, ну или как в нашем случае из комбинации, как четных, так и нечетных. Таким образом мы проверим работоспособность алгоритма на различных входных условиях. Итак, мы с вами решили две типовые задачи на работу с массивами. Вспомнили, как в C-Sharp обозначаются циклические конструкции, условные, а также поработали с арифметикой и вводом-выводом. Друзья, давайте вспомним задачу из лекции введения в программирование, которая была связана с вычислением веса наиболее тяжелой гири. Напомню вам, как выглядит блок-схема для поиска наиболее тяжелой гири из 5 штук. Друзья, мы поочередно, как можете видеть, делаем 4 сравнения в блоках решения, да, и при необходимости, если эти сравнения дают нам ответ да, то по ветке yes мы обновляем значение переменной max в соответствующих блоках процесс. После проведения всех сравнений в переменной max у нас будет находиться значение наиболее тяжелой гири. На предыдущей лекции мы с вами запрограммировали алгоритм для поиска наибольшего из 5 целых чисел. Мы с вами создали 5 целочисленных переменных и разместили в них некоторые произвольные числа. Далее мы с вами сделали 4 сравнения с помощью оператора if, и за счет этого мы нашли вес наиболее тяжелой гири, после чего в конце алгоритма мы вывели значение переменная max на экран. Друзья, но как изменится этот алгоритм, если число гирь, да, или же чисел будет увеличено? Предположим, что нам необходимо найти самую тяжелую гирю из количества 10 штук. Если оставить логику решения без изменений, то код может выглядеть примерно следующим образом. Обратите внимание, друзья, на количество переменных. Их здесь 10 штук. И количество сравнений. Да, в целом задача решена, но код стал достаточно громоздким и содержит большое количество повторяющихся инструкций. Давайте еще немного изменим условия нашей задачи и увеличим количество гирь, скажем, до 100 штук. Как можно видеть из фрагмента исходного кода, букв латинского алфавита для именования переменных мне не хватило, я начал использовать переменные из двух букв. Также можно давать имена следующие, да, гиря 1, гиря 2 и так далее. Но нужно использовать соответствующие английские слова, да, то есть wait1, wait2 и так далее. Друзья, если использовать эту же, да, логику решения задачи, то для создания переменных у нас уйдет порядка 100 строк исходного кода и нам нужно будет запрограммировать порядка 100 практически одинаковых инструкций сравнения с использованием оператора if. Друзья, согласитесь, что для решения подобной задачи нам потребуется несколько иной подход. И одним из таких подходов мы можем рассмотреть использование массива для хранения весов, представленных гирь. Сформулируем задачу в более общем виде. Дано n гирь, где n – некоторое натуральное число, и требуется найти наиболее тяжелую гирю. Вспомним алгоритм поиска, который был приведен в курсе ведения в программировании, основанный на хранении весов гирь в массиве и использовании цикла. Друзья, обратите внимание, что в этом алгоритме также используется переменная max и проводится n сравнений для определения гири наибольшего веса. Отличие этого алгоритма заключается в том, что в нем переменные хранятся не россыпью, как в приведенных ранее алгоритмах, а в упорядоченном контейнере по массиве. А также, друзья, операция сравнения весов гирь не повторяется в коде много раз, а участвует один раз и расположена в цикле. Отмечу, что этот алгоритм может быть применен для произвольного количества гирь, как для пяти, для сотни, так и для тысячи штук. Итак, перейдем в каталог для четвертого задания. Также создадим там новый проект. Давайте возьмем количество гирь, равное, допустим, 5 штук. Создадим целочисленный массив из 5 весов гирь. Друзья, поскольку у нас количество весов небольшое, заранее известное, мы можем воспользоваться упрощенным синтаксисом создания массива. Создадим массив из набора произвольных различных чисел. Не забываем форматировать код. Далее создадим цикл while, который у нас пройдет по элементам массива, и перед этим мы создадим переменную счетчик, которую будем использовать для условия цикла i меньше чем количество элементов. Также мы эту переменную будем использовать при обращении к самим элементам. Друзья, для проверки, да, не превышает ли очередной элемент массива значение переменной max, мы напишем условие array с индексом i больше, чем переменная max. Ну и, конечно же, не забываем, да, предварительно эту переменную создать. И проинициализируем ее первым элементом массива, то есть элементом с индексом 0. Если это так, да, если очередной элемент у нас превысил текущее значение максимума, то мы обновим переменную max, поместив в нее текущий элемент массива. Обращаю внимание, друзья, что в случае невыполнения до этого действия этого условия, если оно неверно, то никакого отдельного действия для ветки ELSA не предусмотрено. Мы ее пропускаем. Не забываем перейти к следующему элементу массива, увеличив значение счетчика на единицу. И после завершения цикла выведем значение переменной max на экран, чтобы проверить правильность работы алгоритма. Сохраним изменения в исходном коде. Запустим наш код командой dotnet run. Ожидаем увидеть ответ 9, что соответствует наибольшему значению в этом массиве. Наши ожидания совпадают с выводом. Это говорит о том, что алгоритм работает правильно, друзья, для указанного набора данных. Друзья, также как и в предыдущей задаче, не забываем проверить правильность работы нашего алгоритма на различных входных данных. Применительно к этой задаче я бы рекомендовал проверить ее работоспособность на массиве, когда у нас наибольшее число находится в конце массива, в начале или же где-то посередине. Также лишним не будет проверить работу алгоритма, когда массив отсортирован по возрастанию или же наоборот по убыванию. Таким образом вы проверите правильность его работы на различных начальных условиях. До настоящего момента мы с вами работали только с одной разновидностью циклов. Это while. Давайте посмотрим, а какие еще способы создания циклических конструкций присутствуют в языке C-sharp. Друзья, на экране представлены блок-схемы с использованием блока счетный цикл. Наверняка некоторые из вас при решении задач в курсе знакомства с программированием использовали этот блок. Большинство современных язы с программированием использовали этот блок. Большинство современных языков программирования поддерживают синтаксис описания счетных циклов. Давайте посмотрим, как это выглядит в C-Sharp. Итак, для создания счетного цикла используется ключевое слово for. Но в отличие от цикла while, где в круглоскопах мы указываем только условия в цикле for, обратите внимание, также указывается создание переменной счетчика, в этом случае i равное 0, и изменение этой переменной, то есть ее модификация i равно i плюс 1. Друзья, давайте рассмотрим составные части цикла for более подробно. Первый блок – это блок инициализации, то есть создание переменной счетчика и присвоение ей некоторого начального значения. В качестве имен переменных обычно используется IJK. Это стандартный подход при создании переменных счетчиков, будь то в цикле for, будь то в цикле while. Второй блок – это условия. Напомню, под условием мы понимаем выражение логического типа, на основании которого мы можем сказать, верно оно или же нет. В данном случае, друзья, как и в цикле while, на основании условия принимается решение, будет ли выполняться очередная итерация или же цикл закончится. Также отмечу то, что в условиях часто применяются операторы арифметики и операторы сравнения. Третья часть цикла – это модификация, то есть изменение переменной счетчика. Переменная счетчика, как в этом примере, может расти с шагом на 1, может расти с большим шагом 2, 3, 4, может умножаться, а также может уменьшаться. То есть будет конструкция i равно i минус 1. Ну и само собой тело цикла, которое располагается в фигурных скобках. То есть, набор инструкций, который будет выполняться на каждой его итерации. Друзья, для правильного применения цикла for крайне важно знать механизм или же алгоритм его работы. Давайте посмотрим, как работает цикл в приведенном примере. Итак, первым шагом выполняется блок инициализации. В данном случае переменная i присваивается значение 0. Вторым шагом, друзья, происходит проверка условия. То есть мы проверяем, меньше ли переменная i, чем число 10. Если это верно, то мы выполняем, меньше ли переменная i, чем число 10. Если это верно, то мы выполняем тело цикла, то есть те инструкции, которые заключены в фигурных скобках. Соответственно, после выполнения тела цикла происходит модификация, то есть то, что мы пишем с вами в теле цикла while. В этом случае i равно i плюс 1. Ну и пятый пункт – это возврат к пункту 2, то есть к проверке условия. То есть мы снова проверяем условие. Если оно верно, мы выполняем тело цикла. Если же оно неверно, мы цикл завершаем. Друзья, обращу ваше внимание, что точно таким же образом цикл for устроен в языках программирования C, C++, Java и PHP. Итак, на текущий момент мы знаем, что в C Sharp используются две разновидности циклов – FOR и WHILE. Но как понять, какой из них применить к каждой конкретной задаче? Давайте, друзья, сформулируем некоторые рекомендации. И обращу внимание, что эти рекомендации не являются строгими правилами, но придерживаться их стоит. Цикл for мы часто используем, когда требуется перебрать элементы массива. Вывод на экран, как в этом примере. Или же подсчет суммы, подсчет среднего арифметического, или допустим поиск элементов по каким-либо критериям. Также цикл for может быть применен, когда верхняя граница числа итерации фиксирована и известна до запуска программы. В данном примере суммируются числа от 1 до 100, и мы уверены, что число итераций здесь не превысит 100. В случаях, когда нельзя заранее предсказать число итераций или же когда нам не неизвестно верхняя их граница, то можем применять цикл while. Давайте рассмотрим классический пример применения этого цикла при чтении файла посимольно. Пусть у нас имеется некоторый файл, который состоит из 27 символов. В зависимости от его кодировки, будь то ANSI, будь то UTF-8 или же Unicode, один символ может занимать 1, 2, 3 или даже 4 байта. Как вы можете видеть из строки состояния, которая указывается в нижней части блокнота, этот файл имеет кодировку UTF-8. То есть один такой символ может иметь размер как 1, 2, так и 3 или 4 байта. Это зависит от того, является ли символ буквенно-цифровым или же представляет собой некоторую иконку или же эмодзу. Обратите внимание, что размер этого файла равен 60 байтам. И зависимость от количества символов в нем не очевидна. То есть нельзя сказать, что один символ занимает 1 байт или один символ занимает 2 байта, поскольку символов, я нап очевидны. То есть нельзя сказать, что один символ занимает один байт или один символ занимает два байта, поскольку символов, я напомню, здесь 27. Поэтому, друзья, даже если мы знаем размер этого файла в байтах, мы заранее не можем предсказать, да, а сколько там будет храниться символов. Соответственно, мы не знаем, на сколько итераций нам запускать цикл for. Как раз-таки здесь нам может быть полезен цикл while. В его условии можем написать ключевое слово true, что будет означать цикл бесконечный. В его действиях мы напишем чтение очередного символа из файла и вторым действием вывод этого символа на экран. Остановить этот цикл можно будет при достижении конца файла. Друзья, давайте рассмотрим третий способ организации цикла в C-Sharp. Это цикл forEach. Для его создания мы используем ключевое слово forEach. Далее в круглых скобках мы создаем переменную цикла с указанием ее типа данных, в данном случае это целочисленный тип данных, и имени. В этом примере имя у нее E. Друзья, важный момент. Тип данных у этой переменной должен совпадать с типом данных у элементов массива. Затем мы указываем ключевое слово IN и указываем сам массив, элементы которого нам требуется перебрать. Работает цикл следующим образом. На каждой итерации в переменную цикла, в данном примере это переменная e, помещается, а если быть точнее копируется очередной элемент массива. То есть на первой итерации в переменную e попадает единица, на второй итерации двойка и так далее, пока все элементы массива не будут перебраны. Этот цикл работает практически так же, как и цикл for, только в нем не используются индексы. Отмечу, что пара циклов for и while имеют принципиальное отличие от цикла forEach в плане обращения к его элементам, а также возможности изменять эти элементы. Так вот, ключевое отличие заключается в том, что элементы в цикле forEach, они доступны только на чтение, то есть нет возможности их изменять. Достигается это за счет того, что элементы массива каждый раз копируются, именно подчеркиваю, копируются в переменную цикла. Например, с помощью цикла forEach мы можем вывести элементы на экран, как представлено в этом примере, посчитать их сумму или, например, средне арифметическое. Кроме того, forEach нам предоставляет возможность осуществить поиск каких-либо элементов. Друзья, важный момент, что попытка изменить содержимое элемента массива с помощью цикла forEach, как здесь представлено в примере, приведет к ошибке. И большинство средств разработки, не исключением здесь является и Visual Studio Code, подчеркнут еще до этапа компиляции красным и как бы просигнализируют о том, что эта конструкция приведет к ошибке. Для лучшего понимания работы цикла for each давайте рассмотрим пример из реальной жизни. Приведем набор коробок с некоторым содержимым и будем считать этот набор массивом. Так вот, друзья, цикл for each позволяет нам заглянуть, проверить содержимое каждой коробки, то есть узнать характеристики этого содержимого, допустим, вес, размер и так далее. Однако цикл forEach не позволяет нам изменять содержимое коробок, удалять что-либо оттуда или добавлять новые предметы. Для подобных манипуляций нам необходимо использовать циклы for или while, которые позволяют изменять содержимое элементов. Итак, давайте применим циклы for и for each к нашей задаче с гирями. Вернем переменную, которая хранит максимальное значение элементов массива в изначальное состояние, то есть присвоим ей значение первого элемента массива. И давайте запустим цикл for. Напомню, первым шагом мы создаем переменную счетчик. Друзья, переменная счетчик i у нас уже задействована, поэтому давайте использовать другую. Пускай это будет переменная счетчик j. Она равна нулю. Далее укажем условие цикла. Оно такое же будет, как и в цикле while. j меньше, чем число элементов n. И, друзья, укажем изменение или же модификацию переменной счетчика. Друзья, обратите внимание, что я использую оператор инкремента. Возможно, вы им уже пользовались. Он работает так же, как и конструкция j равно j плюс 1. Только имеет более сокращенный вид. Предлагаю им пользоваться. Далее, как и в цикле while, оформляем тело в фигурных скобках. Тело можно скопировать целиком, поскольку у нас идет работа с индексами, и тело никак не изменится. Единственное, что скорректируем имя переменной счетчика. Друзья, и конечно же, обратите внимание, что здесь нам не нужно дублировать модификацию счетчика, поскольку ее изменение заложено уже в самом цикле for. То есть эту строчку мы обязательно удаляем. заложено уже в самом цикле for. То есть эту строчку мы обязательно удаляем. Итак, проверим работоспособность нашего цикла for. Для этого мы видим значение переменной максимум на экран. Перейдем в каталог с задачей 4 и запустим там наш проект. На экране ожидаем увидеть дважды, да? 9 и 9. Ожидания совпадают с выводом. Также оформим решение с помощью цикла forEach. Еще раз вернем значение переменной max в начальное состояние и запустим цикла forEach. Еще раз вернем значение переменной max в начальное состояние и запустим цикл forEach. Напомню, он состоит из переменной цикла с типом данных, точно таким же, как и тип данных у элемента массива. В нашем случае это целое число. Затем идет имя переменной, ключевое слово in и сам массив. Друзья, обращение по индексу в этом цикле уже не используется. Тело цикла мы можем скопировать, но необходимо сделать соответствующие замены. То есть, таким образом, обратиться к элементу массива мы не сможем, поскольку у нас здесь работа с индексами отсутствует. Мы с вами должны пользоваться переменной цикла. В данном случае это E. Укажем переменную E. Логика работы никак не меняется. Меняется способ обращения к элементу массива. обращения к элементу массива. Итак, выведем результат работы цикла на экран, запустим наш код, ожидаем увидеть также величину 9. Да, наше ожидание соответствует выводу. Друзья, на этом практическая часть лекции заканчивается. И в заключении давайте обсудим, насколько нам нужен технический английский при разработке программ. При разработке программного обеспечения специалист зачастую сталкивается с терминологией на английском языке. Мы с вами в процессе решения задач построения алгоритмов, блок-схем часто сталкивались с терминологией на английском. Это были имена переменных, функции, а также сообщения об ошибках. Давайте резюмируем основные моменты, где знание английского будет для нас хорошим подспорьем. Первый аспект применения языка – это именование объектов. Для лучшего восприятия исходного кода мы стараемся давать переменным, функциям и другим объектам осмысленные имена, разумеется, на английском языке. В примере приведены три имени переменных с достаточно популярными названиями. Это цифра, да, от английского, digit, количество, amount и среднее, average. Давайте забежим немного вперед и рассмотрим несколько примеров именований функций. Отмечу, что зачастую имена функций состоят из нескольких слов, одной из которых является глагол. Первая функция осуществляет чтение файла по некоторому пути, вторая пишет в журнал сообщение и третья сканирует директорию на предмет наличия интересующих файлов Друзья, о функциях мы будем говорить подробнее на следующей лекции. Чтобы вести разработку программного обеспечения быстро и не обращаться к переводчику за именованием для каждой переменной, требуется пополнять свой словарный запас английскими техническими терминами. Следующий аспект, где английский может существенно нас выручить, это чтение ошибок. Будь то от редактора Visual Studio Code, будь то сообщение об ошибках от компилятора, или же, как в этом примере, от среды выполнения. Дело в том, что даже в русифицированных средах разработки сообщения об ошибках могут появляться на английском языке. Связано это с тем, что далеко не все строки, не все сообщения имеют перевод на русский. Соответственно, знание английского языка поможет вам оперативно читать сообщения об ошибках, улавливать их суть и не прибегать к помощи переводчика. Здесь я уже не говорю о том, что большое число инструментов для разработки в принципе не имеют локализации на русском языке. Третий аспект применения английского – это поиск путей, способов, решения возникающих проблем при разработке программного обеспечения. Давайте рассмотрим пример поиска информации о совместимости некоторого программного средства OpenSSL с операционной системой Windows 7. Друзья, подскажу, OpenSSL это достаточно распространенный продукт, одно из направлений в использовании которого – шифрование данных. Кому знакомы термины шифрования, криптография, можете написать об этом в чат. Так вот, обратите внимание, что попытка сформировать запрос на русском языке к явному ответу не приводит. Среди первых результатов в списке упоминания о средствах OpenSSL отсутствует совсем. Я уже не говорю о том, насколько это средство совместимо с операционной системой Windows 7. Давайте рассмотрим результат поисковой выдачи, но при формировании запроса на английском языке. Как можете видеть, уже в первой ссылке находится наш вопрос о совместимости программных средств. Друзья, можете поверить мне на слово, что подобные ситуации встречаются достаточно часто. будь то в форумах, порталах, иных ресурсах, подходящая техническая информация может попросту отсутствовать или же иметь неудовлетворительное качество. Ну и четвертый аспект применения английского, который я вынес на рассмотрение, это изучение технической документации. Документация у большинства инструментов разработки программного обеспечения изначально пишется на английском языке и не всегда получается найти качественный перевод на русский. Да, здесь можно пользоваться переводчиками, в том числе автоматизированным переводом. Но, друзья, часто случается, что при автоматизированном переводе некоторые технические термины теряют свой смысл или он искажается. И зачастую приходится обращаться к первоисточнику. Итак, друзья, мы с вами рассмотрели несколько важных аспектов применения технического английского языка. Но здесь может возникнуть вопрос, а с чего, собственно, начать изучение? Особенно, если ранее такого опыта у вас не было. Друзья, позвольте мне дать небольшую рекомендацию, выполнить которую большого труда не составит, но пользу от нее вы сможете получить достаточно быстро. Рекомендация эта достаточно нехитрая и заключается она в введении словаря или тетради с техническими терминами. То есть, если в процессе разработки вам встречается тот или иной термин, будь то от компилятора, будь то от среды разработки, будь то от сообщений среды выполнения. Вы этот термин отмечаете себе в тетрадь или ваш конспект и снабжаете его переводом. Такой словарь или тетрадь может получиться достаточно большим, поэтому чтобы эти термины откладывались в долговременную память и вы их со временем запоминали, рекомендую этот конспект время от времени перечитывать. Таким образом, количество незнакомых терминов или же сообщений об ошибках, будь то в редакторе Visual Studio Code, или же от платформы.NET, или же от среды исполнения будет сокращаться. Это вам позволит улавливать основной смысл сообщений об ошибках, давать именам и функциям более качественные названия, а также оперативно искать причины проблем в вашем коде. Ну что, друзья, на этом лекция о массивах подошла к концу. Давайте подведем ее основные итоги. Итак, в начале занятия мы с вами рассмотрели базовое определение касающиеся массивов, рассмотрели их основные характеристики. После вводного экскурса мы с вами решили блок задач на базовую обработку массивов, будь то создание, вывод на экран, заполнение, а также поиск элементов. Далее мы рассмотрели две разновидности циклов for и for each, а также обсудили особенности их применения на конкретных задачах. И в заключение, друзья, мы поговорили о важности изучения технического английского и пользы, которую от этого вы можете получить. На этом, друзья, я с вами прощаюсь. Благодарю вас за внимание. Увидимся на следующей лекции и на семинарах.",
    "chunks": [
        {
            "timestamp": [
                0.0,
                9.96
            ],
            "text": " Друзья, привет! С вами снова я, Денис. Рад вас приветствовать на лекции. Сегодня мы будем"
        },
        {
            "timestamp": [
                9.96,
                14.94
            ],
            "text": " говорить о массивах. На прошлой лекции мы познакомились с языком программирования C-Sharp,"
        },
        {
            "timestamp": [
                14.94,
                20.46
            ],
            "text": " с его основными характеристиками, а также решили блок базовых задач. На семинарах вы"
        },
        {
            "timestamp": [
                20.46,
                29.96
            ],
            "text": " попрактиковались в разработке циклических условных конструкций, применяли арифметические операторы, а также операции ввода-вывода. Сегодня мы вспомним основные понятия,"
        },
        {
            "timestamp": [
                30.14,
                35.86
            ],
            "text": " связанные с массивами, их характеристики, поговорим о том, в каких задачах массивы могут"
        },
        {
            "timestamp": [
                35.86,
                42.0
            ],
            "text": " применяться. Познакомимся, как осуществляется операция создания, заполнения, а также вывода"
        },
        {
            "timestamp": [
                42.0,
                46.26
            ],
            "text": " массивов на экран и решим блок задач на их обработку. Ближе к концу"
        },
        {
            "timestamp": [
                46.26,
                52.14
            ],
            "text": " лекции мы познакомимся с двумя разновидностями циклов for и for each, а также, друзья, поговорим"
        },
        {
            "timestamp": [
                52.14,
                58.6
            ],
            "text": " о таком важном аспекте, как изучение английского для программистов. Друзья, перед тем как приступить"
        },
        {
            "timestamp": [
                58.6,
                63.7
            ],
            "text": " к практике и начать решать задачи, давайте вспомним, а что из себя представляет массив"
        },
        {
            "timestamp": [
                63.7,
                65.34
            ],
            "text": " и какими характеристиками"
        },
        {
            "timestamp": [
                65.34,
                71.1
            ],
            "text": " он обладает. Начнем с ключевого термина этой лекции – массив. Массив представляет собой структуру"
        },
        {
            "timestamp": [
                71.1,
                76.86
            ],
            "text": " данных, которая предназначена для хранения элементов, как правило, одного типа. Массив может"
        },
        {
            "timestamp": [
                76.86,
                82.82
            ],
            "text": " состоять из целых чисел, вещественных, может состоять из символов, а также, например, из строк."
        },
        {
            "timestamp": [
                83.2,
                85.16
            ],
            "text": " Если приводить примеры из реальной жизни,"
        },
        {
            "timestamp": [
                85.76,
                91.56
            ],
            "text": " то массива мы можем назвать упорядоченный набор инструментов или же набор елочных игрушек,"
        },
        {
            "timestamp": [
                91.82,
                97.6
            ],
            "text": " который также обладает характеристикой упорядоченности. Второй важный термин – это индекс элемента"
        },
        {
            "timestamp": [
                97.6,
                102.82
            ],
            "text": " массива. Друзья, этот термин можно сформулировать по-разному. Приведем наиболее популярные"
        },
        {
            "timestamp": [
                102.82,
                106.3
            ],
            "text": " формулировки. Итак, первое, да, это смещение"
        },
        {
            "timestamp": [
                106.3,
                112.06
            ],
            "text": " элемента относительно начала массива. То есть, на сколько позиций элемент смещен, да,"
        },
        {
            "timestamp": [
                112.32,
                118.06
            ],
            "text": " относительно его левой границы. Ну и вторая формулировка, наиболее простая, это просто позиция"
        },
        {
            "timestamp": [
                118.06,
                125.12
            ],
            "text": " элемента в массиве. Друзья, напомню, что в большинстве языков программирования индекс массива начинается с нуля."
        },
        {
            "timestamp": [
                125.68,
                127.8
            ],
            "text": " Перейдем к основным характеристикам массивов."
        },
        {
            "timestamp": [
                128.46,
                132.08
            ],
            "text": " Первая характеристика это то, что массив должен иметь имя."
        },
        {
            "timestamp": [
                132.36,
                134.16
            ],
            "text": " Еще его называют идентификатор."
        },
        {
            "timestamp": [
                134.16,
                138.08
            ],
            "text": " С помощью имени мы осуществляем обращение к элементам массива."
        },
        {
            "timestamp": [
                138.46,
                141.52
            ],
            "text": " Если нам нужно изменить элемент или же просто его прочитать,"
        },
        {
            "timestamp": [
                141.82,
                145.82
            ],
            "text": " то мы используем операцию обращения к элементам по индексу."
        },
        {
            "timestamp": [
                145.82,
                150.8
            ],
            "text": " Также, друзья, эту операцию называют индексация. В большинстве языков программирования она"
        },
        {
            "timestamp": [
                150.8,
                156.6
            ],
            "text": " обозначается с помощью пары квадратных скобок. В примере приведен массив из пяти элементов и ниже"
        },
        {
            "timestamp": [
                156.6,
                162.92
            ],
            "text": " вы можете видеть обращение к каждому его элементу с помощью оператора квадратные скобки. Отметим"
        },
        {
            "timestamp": [
                162.92,
                165.52
            ],
            "text": " важную характеристику, которая определяет внутреннее"
        },
        {
            "timestamp": [
                165.52,
                171.94
            ],
            "text": " устройство массивов. Друзья, элементы в массиве располагаются последовательно, то есть в памяти,"
        },
        {
            "timestamp": [
                171.94,
                179.0
            ],
            "text": " да, они занимают ячейку за ячейкой. Ни в коем случае элементы в массиве не расположены хаотично"
        },
        {
            "timestamp": [
                179.0,
                186.72
            ],
            "text": " или же в каком-либо другом порядке. Ну и в заключение добавим, что массивы имеют конечный размер, поскольку объем"
        },
        {
            "timestamp": [
                186.72,
                192.32
            ],
            "text": " памяти у нас всегда ограничен. Итак, после небольшого экскурса в теорию давайте посмотрим,"
        },
        {
            "timestamp": [
                192.32,
                198.78
            ],
            "text": " как будут выглядеть основные операции при работе с массивами на языке C-Sharp. Рассмотрим создание,"
        },
        {
            "timestamp": [
                198.78,
                207.74
            ],
            "text": " заполнение и вывод массива на экран. В языке C-Sharp создание массива состоит из трех основных этапов. Первый"
        },
        {
            "timestamp": [
                207.74,
                213.86
            ],
            "text": " этап – это указание типа данных для элемента массива. Также, друзья, мы указываем оператор"
        },
        {
            "timestamp": [
                213.86,
                219.38
            ],
            "text": " квадратные скобки, чтобы показать, что у нас именно создается массив, а не обычная переменная."
        },
        {
            "timestamp": [
                219.38,
                227.04
            ],
            "text": " Второй этап – это указание идентификатора или же имени массива. В данном примере, друзья, мы пользуемся именем R,"
        },
        {
            "timestamp": [
                227.04,
                229.24
            ],
            "text": " что является сокращением от Array."
        },
        {
            "timestamp": [
                229.24,
                232.68
            ],
            "text": " Друзья, рекомендую давать массивам осмысленные имена."
        },
        {
            "timestamp": [
                232.68,
                236.1
            ],
            "text": " В самом простом случае можно дать имя Array."
        },
        {
            "timestamp": [
                236.1,
                240.38
            ],
            "text": " Однако рекомендую задуматься над более осмысленным именованием."
        },
        {
            "timestamp": [
                240.38,
                244.0
            ],
            "text": " Как в приведенных примерах, если вы оперируете набором"
        },
        {
            "timestamp": [
                244.0,
                247.04
            ],
            "text": " файлов, то такой массив можно назвать именем files."
        },
        {
            "timestamp": [
                247.04,
                259.26
            ],
            "text": " Если же вы оперируете набором среднесуточных температур, то подобный массив можно назвать averageDialedTemperatures или сократить до averageDialedTemps."
        },
        {
            "timestamp": [
                260.04,
                269.16
            ],
            "text": " Но здесь важно не злоупотреблять с сокращением в именовании переменных, Особенно, если эти имена становятся не общепринятыми и не общеизвестными."
        },
        {
            "timestamp": [
                269.78,
                273.86
            ],
            "text": " Имена array, ar вполне, друзья, допустимы для учебных задач,"
        },
        {
            "timestamp": [
                274.18,
                279.36
            ],
            "text": " где мы делаем упор на демонстрацию той или иной техники по обработке массивов."
        },
        {
            "timestamp": [
                279.76,
                282.82
            ],
            "text": " То есть акцент делается не на конкретной предметной области."
        },
        {
            "timestamp": [
                283.26,
                285.7
            ],
            "text": " Следующий этап – это выделение памяти"
        },
        {
            "timestamp": [
                285.7,
                292.56
            ],
            "text": " от элемента массива. На данном этапе мы указываем количество элементов, а также используем оператор"
        },
        {
            "timestamp": [
                292.56,
                299.92
            ],
            "text": " new, который нам выделит фрагмент памяти для хранения будущих элементов. На этом три основные"
        },
        {
            "timestamp": [
                299.92,
                306.12
            ],
            "text": " операции по созданию массива закончены, но также, друзья, можно выделить и четвертый этап. Он"
        },
        {
            "timestamp": [
                306.12,
                312.6
            ],
            "text": " заключается в связывании участков памяти, которые мы выделили с помощью оператора new, с именем"
        },
        {
            "timestamp": [
                312.6,
                318.76
            ],
            "text": " массива с помощью оператора присваивания. Работать сегодня мы будем в каталоге урок 2. Друзья,"
        },
        {
            "timestamp": [
                318.76,
                327.56
            ],
            "text": " иерархия каталогов на сегодня у меня уже создана. Перейдем в каталог с заданием 1 и создадим там проект,"
        },
        {
            "timestamp": [
                327.56,
                332.44
            ],
            "text": " знакомый вам командой.NET New Console."
        },
        {
            "timestamp": [
                341.52,
                348.14
            ],
            "text": " Перейдем в файл с исходным кодом program.cs Удалим код, который сгенерировался по умолчанию"
        },
        {
            "timestamp": [
                348.14,
                354.78
            ],
            "text": " Итак, укажем тип данных, массив, целых чисел"
        },
        {
            "timestamp": [
                354.78,
                361.06
            ],
            "text": " Далее дадим массиву имя, например, r"
        },
        {
            "timestamp": [
                361.06,
                363.94
            ],
            "text": " Напомним сокращение от слова array"
        },
        {
            "timestamp": [
                363.94,
                369.42
            ],
            "text": " И выделим память с помощью оператора new, допустим, на 5 целых чисел."
        },
        {
            "timestamp": [
                386.42,
                392.48
            ],
            "text": " вещественных чисел, то в этом случае мы слева от присваивания и справа от присваивания использовали бы тип данных double или же float. Друзья, после"
        },
        {
            "timestamp": [
                392.48,
                397.04
            ],
            "text": " выполнения данной операции у нас будет создан массив на 5 целых чисел."
        },
        {
            "timestamp": [
                397.04,
                408.88
            ],
            "text": " Обращаться к нему мы можем, используя его имя. Отмечу, что в языке C-sharp элементы при создании массива имеют значение"
        },
        {
            "timestamp": [
                408.88,
                415.3
            ],
            "text": " по умолчанию. Если это числовой массив, то элементами являются нули. Далее заполним"
        },
        {
            "timestamp": [
                415.3,
                421.46
            ],
            "text": " массив произвольными целыми числами. Напомню, друзья, что для изменения элементов массива"
        },
        {
            "timestamp": [
                421.46,
                425.98
            ],
            "text": " мы используем оператор индексации и в квадратных скобках указываем"
        },
        {
            "timestamp": [
                425.98,
                434.34
            ],
            "text": " индекс элемента. Заполним его произвольными целыми числами. Для ускорения можно скопировать эти конструкции."
        },
        {
            "timestamp": [
                439.2,
                445.46
            ],
            "text": " И не забываем менять индексы массива."
        },
        {
            "timestamp": [
                451.78,
                456.06
            ],
            "text": " В данном случае они у нас изменяются от нулевого и до размера массива минус 1."
        },
        {
            "timestamp": [
                459.9,
                463.44
            ],
            "text": " Сделаем элементы массива относительно случайными."
        },
        {
            "timestamp": [
                465.82,
                472.94
            ],
            "text": " Проверим, действительно ли массив заполнен. Для этого выведем каждый его элемент на экран знакомым методом writeLine из модуля консоли."
        },
        {
            "timestamp": [
                472.94,
                483.32
            ],
            "text": " Для вывода элементов, для обращения мы также используем имя массива и операцию"
        },
        {
            "timestamp": [
                483.32,
                487.8
            ],
            "text": " индексации с указанием индекса необходимого нам элемента."
        },
        {
            "timestamp": [
                487.8,
                493.98
            ],
            "text": " Для ускорения конструкцию вывода можно скопировать необходимое количество раз,"
        },
        {
            "timestamp": [
                494.86,
                498.8
            ],
            "text": " заменив индексы на соответствующих позициях."
        },
        {
            "timestamp": [
                499.86,
                519.54
            ],
            "text": " Друзья, выполним наш код с помощью команды.NET RUN."
        },
        {
            "timestamp": [
                523.42,
                523.82
            ],
            "text": " На экране мы видим значения, которые были помещены в массив."
        },
        {
            "timestamp": [
                529.18,
                529.72
            ],
            "text": " Друзья, а как вы думаете, что произойдет, если мы обратимся к элементу с индексом 5,"
        },
        {
            "timestamp": [
                532.72,
                533.18
            ],
            "text": " при том, что количество элементов в массиве равно 5?"
        },
        {
            "timestamp": [
                538.06,
                538.66
            ],
            "text": " Давайте это проверим и попробуем вывести на экран элемент с индексом равным 5."
        },
        {
            "timestamp": [
                542.1,
                547.48
            ],
            "text": " Итак, воспользуемся все тем же методом консоли Brightline и выведем на экран массив с индексом равным 5."
        },
        {
            "timestamp": [
                548.72,
                552.78
            ],
            "text": " Сохраним исходный код и запустим наш проект еще раз."
        },
        {
            "timestamp": [
                557.7,
                561.72
            ],
            "text": " Друзья, обратите внимание, что на экране у нас вывелась ошибка,"
        },
        {
            "timestamp": [
                562.72,
                566.88
            ],
            "text": " связанная с выходом за границы массива."
        },
        {
            "timestamp": [
                567.5,
                570.7
            ],
            "text": " То есть, таким образом, среда выполнения предупреждает нас о том,"
        },
        {
            "timestamp": [
                571.08,
                577.9
            ],
            "text": " что недопустимо обращаться за границы памяти, которые мы выделили для массива."
        },
        {
            "timestamp": [
                578.58,
                582.26
            ],
            "text": " Закомментируем строчку с недопустимым обращением к массиву и давайте продолжим."
        },
        {
            "timestamp": [
                583.64,
                587.38
            ],
            "text": " Итак, друзья, мы создали массив на 5 элементов,"
        },
        {
            "timestamp": [
                587.38,
                593.5
            ],
            "text": " заполнили его числами, вывели их на экран. Давайте рассмотрим способ заполнения массива сразу же при"
        },
        {
            "timestamp": [
                593.5,
                600.46
            ],
            "text": " его создании. Для этого воспользуемся той же конструкцией, которую мы использовали, только с"
        },
        {
            "timestamp": [
                600.46,
                605.18
            ],
            "text": " небольшим изменением. Все так же будем создавать массив целочисленный."
        },
        {
            "timestamp": [
                609.92,
                612.62
            ],
            "text": " Дадим ему имя r2, поскольку имя r уже занято."
        },
        {
            "timestamp": [
                618.52,
                620.22
            ],
            "text": " И после указания имени выделим память на все те же 5 элементов."
        },
        {
            "timestamp": [
                622.42,
                630.9
            ],
            "text": " Обязательно с указанием типа данных, и заполним их произвольными целыми числами сразу же при создании этого массива."
        },
        {
            "timestamp": [
                635.8,
                641.24
            ],
            "text": " Друзья, напомню, что редактор Visual Studio Code имеет инструменты форматирования кода."
        },
        {
            "timestamp": [
                641.96,
                644.48
            ],
            "text": " Для этого можно выделить необходимый участок,"
        },
        {
            "timestamp": [
                653.4,
                653.88
            ],
            "text": " форматирования кода. Для этого можно выделить необходимый участок, нажать правой кнопкой мыши и выбрать пункт меню формат документ или сочетание горячих клавиш shift alt f."
        },
        {
            "timestamp": [
                667.28,
                691.84
            ],
            "text": " Отмечу, что в C-Sharp можно использовать упрощенный синтаксис для создания массива. Он заключается в том, что команду на выделение памяти, то есть new int и указание количества элементов, в некотор случае команду на выделение памяти мы можем"
        },
        {
            "timestamp": [
                691.84,
                699.02
            ],
            "text": " не использовать, поскольку число элементов у нас фиксировано и мы их указываем сразу при создании"
        },
        {
            "timestamp": [
                699.02,
                705.2
            ],
            "text": " массива. Способ достаточно удобный для создания небольших массивов, когда заранее известны их элементы."
        },
        {
            "timestamp": [
                706.2,
                715.2
            ],
            "text": " И, друзья, отмечу, что, вероятно, знакомый многим из вас язык программирования Python имеет схожий синтаксис создания массива."
        },
        {
            "timestamp": [
                715.2,
                717.92
            ],
            "text": " Выглядит он примерно следующим образом."
        },
        {
            "timestamp": [
                733.48,
                735.48
            ],
            "text": " И также отмечу, что тип данных у массива мы не указываем."
        },
        {
            "timestamp": [
                743.1,
                744.0
            ],
            "text": " Не забываем, друзья, форматировать наш код, чтобы повысить его читаемость."
        },
        {
            "timestamp": [
                746.2,
                750.2
            ],
            "text": " Сохраним наши наработки в репозитории git."
        },
        {
            "timestamp": [
                755.2,
                758.56
            ],
            "text": " Проиндексируем целиком каталог task1."
        },
        {
            "timestamp": [
                764.16,
                764.24
            ],
            "text": " Далее сформируем commit с указанием комментария о том,"
        },
        {
            "timestamp": [
                769.18,
                776.56
            ],
            "text": " что мы добавили первую задачу в уроке 2."
        },
        {
            "timestamp": [
                799.74,
                802.96
            ],
            "text": " И отправим наши наработки на удаленный репозиторий. Друзья, перед тем как приступить к решению задач, давайте поговорим о том, а какие именно классы задач могут"
        },
        {
            "timestamp": [
                802.96,
                806.56
            ],
            "text": " быть решены с помощью массивов, а также каким"
        },
        {
            "timestamp": [
                806.56,
                813.86
            ],
            "text": " специальностям, навыкам работы с массивами и в целом знаниям основ программирования будет полезно."
        },
        {
            "timestamp": [
                813.86,
                819.72
            ],
            "text": " Один из самых простых вариантов использования – это хранение однотипных элементов и последующее"
        },
        {
            "timestamp": [
                819.72,
                826.1
            ],
            "text": " обращение к ним. Например, в массиве мы можем сохранить набор целых чисел, чисел с плавающей"
        },
        {
            "timestamp": [
                826.1,
                832.06
            ],
            "text": " точкой, символов или же набор строк, которые составляют некоторый текст. Также в массиве можем"
        },
        {
            "timestamp": [
                832.06,
                838.3
            ],
            "text": " сохранить и более сложные объекты, например, файлы. Массивы часто используются для поиска элементов"
        },
        {
            "timestamp": [
                838.3,
                845.52
            ],
            "text": " по какому-либо критерию. Например, знакомый вам поиск минимального и максимального значения среди набора целых чисел."
        },
        {
            "timestamp": [
                846.22,
                859.52
            ],
            "text": " Если же рассмотреть набор строк в виде имен файлов как массив, то в таком массиве мы можем осуществить поиск графических файлов, файлов с видеосодержимым или же, например, файлов с исходным кодом."
        },
        {
            "timestamp": [
                860.08,
                863.42
            ],
            "text": " В данном случае критерием будет расширение файла."
        },
        {
            "timestamp": [
                863.4,
                864.32
            ],
            "text": " В данном случае критерием будет расширение файла."
        },
        {
            "timestamp": [
                871.22,
                877.38
            ],
            "text": " Также отметим класс задач, в которых необходимо вычислить некоторую характеристику от всего набора элементов. Это может быть сумма значений, это может быть произведение или среднее значение."
        },
        {
            "timestamp": [
                878.16,
                883.9
            ],
            "text": " Друзья, в качестве примера можно рассмотреть вычисление суммарных затрат на предприятии."
        },
        {
            "timestamp": [
                883.88,
                887.76
            ],
            "text": " рассмотреть вычисления суммарных затрат на предприятии. В таком массиве элементами могут быть затраты предприятия"
        },
        {
            "timestamp": [
                887.76,
                891.06
            ],
            "text": " за день, за неделю или же, например, за месяц."
        },
        {
            "timestamp": [
                891.06,
                893.62
            ],
            "text": " Друзья, вопрос на засыпку."
        },
        {
            "timestamp": [
                893.62,
                896.62
            ],
            "text": " А как вы думаете, какой тип данных может быть у"
        },
        {
            "timestamp": [
                896.62,
                899.3
            ],
            "text": " элементов в подобном массиве?"
        },
        {
            "timestamp": [
                899.3,
                902.16
            ],
            "text": " Свои предположения можете написать в чат."
        },
        {
            "timestamp": [
                902.16,
                906.78
            ],
            "text": " Второй пример – это нахождение средней температуры за год. В таком"
        },
        {
            "timestamp": [
                906.78,
                913.14
            ],
            "text": " массиве элементами могут быть значения температур за месяц, из которых потом будет вычисляться"
        },
        {
            "timestamp": [
                913.14,
                918.68
            ],
            "text": " среднегодовое значение. Друзья, перед тем как порешать конкретные задачки на обработку массивов,"
        },
        {
            "timestamp": [
                918.68,
                927.22
            ],
            "text": " давайте обсудим еще такой вопрос, как применимость знаний о массивах, ну и в целом навыков программирования на конкретных"
        },
        {
            "timestamp": [
                927.22,
                933.24
            ],
            "text": " специальностях. Наиболее очевидный случай это разработчик. Массивы являются достаточно простой"
        },
        {
            "timestamp": [
                933.24,
                939.58
            ],
            "text": " и базовой структурой данных, с которой программисты знакомятся в первую очередь. После изучения"
        },
        {
            "timestamp": [
                939.58,
                945.26
            ],
            "text": " массивов, а также получения навыков по их обработке, можно переходить к изучению таких"
        },
        {
            "timestamp": [
                945.26,
                952.24
            ],
            "text": " структур данных, как стэк, очередь или же связный список. Следующая специальность, где навыки работы"
        },
        {
            "timestamp": [
                952.24,
                958.3
            ],
            "text": " с массивами не будут лишними, это тестировщик программного обеспечения. На старте профессии умение"
        },
        {
            "timestamp": [
                958.3,
                963.62
            ],
            "text": " программировать, вероятно, вам не понадобится, особенно если речь идет о ручном тестировании."
        },
        {
            "timestamp": [
                964.06,
                967.1
            ],
            "text": " Однако, если вам понадобится освоить автоматизированное"
        },
        {
            "timestamp": [
                967.1,
                969.7
            ],
            "text": " тестирование, то здесь уже, друзья, без навыков"
        },
        {
            "timestamp": [
                969.7,
                971.46
            ],
            "text": " программирования не обойтись."
        },
        {
            "timestamp": [
                971.86,
                975.54
            ],
            "text": " В частности, понимание массивов, а также навыки работы"
        },
        {
            "timestamp": [
                975.54,
                979.06
            ],
            "text": " с ними существенно ускорят изучение языка программирования"
        },
        {
            "timestamp": [
                979.06,
                980.08
            ],
            "text": " высокого уровня."
        },
        {
            "timestamp": [
                980.08,
                984.8
            ],
            "text": " К специальностям аналитик, продакт, а также project manager"
        },
        {
            "timestamp": [
                984.8,
                990.82
            ],
            "text": " высоких требований в плане владения конкретным языком программирования не предъявляется."
        },
        {
            "timestamp": [
                991.4,
                1005.5
            ],
            "text": " Однако умение программировать и в том числе навыки работы с массивами будут достаточно полезны аналитику, особенно если в круг его задач входит работа с большими объемами данных. Product и Project Manager понимание основ"
        },
        {
            "timestamp": [
                1005.5,
                1009.66
            ],
            "text": " программирования будет достаточно полезно для взаимодействия с командой"
        },
        {
            "timestamp": [
                1009.66,
                1014.88
            ],
            "text": " разработки. В частности, чтобы вести диалог с программистами на одном языке."
        },
        {
            "timestamp": [
                1014.88,
                1020.32
            ],
            "text": " Итак, друзья, давайте перейдем к первой задаче. В ней требуется заполнить массив"
        },
        {
            "timestamp": [
                1020.32,
                1026.74
            ],
            "text": " целыми числами от 1 до n, где n некоторое целое число, и вывести этот массив на экран."
        },
        {
            "timestamp": [
                1027.46,
                1033.74
            ],
            "text": " Давайте перечислим основные этапы в решении этой задачи, затем сформируем с вами блок-схему и"
        },
        {
            "timestamp": [
                1033.74,
                1039.76
            ],
            "text": " запрограммируем на языке C-sharp. Первым шагом нам необходимо понять, а какой размер будет иметь"
        },
        {
            "timestamp": [
                1039.76,
                1046.38
            ],
            "text": " создаваемый массив. Для этого, друзья, введем натуральное число n, после чего вторым шагом"
        },
        {
            "timestamp": [
                1046.38,
                1053.66
            ],
            "text": " можем создать массив на n элементов, выделив под него память. Третьим этапом можно заполнить"
        },
        {
            "timestamp": [
                1053.66,
                1060.58
            ],
            "text": " массив конкретными числами, после чего вывести его на экран. Для создания блок-схемы давайте"
        },
        {
            "timestamp": [
                1060.58,
                1065.16
            ],
            "text": " вспомним задачу с предыдущего урока на вывод чисел от 1 до n."
        },
        {
            "timestamp": [
                1065.8,
                1069.7
            ],
            "text": " Друзья, обратите внимание, что эта задача очень похожа на текущую,"
        },
        {
            "timestamp": [
                1070.24,
                1074.92
            ],
            "text": " поскольку в ней формируются числа от 1 до n и затем выводятся на экран."
        },
        {
            "timestamp": [
                1075.82,
                1081.14
            ],
            "text": " Давайте посмотрим, как можно модифицировать эту схему для решения нашей задачи."
        },
        {
            "timestamp": [
                1081.8,
                1083.4
            ],
            "text": " Первый этап у нас уже выполнен."
        },
        {
            "timestamp": [
                1083.9,
                1087.74
            ],
            "text": " Ввод числа n в схеме уже присутствует. Добавим"
        },
        {
            "timestamp": [
                1087.74,
                1094.1
            ],
            "text": " создание массива в блоке инициализации переменных до запуска цикла. Друзья, обратите внимание,"
        },
        {
            "timestamp": [
                1094.1,
                1100.62
            ],
            "text": " что создание массива у меня выделено желтым цветом. И напомню вам, что под созданием массива"
        },
        {
            "timestamp": [
                1100.62,
                1107.5
            ],
            "text": " мы понимаем выделение участка памяти для размещения элементов. Далее добавим основное"
        },
        {
            "timestamp": [
                1107.5,
                1114.26
            ],
            "text": " действие, которое позволит заполнить массив. Для этого поместим значение счетчика на очередную"
        },
        {
            "timestamp": [
                1114.26,
                1120.34
            ],
            "text": " позицию массива. Друзья, обратите внимание, что переменная счетчик изначально равна нулю,"
        },
        {
            "timestamp": [
                1120.76,
                1127.02
            ],
            "text": " поэтому мы помещаем в массив число на единицу больше, то есть, как видно из схемы i плюс 1."
        },
        {
            "timestamp": [
                1127.02,
                1134.24
            ],
            "text": " Таким образом, друзья, в массив мы будем помещать числа 1, 2, 3 и так далее до числа n."
        },
        {
            "timestamp": [
                1134.24,
                1140.4
            ],
            "text": " Вывод элемента массива можно разместить в этом же цикле, но, друзья, сделать это нужно после"
        },
        {
            "timestamp": [
                1140.4,
                1148.36
            ],
            "text": " помещения очередного значения в массив, иначе мы будем выводить элементы массива до их формирования."
        },
        {
            "timestamp": [
                1149.24,
                1153.48
            ],
            "text": " Также отмечу, что вывод элементов можно сделать и в отдельном цикле."
        },
        {
            "timestamp": [
                1153.88,
                1158.5
            ],
            "text": " То есть сначала у нас будет идти цикл по формированию элементов массива"
        },
        {
            "timestamp": [
                1158.5,
                1161.84
            ],
            "text": " и ниже точно такой же цикл для их вывода."
        },
        {
            "timestamp": [
                1161.84,
                1164.26
            ],
            "text": " Итак, наша блок-схема готова."
        },
        {
            "timestamp": [
                1164.58,
                1165.88
            ],
            "text": " Давайте посмотрим, как этот алгоритм"
        },
        {
            "timestamp": [
                1165.88,
                1174.4
            ],
            "text": " будет выглядеть на языке C-Sharp. Перейдем в каталог с заданием 2 и создадим там проект"
        },
        {
            "timestamp": [
                1174.4,
                1186.9
            ],
            "text": " командой.NET New Console. Перейдем в файл со сходным кодом, удалим код сгенерированный по умолчанию и,"
        },
        {
            "timestamp": [
                1186.9,
                1192.7
            ],
            "text": " согласно нашей блок-схеме, создадим целочисленную переменную n, равную 10."
        },
        {
            "timestamp": [
                1192.7,
                1200.5
            ],
            "text": " Друзья, поскольку число элементов в массиве заранее неизвестно, то мы будем пользоваться"
        },
        {
            "timestamp": [
                1200.5,
                1206.24
            ],
            "text": " стандартным синтаксисом создания массива с указанием оператора new,"
        },
        {
            "timestamp": [
                1206.24,
                1214.62
            ],
            "text": " типа данных и количества элементов, для которых мы будем создавать массив. Создадим переменную"
        },
        {
            "timestamp": [
                1214.62,
                1225.88
            ],
            "text": " счетчик i, изначально равную нулю. Для заполнения и вывода мы используем цикл, поскольку будем повторять одни и те же действия, пока не дойдем"
        },
        {
            "timestamp": [
                1225.88,
                1227.4
            ],
            "text": " до конца массива."
        },
        {
            "timestamp": [
                1227.4,
                1232.56
            ],
            "text": " Создадим цикл while с условием i строго меньше, чем количество"
        },
        {
            "timestamp": [
                1232.56,
                1235.18
            ],
            "text": " элементов в массиве."
        },
        {
            "timestamp": [
                1235.18,
                1239.82
            ],
            "text": " В теле цикла сформируем очередной элемент массива"
        },
        {
            "timestamp": [
                1239.82,
                1249.56
            ],
            "text": " i плюс 1 и поместим его на требуемую позицию в массиве r."
        },
        {
            "timestamp": [
                1255.84,
                1260.4
            ],
            "text": " Давайте выведем сразу его на экран с помощью инструкции"
        },
        {
            "timestamp": [
                1260.4,
                1276.98
            ],
            "text": " консоли в райт. Друзья, чтобы элементы у нас не слипались при выводе, добавим пробел после каждого"
        },
        {
            "timestamp": [
                1276.98,
                1288.94
            ],
            "text": " элемента. То есть продублируем инструкцию консоли в райт, только вместо элемента мы укажем символ пробела."
        },
        {
            "timestamp": [
                1288.94,
                1299.06
            ],
            "text": " И не забываем перейти к следующему значению счетчика"
        },
        {
            "timestamp": [
                1299.06,
                1300.88
            ],
            "text": " путем увеличения его на единицу."
        },
        {
            "timestamp": [
                1300.88,
                1305.24
            ],
            "text": " Друзья, обратите внимание на вывод элементов на экран. его на единицу."
        },
        {
            "timestamp": [
                1309.44,
                1309.86
            ],
            "text": " Друзья, обратите внимание на вывод элементов на экран."
        },
        {
            "timestamp": [
                1312.58,
                1313.62
            ],
            "text": " Давайте оформим это более изящно и в одну строку."
        },
        {
            "timestamp": [
                1318.9,
                1322.84
            ],
            "text": " Воспользуемся средством C-Sharp, которое позволяет выводить на экран строку и помещать в нее переменную."
        },
        {
            "timestamp": [
                1324.66,
                1326.84
            ],
            "text": " Для этого воспользуемся все тем же методом консоли"
        },
        {
            "timestamp": [
                1326.84,
                1335.78
            ],
            "text": " в write. Только перед строкой мы поставим значок доллара и в самой строке значение очередного"
        },
        {
            "timestamp": [
                1335.78,
                1349.42
            ],
            "text": " элемента массива array с индексом i поместим, обратите внимание, в фигурные скобки и добавим знак пробел. Друзья, в этом случае то, что было помещено в фигурные"
        },
        {
            "timestamp": [
                1349.42,
                1354.86
            ],
            "text": " скобки, будет рассматриваться как значение элемента массива или же, например, переменная,"
        },
        {
            "timestamp": [
                1354.86,
                1373.8
            ],
            "text": " и будет выведено на экран именно то, что находится в памяти, то есть сам элемент массива. Итак, давайте запустим наш код командой.NET RUN. На экране мы видим приветственное сообщение"
        },
        {
            "timestamp": [
                1373.8,
                1387.98
            ],
            "text": " hello world, однако, друзья, такого кода в файле, да, в нашем program.cs нет. Такая ситуация часто возникает, если мы забываем сохранить изменения в исходном файле."
        },
        {
            "timestamp": [
                1387.98,
                1395.54
            ],
            "text": " Давайте сохраним изменения путем нажатия комбинации клавиш Ctrl-S и запустим наш код еще раз."
        },
        {
            "timestamp": [
                1395.54,
                1405.24
            ],
            "text": " На экране мы видим последовательность чисел от 1 до 10."
        },
        {
            "timestamp": [
                1406.34,
                1411.48
            ],
            "text": " Следовательно, для этого набора элементов алгоритм работает верно."
        },
        {
            "timestamp": [
                1411.48,
                1422.22
            ],
            "text": " Друзья, обращу ваше внимание, что вместо использования переменной n, которая хранит количество элементов массива, мы можем воспользоваться свойством массива."
        },
        {
            "timestamp": [
                1428.58,
                1435.36
            ],
            "text": " свойства массива. Для этого обратимся по его имени, поставим точку и будет предложен набор методов и свойств, которыми располагает объект массив. Друзья, нам здесь из этого многообразия"
        },
        {
            "timestamp": [
                1435.36,
                1448.86
            ],
            "text": " понадобится только свойство Length, которое как раз таки хранит количество элементов, под которые выделена память. То есть, Length в данном случае будет равен"
        },
        {
            "timestamp": [
                1448.86,
                1455.0
            ],
            "text": " 10. Можно пользоваться как этим свойством, так же можно пользоваться и переменной."
        },
        {
            "timestamp": [
                1455.0,
                1463.06
            ],
            "text": " Друзья, давайте сделаем небольшую паузу, отдохнем от решения задач и рассмотрим два подхода к"
        },
        {
            "timestamp": [
                1463.06,
                1465.16
            ],
            "text": " изучению программирования."
        },
        {
            "timestamp": [
                1465.16,
                1468.04
            ],
            "text": " Основная идея первого подхода заключается в постепенном"
        },
        {
            "timestamp": [
                1468.04,
                1471.18
            ],
            "text": " повышении сложности решаемых задач."
        },
        {
            "timestamp": [
                1471.18,
                1474.48
            ],
            "text": " Друзья, наше знакомство с языком C-Sharp мы начали"
        },
        {
            "timestamp": [
                1474.48,
                1478.6
            ],
            "text": " с таких тематик, как переменные, типы данных, арифметика"
        },
        {
            "timestamp": [
                1478.6,
                1482.96
            ],
            "text": " и затем перешли к условным и циклическим конструкциям."
        },
        {
            "timestamp": [
                1482.96,
                1485.54
            ],
            "text": " Друзья, рекомендую начинаать знакомство с программированием,"
        },
        {
            "timestamp": [
                1485.9,
                1488.2
            ],
            "text": " с решением базовых и простых задач."
        },
        {
            "timestamp": [
                1489.32,
                1491.48
            ],
            "text": " Например, нарешивать их некоторое количество,"
        },
        {
            "timestamp": [
                1491.94,
                1495.54
            ],
            "text": " 5, 10, 15 штук, и переходить к более сложным."
        },
        {
            "timestamp": [
                1495.54,
                1499.5
            ],
            "text": " Более сложной задачей очень часто является комбинация"
        },
        {
            "timestamp": [
                1499.5,
                1502.0
            ],
            "text": " из набора простых задач."
        },
        {
            "timestamp": [
                1502.7,
                1508.08
            ],
            "text": " Друзья, не рекомендую сразу браться за сложные и комбинированные задачи,"
        },
        {
            "timestamp": [
                1508.3,
                1512.08
            ],
            "text": " особенно если у вас возникают сложности на базовых задачах."
        },
        {
            "timestamp": [
                1512.8,
                1517.5
            ],
            "text": " А рассмотренный подход, друзья, носит название «От простого к сложному»."
        },
        {
            "timestamp": [
                1517.5,
                1523.06
            ],
            "text": " Второй подход заключается в том, что количество решенных вами простых и базовых задач"
        },
        {
            "timestamp": [
                1523.06,
                1525.68
            ],
            "text": " будет постепенно переходить в качество."
        },
        {
            "timestamp": [
                1526.18,
                1529.82
            ],
            "text": " То есть вы будете формировать свое алгоритмическое мышление,"
        },
        {
            "timestamp": [
                1529.82,
                1533.76
            ],
            "text": " которое позволит вам решать более сложные задачи"
        },
        {
            "timestamp": [
                1533.76,
                1536.54
            ],
            "text": " и строить более сложные алгоритмы."
        },
        {
            "timestamp": [
                1537.0,
                1540.86
            ],
            "text": " Таким образом, вы сможете опираться на некоторый фундамент"
        },
        {
            "timestamp": [
                1540.86,
                1545.68
            ],
            "text": " из множества решенных вами базовых и простых задач."
        },
        {
            "timestamp": [
                1546.12,
                1550.9
            ],
            "text": " Двигаемся далее и давайте рассмотрим типовую задачу на поиск элементов в массиве,"
        },
        {
            "timestamp": [
                1551.12,
                1553.32
            ],
            "text": " которые удовлетворяют некоторым условиям."
        },
        {
            "timestamp": [
                1553.8,
                1558.36
            ],
            "text": " Пусть у нас имеется массив на некоторое количество целых чисел, допустим на 10 штук."
        },
        {
            "timestamp": [
                1558.98,
                1562.52
            ],
            "text": " Требуется найти в нем четные числа и вывести их на экран."
        },
        {
            "timestamp": [
                1562.88,
                1567.76
            ],
            "text": " Друзья, напомню, что число является четным, если оно делится на"
        },
        {
            "timestamp": [
                1567.76,
                1575.84
            ],
            "text": " цело на 2. Примеры четных чисел это 0, 2, 4, 6 и так далее. Давайте для этой задачи перечислим основные"
        },
        {
            "timestamp": [
                1575.84,
                1585.4
            ],
            "text": " этапы, сформируем ее блок-схему и реализуем эту схему на языке C-sharp. Итак, в этой задаче можно выделить следующие этапы."
        },
        {
            "timestamp": [
                1585.72,
                1590.12
            ],
            "text": " Первое. Создать и заполнить массив на 10 целых чисел."
        },
        {
            "timestamp": [
                1590.84,
                1594.26
            ],
            "text": " Вторым этапом можно выделить проход по элементам,"
        },
        {
            "timestamp": [
                1594.64,
                1596.64
            ],
            "text": " то есть просмотр каждого элемента."
        },
        {
            "timestamp": [
                1597.42,
                1603.56
            ],
            "text": " Третий этап – это проверка элемента на условия того, является ли он четным."
        },
        {
            "timestamp": [
                1604.12,
                1608.06
            ],
            "text": " Ну и четвертый этап, друзья, это вывести этот элемент на экран,"
        },
        {
            "timestamp": [
                1608.48,
                1610.68
            ],
            "text": " если указанное условие выполняется."
        },
        {
            "timestamp": [
                1611.26,
                1612.2
            ],
            "text": " Перейдем в блок схеме."
        },
        {
            "timestamp": [
                1612.96,
                1617.16
            ],
            "text": " Обращу ваше внимание, друзья, что цикл прохода по элементам массива"
        },
        {
            "timestamp": [
                1617.16,
                1619.82
            ],
            "text": " мы можем целиком взять из предыдущей задачи."
        },
        {
            "timestamp": [
                1620.58,
                1622.76
            ],
            "text": " Этот цикл будет одинаковым для всех задач,"
        },
        {
            "timestamp": [
                1623.1,
                1626.36
            ],
            "text": " где требуется перебрать или же просмотреть элементы."
        },
        {
            "timestamp": [
                1627.06,
                1630.88
            ],
            "text": " Массив мы заполним с клавиатуры сразу же при его создании."
        },
        {
            "timestamp": [
                1631.46,
                1641.68
            ],
            "text": " Я обращу ваше внимание, что цикл в этом случае можно не использовать, поскольку число элементов заранее известно, напомню их 10 штук, и оно невелико."
        },
        {
            "timestamp": [
                1642.18,
                1645.86
            ],
            "text": " Далее, в цикл прохода по элементам массива нам необходимо добавить"
        },
        {
            "timestamp": [
                1645.86,
                1651.0
            ],
            "text": " проверку очередного элемента на четность. Если же этого мы не будем делать, то на экран будет"
        },
        {
            "timestamp": [
                1651.0,
                1659.62
            ],
            "text": " выведены все элементы, включая нечетные. Обратите внимание, условие разместил в блоке решения и"
        },
        {
            "timestamp": [
                1659.62,
                1666.86
            ],
            "text": " написал там array с индексом i из even, что переводится как четный ли элемент с индексом i."
        },
        {
            "timestamp": [
                1667.5,
                1674.92
            ],
            "text": " Друзья, такая формулировка условия вполне подходит в использовании блок-схемы."
        },
        {
            "timestamp": [
                1675.14,
                1681.84
            ],
            "text": " Однако при переносе блок-схемы на конкретный язык программирования могут возникнуть существенные сложности."
        },
        {
            "timestamp": [
                1681.84,
                1682.56
            ],
            "text": " могут возникнуть существенные сложности."
        },
        {
            "timestamp": [
                1686.82,
                1691.84
            ],
            "text": " Дело в том, что языкам программирования непонятна такая формулировка условия, которая вполне понятна человеку и допускается в использовании блок-схем."
        },
        {
            "timestamp": [
                1692.18,
                1698.04
            ],
            "text": " Попытка перенести такое условие в язык программирования приведет к синтаксической ошибке."
        },
        {
            "timestamp": [
                1698.44,
                1701.32
            ],
            "text": " Друзья, к счастью, у этой проблемы есть решение."
        },
        {
            "timestamp": [
                1701.6,
                1707.38
            ],
            "text": " И заключается оно в использовании операторов сравнения и арифметических операторов"
        },
        {
            "timestamp": [
                1707.38,
                1713.74
            ],
            "text": " при построении условий. Эти операторы языки программирования вполне хорошо воспринимают."
        },
        {
            "timestamp": [
                1713.74,
                1718.94
            ],
            "text": " В данной задаче нам поможет оператор вычисления остатка отделения. Во многих современных языках"
        },
        {
            "timestamp": [
                1718.94,
                1727.74
            ],
            "text": " программирования он обозначается либо с помощью значка % либо с помощью ключевого слова mod, что от английского"
        },
        {
            "timestamp": [
                1727.74,
                1734.98
            ],
            "text": " в переводе с модула означает деление по модулю. И для проверки на равенство мы будем использовать"
        },
        {
            "timestamp": [
                1734.98,
                1740.4
            ],
            "text": " двойной знак равно. И, друзья, напомню, что одинарный значок равно обозначает другую"
        },
        {
            "timestamp": [
                1740.4,
                1745.5
            ],
            "text": " операцию. Итак, скорректируем наши условия и применим арифметический оператор"
        },
        {
            "timestamp": [
                1745.5,
                1753.62
            ],
            "text": " остаток отделения и проверки на равенство. Если остаток отделения на 2 равен 0, это мы пишем в"
        },
        {
            "timestamp": [
                1753.62,
                1760.04
            ],
            "text": " блоке решения, он у меня подсвечен оранжевым цветом, то это значит, что очередной элемент"
        },
        {
            "timestamp": [
                1760.04,
                1766.94
            ],
            "text": " массива делится на 2 нацело. То есть, он четный и мы его будем выводить на экран ниже, друзья,"
        },
        {
            "timestamp": [
                1766.94,
                1773.44
            ],
            "text": " с помощью блока ввод-вывод, который обозначается в виде параллелограммы. В нем мы напишем то,"
        },
        {
            "timestamp": [
                1773.44,
                1780.18
            ],
            "text": " что вывести очередной элемент массива array с индексом i. Итак, блок-схема нашего логаритма"
        },
        {
            "timestamp": [
                1780.18,
                1785.96
            ],
            "text": " готова. Давайте посмотрим, как он будет выглядеть на языке C Sharp. Перейдем в каталог с заданием 3"
        },
        {
            "timestamp": [
                1785.96,
                1787.16
            ],
            "text": " и создадим там проект."
        },
        {
            "timestamp": [
                1799.42,
                1801.82
            ],
            "text": " Перейдем в файл с исходным кодом, удалим"
        },
        {
            "timestamp": [
                1801.82,
                1803.2
            ],
            "text": " сгенерированный по умолчанию."
        },
        {
            "timestamp": [
                1804.34,
                1805.96
            ],
            "text": " Согласно нашей блок-схеме создадим"
        },
        {
            "timestamp": [
                1805.96,
                1816.62
            ],
            "text": " целочисленную переменную n, равную 10, и массив на 10 целых чисел. Друзья, предлагаю использовать"
        },
        {
            "timestamp": [
                1816.62,
                1829.0
            ],
            "text": " упрощенный синтаксис создания массива, поскольку число элементов заранее известно и оно невелико."
        },
        {
            "timestamp": [
                1834.0,
                1836.0
            ],
            "text": " Создадим массив из 10 произвольных целых чисел, четных, а также добавим нечетные."
        },
        {
            "timestamp": [
                1841.0,
                1843.0
            ],
            "text": " Не забываем про форматирование кода."
        },
        {
            "timestamp": [
                1842.7,
                1848.34
            ],
            "text": " Не забываем про форматирование кода."
        },
        {
            "timestamp": [
                1864.02,
                1865.94
            ],
            "text": " Создадим переменную счетчик i, изначально равную 0, и оформим цикл while с условием счетчик строго меньше, чем количество элементов n."
        },
        {
            "timestamp": [
                1871.76,
                1873.0
            ],
            "text": " На каждой итерации будем проверять четность очередного элемента с помощью условной конструкции if."
        },
        {
            "timestamp": [
                1876.34,
                1877.26
            ],
            "text": " Обратимся к конкретному элементу по индексу i."
        },
        {
            "timestamp": [
                1881.9,
                1882.38
            ],
            "text": " Разделим его с остатком на 2 и проверим, равен ли этот остаток 0."
        },
        {
            "timestamp": [
                1885.42,
                1890.88
            ],
            "text": " Если это так, друзья, то значит, что элемент четный и нам нужно вывести его на экран. Давайте это сделаем с помощью метода write."
        },
        {
            "timestamp": [
                1890.88,
                1901.54
            ],
            "text": " Друзья, предлагаю использовать метод вывода переменной сразу же в строке. То есть,"
        },
        {
            "timestamp": [
                1901.54,
                1910.6
            ],
            "text": " напомню, используем символ доллара и затем затем в строке, в фигурных скобочках, пишем элемент, который хотим вывести на экран."
        },
        {
            "timestamp": [
                1910.78,
                1913.78
            ],
            "text": " В данном случае это просто очередной элемент массива."
        },
        {
            "timestamp": [
                1914.32,
                1917.24
            ],
            "text": " И добавим пробел, чтобы элементы не слепались."
        },
        {
            "timestamp": [
                1921.5,
                1937.08
            ],
            "text": " Давайте запустим наш код. Друзья, на экране мы видим, что алгоритм у нас зациклился"
        },
        {
            "timestamp": [
                1937.08,
                1942.12
            ],
            "text": " и значение первого элемента, двойка, выводится в бесконечном"
        },
        {
            "timestamp": [
                1942.12,
                1943.12
            ],
            "text": " цикле."
        },
        {
            "timestamp": [
                1943.12,
                1945.88
            ],
            "text": " Как вы думаете, почему так вышло?"
        },
        {
            "timestamp": [
                1949.0,
                1950.76
            ],
            "text": " Я установлю вывод комбинацией клавиши Ctrl-C."
        },
        {
            "timestamp": [
                1955.72,
                1955.88
            ],
            "text": " Друзья, все дело в том, что мы с вами забыли увеличить значение переменной i,"
        },
        {
            "timestamp": [
                1960.42,
                1980.58
            ],
            "text": " то есть перейти к следующему элементу массива. Без этого мы будем обрабатывать каждый раз первый элемент массива и проверять его. То, что мы видим. То есть проверили, вывели, проверили, вывели. И если не переходить к следующему элементу, то мы зациклим наш цикл. Итак, сохраним изменения и запустим еще раз."
        },
        {
            "timestamp": [
                1993.18,
                1999.28
            ],
            "text": " еще раз. На экране мы видим четные числа, которые являются элементами этого массива. Друзья, рекомендую проверить правильность работы этого алгоритма на различных входных данных. Например,"
        },
        {
            "timestamp": [
                1999.28,
                2008.08
            ],
            "text": " массив можно задать целиком из четных чисел, из нечетных, ну или как в нашем случае из комбинации, как четных, так и нечетных."
        },
        {
            "timestamp": [
                2008.18,
                2013.3
            ],
            "text": " Таким образом мы проверим работоспособность алгоритма на различных входных условиях."
        },
        {
            "timestamp": [
                2013.3,
                2017.76
            ],
            "text": " Итак, мы с вами решили две типовые задачи на работу с массивами."
        },
        {
            "timestamp": [
                2018.18,
                2026.04
            ],
            "text": " Вспомнили, как в C-Sharp обозначаются циклические конструкции, условные, а также поработали с арифметикой и вводом-выводом."
        },
        {
            "timestamp": [
                2026.7,
                2030.86
            ],
            "text": " Друзья, давайте вспомним задачу из лекции введения в программирование,"
        },
        {
            "timestamp": [
                2031.26,
                2035.64
            ],
            "text": " которая была связана с вычислением веса наиболее тяжелой гири."
        },
        {
            "timestamp": [
                2036.26,
                2041.62
            ],
            "text": " Напомню вам, как выглядит блок-схема для поиска наиболее тяжелой гири из 5 штук."
        },
        {
            "timestamp": [
                2042.34,
                2047.56
            ],
            "text": " Друзья, мы поочередно, как можете видеть, делаем 4 сравнения в блоках решения,"
        },
        {
            "timestamp": [
                2047.56,
                2056.0
            ],
            "text": " да, и при необходимости, если эти сравнения дают нам ответ да, то по ветке yes мы обновляем значение"
        },
        {
            "timestamp": [
                2056.0,
                2067.98
            ],
            "text": " переменной max в соответствующих блоках процесс. После проведения всех сравнений в переменной max у нас будет находиться значение наиболее тяжелой гири."
        },
        {
            "timestamp": [
                2068.74,
                2074.68
            ],
            "text": " На предыдущей лекции мы с вами запрограммировали алгоритм для поиска наибольшего из 5 целых чисел."
        },
        {
            "timestamp": [
                2075.66,
                2086.44
            ],
            "text": " Мы с вами создали 5 целочисленных переменных и разместили в них некоторые произвольные числа. Далее мы с вами сделали 4 сравнения с помощью оператора if,"
        },
        {
            "timestamp": [
                2086.44,
                2093.06
            ],
            "text": " и за счет этого мы нашли вес наиболее тяжелой гири, после чего в конце алгоритма мы вывели"
        },
        {
            "timestamp": [
                2093.06,
                2100.04
            ],
            "text": " значение переменная max на экран. Друзья, но как изменится этот алгоритм, если число гирь, да,"
        },
        {
            "timestamp": [
                2100.04,
                2106.94
            ],
            "text": " или же чисел будет увеличено? Предположим, что нам необходимо найти самую тяжелую гирю из количества"
        },
        {
            "timestamp": [
                2106.94,
                2114.58
            ],
            "text": " 10 штук. Если оставить логику решения без изменений, то код может выглядеть примерно следующим образом."
        },
        {
            "timestamp": [
                2114.58,
                2122.02
            ],
            "text": " Обратите внимание, друзья, на количество переменных. Их здесь 10 штук. И количество сравнений. Да, в"
        },
        {
            "timestamp": [
                2122.02,
                2128.46
            ],
            "text": " целом задача решена, но код стал достаточно громоздким и содержит большое количество повторяющихся"
        },
        {
            "timestamp": [
                2128.46,
                2129.92
            ],
            "text": " инструкций."
        },
        {
            "timestamp": [
                2129.92,
                2132.5
            ],
            "text": " Давайте еще немного изменим условия нашей задачи и"
        },
        {
            "timestamp": [
                2132.5,
                2137.06
            ],
            "text": " увеличим количество гирь, скажем, до 100 штук."
        },
        {
            "timestamp": [
                2137.06,
                2140.38
            ],
            "text": " Как можно видеть из фрагмента исходного кода, букв латинского"
        },
        {
            "timestamp": [
                2140.38,
                2143.56
            ],
            "text": " алфавита для именования переменных мне не хватило,"
        },
        {
            "timestamp": [
                2143.56,
                2146.14
            ],
            "text": " я начал использовать переменные из двух букв."
        },
        {
            "timestamp": [
                2147.06,
                2149.22
            ],
            "text": " Также можно давать имена следующие, да,"
        },
        {
            "timestamp": [
                2149.46,
                2151.5
            ],
            "text": " гиря 1, гиря 2 и так далее."
        },
        {
            "timestamp": [
                2152.14,
                2155.1
            ],
            "text": " Но нужно использовать соответствующие английские слова, да,"
        },
        {
            "timestamp": [
                2155.46,
                2157.98
            ],
            "text": " то есть wait1, wait2 и так далее."
        },
        {
            "timestamp": [
                2159.22,
                2162.48
            ],
            "text": " Друзья, если использовать эту же, да, логику решения задачи,"
        },
        {
            "timestamp": [
                2162.48,
                2167.32
            ],
            "text": " то для создания переменных у нас уйдет порядка 100 строк исходного"
        },
        {
            "timestamp": [
                2167.32,
                2173.56
            ],
            "text": " кода и нам нужно будет запрограммировать порядка 100 практически одинаковых инструкций сравнения"
        },
        {
            "timestamp": [
                2173.56,
                2179.32
            ],
            "text": " с использованием оператора if. Друзья, согласитесь, что для решения подобной задачи нам потребуется"
        },
        {
            "timestamp": [
                2179.32,
                2186.9
            ],
            "text": " несколько иной подход. И одним из таких подходов мы можем рассмотреть использование массива для хранения"
        },
        {
            "timestamp": [
                2186.9,
                2194.38
            ],
            "text": " весов, представленных гирь. Сформулируем задачу в более общем виде. Дано n гирь, где n – некоторое"
        },
        {
            "timestamp": [
                2194.38,
                2201.2
            ],
            "text": " натуральное число, и требуется найти наиболее тяжелую гирю. Вспомним алгоритм поиска, который был"
        },
        {
            "timestamp": [
                2201.2,
                2206.02
            ],
            "text": " приведен в курсе ведения в программировании, основанный на хранении весов гирь"
        },
        {
            "timestamp": [
                2206.02,
                2208.2
            ],
            "text": " в массиве и использовании цикла."
        },
        {
            "timestamp": [
                2208.82,
                2209.82
            ],
            "text": " Друзья, обратите внимание,"
        },
        {
            "timestamp": [
                2210.0,
                2212.02
            ],
            "text": " что в этом алгоритме"
        },
        {
            "timestamp": [
                2212.02,
                2213.92
            ],
            "text": " также используется переменная max"
        },
        {
            "timestamp": [
                2213.92,
                2216.18
            ],
            "text": " и проводится n сравнений"
        },
        {
            "timestamp": [
                2216.18,
                2217.82
            ],
            "text": " для определения гири"
        },
        {
            "timestamp": [
                2217.82,
                2219.82
            ],
            "text": " наибольшего веса. Отличие"
        },
        {
            "timestamp": [
                2219.82,
                2221.98
            ],
            "text": " этого алгоритма заключается в том, что"
        },
        {
            "timestamp": [
                2221.98,
                2223.94
            ],
            "text": " в нем переменные хранятся не"
        },
        {
            "timestamp": [
                2223.94,
                2225.54
            ],
            "text": " россыпью, как в приведенных"
        },
        {
            "timestamp": [
                2225.54,
                2227.56
            ],
            "text": " ранее алгоритмах, а"
        },
        {
            "timestamp": [
                2227.56,
                2229.8
            ],
            "text": " в упорядоченном контейнере"
        },
        {
            "timestamp": [
                2229.8,
                2231.94
            ],
            "text": " по массиве. А также, друзья,"
        },
        {
            "timestamp": [
                2232.28,
                2234.22
            ],
            "text": " операция сравнения весов гирь"
        },
        {
            "timestamp": [
                2234.22,
                2236.06
            ],
            "text": " не повторяется в коде много"
        },
        {
            "timestamp": [
                2236.06,
                2237.8
            ],
            "text": " раз, а участвует"
        },
        {
            "timestamp": [
                2237.8,
                2239.82
            ],
            "text": " один раз и расположена в цикле."
        },
        {
            "timestamp": [
                2240.5,
                2241.78
            ],
            "text": " Отмечу, что этот алгоритм"
        },
        {
            "timestamp": [
                2241.78,
                2243.94
            ],
            "text": " может быть применен для произвольного"
        },
        {
            "timestamp": [
                2243.94,
                2248.28
            ],
            "text": " количества гирь, как для пяти, для сотни, так и для тысячи штук."
        },
        {
            "timestamp": [
                2248.72,
                2251.2
            ],
            "text": " Итак, перейдем в каталог для четвертого задания."
        },
        {
            "timestamp": [
                2253.56,
                2255.32
            ],
            "text": " Также создадим там новый проект."
        },
        {
            "timestamp": [
                2272.32,
                2279.04
            ],
            "text": " Давайте возьмем количество гирь, равное, допустим, 5 штук. Создадим целочисленный массив из 5 весов гирь."
        },
        {
            "timestamp": [
                2279.04,
                2284.54
            ],
            "text": " Друзья, поскольку у нас количество весов небольшое, заранее известное,"
        },
        {
            "timestamp": [
                2284.62,
                2287.26
            ],
            "text": " мы можем воспользоваться упрощенным синтаксисом"
        },
        {
            "timestamp": [
                2287.26,
                2297.16
            ],
            "text": " создания массива. Создадим массив из набора произвольных различных чисел. Не забываем"
        },
        {
            "timestamp": [
                2297.16,
                2309.04
            ],
            "text": " форматировать код. Далее создадим цикл while, который у нас пройдет по элементам массива,"
        },
        {
            "timestamp": [
                2309.04,
                2317.0
            ],
            "text": " и перед этим мы создадим переменную счетчик, которую будем использовать для условия цикла"
        },
        {
            "timestamp": [
                2317.0,
                2326.7
            ],
            "text": " i меньше чем количество элементов. Также мы эту переменную будем использовать при обращении к самим элементам."
        },
        {
            "timestamp": [
                2328.34,
                2329.54
            ],
            "text": " Друзья, для проверки, да,"
        },
        {
            "timestamp": [
                2329.82,
                2333.44
            ],
            "text": " не превышает ли очередной элемент массива"
        },
        {
            "timestamp": [
                2333.44,
                2334.98
            ],
            "text": " значение переменной max,"
        },
        {
            "timestamp": [
                2335.98,
                2340.98
            ],
            "text": " мы напишем условие array с индексом i"
        },
        {
            "timestamp": [
                2340.98,
                2344.74
            ],
            "text": " больше, чем переменная max."
        },
        {
            "timestamp": [
                2347.8,
                2355.6
            ],
            "text": " Ну и, конечно же, не забываем, да, предварительно эту переменную создать. И проинициализируем ее первым элементом массива, то есть элементом с"
        },
        {
            "timestamp": [
                2355.6,
                2366.6
            ],
            "text": " индексом 0. Если это так, да, если очередной элемент у нас превысил текущее значение максимума, то мы обновим переменную max,"
        },
        {
            "timestamp": [
                2366.6,
                2376.98
            ],
            "text": " поместив в нее текущий элемент массива. Обращаю внимание, друзья, что в случае невыполнения до"
        },
        {
            "timestamp": [
                2376.98,
                2385.76
            ],
            "text": " этого действия этого условия, если оно неверно, то никакого отдельного действия для ветки ELSA не предусмотрено. Мы ее пропускаем."
        },
        {
            "timestamp": [
                2385.76,
                2393.32
            ],
            "text": " Не забываем перейти к следующему элементу массива, увеличив значение счетчика на единицу."
        },
        {
            "timestamp": [
                2393.32,
                2398.72
            ],
            "text": " И после завершения цикла выведем значение переменной max на экран,"
        },
        {
            "timestamp": [
                2398.72,
                2405.26
            ],
            "text": " чтобы проверить правильность работы алгоритма. Сохраним изменения в исходном коде."
        },
        {
            "timestamp": [
                2407.12,
                2409.9
            ],
            "text": " Запустим наш код командой dotnet run."
        },
        {
            "timestamp": [
                2411.78,
                2418.9
            ],
            "text": " Ожидаем увидеть ответ 9, что соответствует наибольшему значению в этом массиве."
        },
        {
            "timestamp": [
                2420.32,
                2422.68
            ],
            "text": " Наши ожидания совпадают с выводом."
        },
        {
            "timestamp": [
                2422.84,
                2425.18
            ],
            "text": " Это говорит о том, что алгоритм работает правильно, друзья,"
        },
        {
            "timestamp": [
                2425.18,
                2431.16
            ],
            "text": " для указанного набора данных. Друзья, также как и в предыдущей задаче, не забываем проверить"
        },
        {
            "timestamp": [
                2431.16,
                2437.22
            ],
            "text": " правильность работы нашего алгоритма на различных входных данных. Применительно к этой задаче я бы"
        },
        {
            "timestamp": [
                2437.22,
                2447.72
            ],
            "text": " рекомендовал проверить ее работоспособность на массиве, когда у нас наибольшее число находится в конце массива, в начале или же где-то посередине."
        },
        {
            "timestamp": [
                2448.06,
                2455.3
            ],
            "text": " Также лишним не будет проверить работу алгоритма, когда массив отсортирован по возрастанию или же наоборот по убыванию."
        },
        {
            "timestamp": [
                2455.3,
                2461.24
            ],
            "text": " Таким образом вы проверите правильность его работы на различных начальных условиях."
        },
        {
            "timestamp": [
                2461.82,
                2465.7
            ],
            "text": " До настоящего момента мы с вами работали только с одной разновидностью циклов."
        },
        {
            "timestamp": [
                2465.7,
                2470.98
            ],
            "text": " Это while. Давайте посмотрим, а какие еще способы создания циклических конструкций"
        },
        {
            "timestamp": [
                2470.98,
                2477.28
            ],
            "text": " присутствуют в языке C-sharp. Друзья, на экране представлены блок-схемы с использованием блока"
        },
        {
            "timestamp": [
                2477.28,
                2483.7
            ],
            "text": " счетный цикл. Наверняка некоторые из вас при решении задач в курсе знакомства с программированием"
        },
        {
            "timestamp": [
                2483.7,
                2485.56
            ],
            "text": " использовали этот блок. Большинство современных язы с программированием использовали этот блок."
        },
        {
            "timestamp": [
                2486.1,
                2488.08
            ],
            "text": " Большинство современных языков программирования"
        },
        {
            "timestamp": [
                2488.08,
                2491.56
            ],
            "text": " поддерживают синтаксис описания счетных циклов."
        },
        {
            "timestamp": [
                2491.88,
                2494.2
            ],
            "text": " Давайте посмотрим, как это выглядит в C-Sharp."
        },
        {
            "timestamp": [
                2494.54,
                2499.5
            ],
            "text": " Итак, для создания счетного цикла используется ключевое слово for."
        },
        {
            "timestamp": [
                2500.6,
                2503.88
            ],
            "text": " Но в отличие от цикла while, где в круглоскопах мы указываем"
        },
        {
            "timestamp": [
                2503.88,
                2505.72
            ],
            "text": " только условия в цикле for,"
        },
        {
            "timestamp": [
                2506.14,
                2512.48
            ],
            "text": " обратите внимание, также указывается создание переменной счетчика, в этом случае i равное 0,"
        },
        {
            "timestamp": [
                2512.86,
                2517.82
            ],
            "text": " и изменение этой переменной, то есть ее модификация i равно i плюс 1."
        },
        {
            "timestamp": [
                2518.48,
                2523.1
            ],
            "text": " Друзья, давайте рассмотрим составные части цикла for более подробно."
        },
        {
            "timestamp": [
                2523.6,
                2527.42
            ],
            "text": " Первый блок – это блок инициализации, то есть создание переменной"
        },
        {
            "timestamp": [
                2527.42,
                2532.5
            ],
            "text": " счетчика и присвоение ей некоторого начального значения. В качестве имен переменных обычно"
        },
        {
            "timestamp": [
                2532.5,
                2540.12
            ],
            "text": " используется IJK. Это стандартный подход при создании переменных счетчиков, будь то в цикле for,"
        },
        {
            "timestamp": [
                2540.46,
                2546.22
            ],
            "text": " будь то в цикле while. Второй блок – это условия. Напомню, под условием мы понимаем выражение"
        },
        {
            "timestamp": [
                2546.22,
                2552.36
            ],
            "text": " логического типа, на основании которого мы можем сказать, верно оно или же нет. В данном случае,"
        },
        {
            "timestamp": [
                2552.36,
                2558.46
            ],
            "text": " друзья, как и в цикле while, на основании условия принимается решение, будет ли выполняться"
        },
        {
            "timestamp": [
                2558.46,
                2567.08
            ],
            "text": " очередная итерация или же цикл закончится. Также отмечу то, что в условиях часто применяются операторы арифметики"
        },
        {
            "timestamp": [
                2567.08,
                2568.78
            ],
            "text": " и операторы сравнения."
        },
        {
            "timestamp": [
                2569.44,
                2571.22
            ],
            "text": " Третья часть цикла – это модификация,"
        },
        {
            "timestamp": [
                2571.34,
                2573.44
            ],
            "text": " то есть изменение переменной счетчика."
        },
        {
            "timestamp": [
                2574.04,
                2577.44
            ],
            "text": " Переменная счетчика, как в этом примере, может расти с шагом на 1,"
        },
        {
            "timestamp": [
                2577.64,
                2580.56
            ],
            "text": " может расти с большим шагом 2, 3, 4,"
        },
        {
            "timestamp": [
                2580.74,
                2583.2
            ],
            "text": " может умножаться, а также может уменьшаться."
        },
        {
            "timestamp": [
                2583.52,
                2586.7
            ],
            "text": " То есть будет конструкция i равно i минус 1."
        },
        {
            "timestamp": [
                2587.22,
                2590.2
            ],
            "text": " Ну и само собой тело цикла, которое располагается"
        },
        {
            "timestamp": [
                2590.2,
                2591.52
            ],
            "text": " в фигурных скобках."
        },
        {
            "timestamp": [
                2591.82,
                2595.6
            ],
            "text": " То есть, набор инструкций, который будет выполняться"
        },
        {
            "timestamp": [
                2595.6,
                2597.2
            ],
            "text": " на каждой его итерации."
        },
        {
            "timestamp": [
                2597.76,
                2601.2
            ],
            "text": " Друзья, для правильного применения цикла for крайне"
        },
        {
            "timestamp": [
                2601.2,
                2604.5
            ],
            "text": " важно знать механизм или же алгоритм его работы."
        },
        {
            "timestamp": [
                2605.04,
                2608.38
            ],
            "text": " Давайте посмотрим, как работает цикл в приведенном примере."
        },
        {
            "timestamp": [
                2608.7,
                2611.66
            ],
            "text": " Итак, первым шагом выполняется блок инициализации."
        },
        {
            "timestamp": [
                2612.18,
                2615.82
            ],
            "text": " В данном случае переменная i присваивается значение 0."
        },
        {
            "timestamp": [
                2616.46,
                2619.86
            ],
            "text": " Вторым шагом, друзья, происходит проверка условия."
        },
        {
            "timestamp": [
                2619.86,
                2624.4
            ],
            "text": " То есть мы проверяем, меньше ли переменная i, чем число 10."
        },
        {
            "timestamp": [
                2624.98,
                2625.02
            ],
            "text": " Если это верно, то мы выполняем, меньше ли переменная i, чем число 10."
        },
        {
            "timestamp": [
                2627.84,
                2628.08
            ],
            "text": " Если это верно, то мы выполняем тело цикла,"
        },
        {
            "timestamp": [
                2630.98,
                2631.88
            ],
            "text": " то есть те инструкции, которые заключены в фигурных скобках."
        },
        {
            "timestamp": [
                2635.96,
                2636.5
            ],
            "text": " Соответственно, после выполнения тела цикла происходит модификация,"
        },
        {
            "timestamp": [
                2638.8,
                2641.26
            ],
            "text": " то есть то, что мы пишем с вами в теле цикла while. В этом случае i равно i плюс 1."
        },
        {
            "timestamp": [
                2642.18,
                2647.14
            ],
            "text": " Ну и пятый пункт – это возврат к пункту 2, то есть к проверке условия. То есть мы"
        },
        {
            "timestamp": [
                2647.14,
                2652.68
            ],
            "text": " снова проверяем условие. Если оно верно, мы выполняем тело цикла. Если же оно неверно,"
        },
        {
            "timestamp": [
                2652.68,
                2660.46
            ],
            "text": " мы цикл завершаем. Друзья, обращу ваше внимание, что точно таким же образом цикл for устроен в"
        },
        {
            "timestamp": [
                2660.46,
                2665.2
            ],
            "text": " языках программирования C, C++, Java и PHP."
        },
        {
            "timestamp": [
                2671.06,
                2671.64
            ],
            "text": " Итак, на текущий момент мы знаем, что в C Sharp используются две разновидности циклов – FOR и WHILE."
        },
        {
            "timestamp": [
                2675.54,
                2676.0
            ],
            "text": " Но как понять, какой из них применить к каждой конкретной задаче?"
        },
        {
            "timestamp": [
                2679.2,
                2686.04
            ],
            "text": " Давайте, друзья, сформулируем некоторые рекомендации. И обращу внимание, что эти рекомендации не являются строгими правилами, но придерживаться их стоит."
        },
        {
            "timestamp": [
                2686.8,
                2691.6
            ],
            "text": " Цикл for мы часто используем, когда требуется перебрать элементы массива."
        },
        {
            "timestamp": [
                2692.54,
                2694.92
            ],
            "text": " Вывод на экран, как в этом примере."
        },
        {
            "timestamp": [
                2694.92,
                2701.92
            ],
            "text": " Или же подсчет суммы, подсчет среднего арифметического, или допустим поиск элементов по каким-либо критериям."
        },
        {
            "timestamp": [
                2701.98,
                2705.6
            ],
            "text": " Также цикл for может быть применен, когда верхняя граница числа итерации"
        },
        {
            "timestamp": [
                2705.6,
                2712.84
            ],
            "text": " фиксирована и известна до запуска программы. В данном примере суммируются числа от 1 до 100,"
        },
        {
            "timestamp": [
                2712.84,
                2719.28
            ],
            "text": " и мы уверены, что число итераций здесь не превысит 100. В случаях, когда нельзя заранее"
        },
        {
            "timestamp": [
                2719.28,
                2725.06
            ],
            "text": " предсказать число итераций или же когда нам не неизвестно верхняя их граница,"
        },
        {
            "timestamp": [
                2726.8,
                2727.16
            ],
            "text": " то можем применять цикл while."
        },
        {
            "timestamp": [
                2730.54,
                2733.16
            ],
            "text": " Давайте рассмотрим классический пример применения этого цикла при чтении файла посимольно."
        },
        {
            "timestamp": [
                2733.84,
                2738.22
            ],
            "text": " Пусть у нас имеется некоторый файл, который состоит из 27 символов."
        },
        {
            "timestamp": [
                2738.88,
                2744.5
            ],
            "text": " В зависимости от его кодировки, будь то ANSI, будь то UTF-8 или же Unicode,"
        },
        {
            "timestamp": [
                2744.5,
                2749.36
            ],
            "text": " один символ может занимать 1, 2, 3 или даже 4 байта."
        },
        {
            "timestamp": [
                2749.84,
                2754.88
            ],
            "text": " Как вы можете видеть из строки состояния, которая указывается в нижней части блокнота,"
        },
        {
            "timestamp": [
                2755.16,
                2757.68
            ],
            "text": " этот файл имеет кодировку UTF-8."
        },
        {
            "timestamp": [
                2758.14,
                2765.14
            ],
            "text": " То есть один такой символ может иметь размер как 1, 2, так и 3 или 4 байта."
        },
        {
            "timestamp": [
                2768.34,
                2773.18
            ],
            "text": " Это зависит от того, является ли символ буквенно-цифровым или же представляет собой некоторую иконку или же эмодзу."
        },
        {
            "timestamp": [
                2773.74,
                2778.0
            ],
            "text": " Обратите внимание, что размер этого файла равен 60 байтам."
        },
        {
            "timestamp": [
                2778.42,
                2781.52
            ],
            "text": " И зависимость от количества символов в нем не очевидна."
        },
        {
            "timestamp": [
                2781.52,
                2784.84
            ],
            "text": " То есть нельзя сказать, что один символ занимает 1 байт"
        },
        {
            "timestamp": [
                2784.84,
                2785.7
            ],
            "text": " или один символ занимает 2 байта, поскольку символов, я нап очевидны. То есть нельзя сказать, что один символ занимает один байт или один символ"
        },
        {
            "timestamp": [
                2785.7,
                2788.62
            ],
            "text": " занимает два байта, поскольку символов, я напомню, здесь"
        },
        {
            "timestamp": [
                2788.62,
                2793.0
            ],
            "text": " 27. Поэтому, друзья, даже если мы знаем размер этого"
        },
        {
            "timestamp": [
                2793.0,
                2796.42
            ],
            "text": " файла в байтах, мы заранее не можем предсказать, да,"
        },
        {
            "timestamp": [
                2796.42,
                2799.94
            ],
            "text": " а сколько там будет храниться символов. Соответственно,"
        },
        {
            "timestamp": [
                2799.94,
                2802.48
            ],
            "text": " мы не знаем, на сколько итераций нам запускать"
        },
        {
            "timestamp": [
                2802.48,
                2806.02
            ],
            "text": " цикл for. Как раз-таки здесь нам может быть полезен цикл"
        },
        {
            "timestamp": [
                2806.02,
                2813.14
            ],
            "text": " while. В его условии можем написать ключевое слово true, что будет означать цикл бесконечный. В его"
        },
        {
            "timestamp": [
                2813.14,
                2819.72
            ],
            "text": " действиях мы напишем чтение очередного символа из файла и вторым действием вывод этого символа"
        },
        {
            "timestamp": [
                2819.72,
                2826.12
            ],
            "text": " на экран. Остановить этот цикл можно будет при достижении конца файла. Друзья, давайте рассмотрим"
        },
        {
            "timestamp": [
                2826.12,
                2832.7
            ],
            "text": " третий способ организации цикла в C-Sharp. Это цикл forEach. Для его создания мы используем ключевое"
        },
        {
            "timestamp": [
                2832.7,
                2839.24
            ],
            "text": " слово forEach. Далее в круглых скобках мы создаем переменную цикла с указанием ее типа данных,"
        },
        {
            "timestamp": [
                2839.24,
                2849.18
            ],
            "text": " в данном случае это целочисленный тип данных, и имени. В этом примере имя у нее E. Друзья, важный момент. Тип"
        },
        {
            "timestamp": [
                2849.18,
                2856.5
            ],
            "text": " данных у этой переменной должен совпадать с типом данных у элементов массива. Затем мы указываем"
        },
        {
            "timestamp": [
                2856.5,
                2865.7
            ],
            "text": " ключевое слово IN и указываем сам массив, элементы которого нам требуется перебрать. Работает цикл следующим образом."
        },
        {
            "timestamp": [
                2866.44,
                2873.14
            ],
            "text": " На каждой итерации в переменную цикла, в данном примере это переменная e, помещается, а если быть"
        },
        {
            "timestamp": [
                2873.14,
                2880.0
            ],
            "text": " точнее копируется очередной элемент массива. То есть на первой итерации в переменную e попадает"
        },
        {
            "timestamp": [
                2880.0,
                2886.0
            ],
            "text": " единица, на второй итерации двойка и так далее, пока все элементы массива не будут перебраны."
        },
        {
            "timestamp": [
                2886.0,
                2890.02
            ],
            "text": " Этот цикл работает практически так же, как и цикл for, только"
        },
        {
            "timestamp": [
                2890.02,
                2892.78
            ],
            "text": " в нем не используются индексы."
        },
        {
            "timestamp": [
                2892.78,
                2897.1
            ],
            "text": " Отмечу, что пара циклов for и while имеют принципиальное"
        },
        {
            "timestamp": [
                2897.1,
                2901.4
            ],
            "text": " отличие от цикла forEach в плане обращения к его"
        },
        {
            "timestamp": [
                2901.4,
                2905.24
            ],
            "text": " элементам, а также возможности изменять эти элементы."
        },
        {
            "timestamp": [
                2909.54,
                2909.76
            ],
            "text": " Так вот, ключевое отличие заключается в том, что элементы в цикле forEach,"
        },
        {
            "timestamp": [
                2913.66,
                2914.52
            ],
            "text": " они доступны только на чтение, то есть нет возможности их изменять."
        },
        {
            "timestamp": [
                2919.84,
                2919.92
            ],
            "text": " Достигается это за счет того, что элементы массива каждый раз копируются,"
        },
        {
            "timestamp": [
                2923.42,
                2923.96
            ],
            "text": " именно подчеркиваю, копируются в переменную цикла."
        },
        {
            "timestamp": [
                2926.56,
                2932.16
            ],
            "text": " Например, с помощью цикла forEach мы можем вывести элементы на экран, как представлено в этом примере, посчитать их сумму или, например,"
        },
        {
            "timestamp": [
                2932.16,
                2938.24
            ],
            "text": " средне арифметическое. Кроме того, forEach нам предоставляет возможность осуществить поиск"
        },
        {
            "timestamp": [
                2938.24,
                2949.46
            ],
            "text": " каких-либо элементов. Друзья, важный момент, что попытка изменить содержимое элемента массива с помощью цикла forEach, как здесь представлено в примере, приведет к ошибке."
        },
        {
            "timestamp": [
                2949.88,
                2965.12
            ],
            "text": " И большинство средств разработки, не исключением здесь является и Visual Studio Code, подчеркнут еще до этапа компиляции красным и как бы просигнализируют о том, что эта конструкция приведет к ошибке."
        },
        {
            "timestamp": [
                2970.26,
                2971.44
            ],
            "text": " Для лучшего понимания работы цикла for each давайте рассмотрим пример из реальной жизни."
        },
        {
            "timestamp": [
                2976.84,
                2977.2
            ],
            "text": " Приведем набор коробок с некоторым содержимым и будем считать этот набор массивом."
        },
        {
            "timestamp": [
                2983.8,
                2986.88
            ],
            "text": " Так вот, друзья, цикл for each позволяет нам заглянуть, проверить содержимое каждой коробки, то есть узнать характеристики этого содержимого,"
        },
        {
            "timestamp": [
                2987.0,
                2994.16
            ],
            "text": " допустим, вес, размер и так далее. Однако цикл forEach не позволяет нам изменять содержимое коробок,"
        },
        {
            "timestamp": [
                2994.86,
                3000.78
            ],
            "text": " удалять что-либо оттуда или добавлять новые предметы. Для подобных манипуляций нам необходимо"
        },
        {
            "timestamp": [
                3000.78,
                3006.2
            ],
            "text": " использовать циклы for или while, которые позволяют изменять содержимое элементов."
        },
        {
            "timestamp": [
                3006.84,
                3010.92
            ],
            "text": " Итак, давайте применим циклы for и for each к нашей задаче с гирями."
        },
        {
            "timestamp": [
                3011.92,
                3016.96
            ],
            "text": " Вернем переменную, которая хранит максимальное значение элементов массива"
        },
        {
            "timestamp": [
                3016.96,
                3022.1
            ],
            "text": " в изначальное состояние, то есть присвоим ей значение первого элемента массива."
        },
        {
            "timestamp": [
                3023.18,
                3024.48
            ],
            "text": " И давайте запустим цикл for."
        },
        {
            "timestamp": [
                3024.74,
                3028.4
            ],
            "text": " Напомню, первым шагом мы создаем переменную счетчик."
        },
        {
            "timestamp": [
                3028.82,
                3032.1
            ],
            "text": " Друзья, переменная счетчик i у нас уже задействована,"
        },
        {
            "timestamp": [
                3032.2,
                3033.7
            ],
            "text": " поэтому давайте использовать другую."
        },
        {
            "timestamp": [
                3034.06,
                3036.22
            ],
            "text": " Пускай это будет переменная счетчик j."
        },
        {
            "timestamp": [
                3036.98,
                3037.84
            ],
            "text": " Она равна нулю."
        },
        {
            "timestamp": [
                3039.2,
                3040.6
            ],
            "text": " Далее укажем условие цикла."
        },
        {
            "timestamp": [
                3040.66,
                3042.4
            ],
            "text": " Оно такое же будет, как и в цикле while."
        },
        {
            "timestamp": [
                3042.4,
                3048.22
            ],
            "text": " j меньше, чем число элементов n. И, друзья, укажем"
        },
        {
            "timestamp": [
                3048.22,
                3058.6
            ],
            "text": " изменение или же модификацию переменной счетчика. Друзья, обратите внимание, что я использую оператор"
        },
        {
            "timestamp": [
                3058.6,
                3067.72
            ],
            "text": " инкремента. Возможно, вы им уже пользовались. Он работает так же, как и конструкция j равно j плюс 1."
        },
        {
            "timestamp": [
                3068.32,
                3070.5
            ],
            "text": " Только имеет более сокращенный вид."
        },
        {
            "timestamp": [
                3071.08,
                3072.68
            ],
            "text": " Предлагаю им пользоваться."
        },
        {
            "timestamp": [
                3073.02,
                3076.46
            ],
            "text": " Далее, как и в цикле while, оформляем тело в фигурных скобках."
        },
        {
            "timestamp": [
                3077.14,
                3078.66
            ],
            "text": " Тело можно скопировать целиком,"
        },
        {
            "timestamp": [
                3078.78,
                3081.5
            ],
            "text": " поскольку у нас идет работа с индексами,"
        },
        {
            "timestamp": [
                3081.5,
                3083.28
            ],
            "text": " и тело никак не изменится."
        },
        {
            "timestamp": [
                3084.34,
                3087.9
            ],
            "text": " Единственное, что скорректируем имя переменной счетчика."
        },
        {
            "timestamp": [
                3089.7,
                3102.26
            ],
            "text": " Друзья, и конечно же, обратите внимание, что здесь нам не нужно дублировать модификацию счетчика, поскольку ее изменение заложено уже в самом цикле for."
        },
        {
            "timestamp": [
                3103.0,
                3104.96
            ],
            "text": " То есть эту строчку мы обязательно удаляем."
        },
        {
            "timestamp": [
                3104.88,
                3117.24
            ],
            "text": " заложено уже в самом цикле for. То есть эту строчку мы обязательно удаляем. Итак, проверим работоспособность нашего цикла for. Для этого мы видим значение"
        },
        {
            "timestamp": [
                3117.24,
                3126.94
            ],
            "text": " переменной максимум на экран. Перейдем в каталог с задачей 4 и запустим там наш проект."
        },
        {
            "timestamp": [
                3130.94,
                3134.64
            ],
            "text": " На экране ожидаем увидеть дважды, да? 9 и 9."
        },
        {
            "timestamp": [
                3136.02,
                3138.24
            ],
            "text": " Ожидания совпадают с выводом."
        },
        {
            "timestamp": [
                3138.24,
                3141.26
            ],
            "text": " Также оформим решение с помощью цикла forEach."
        },
        {
            "timestamp": [
                3143.44,
                3147.32
            ],
            "text": " Еще раз вернем значение переменной max в начальное состояние и запустим цикла forEach. Еще раз вернем значение переменной max в начальное состояние"
        },
        {
            "timestamp": [
                3147.32,
                3149.72
            ],
            "text": " и запустим цикл forEach."
        },
        {
            "timestamp": [
                3151.96,
                3156.14
            ],
            "text": " Напомню, он состоит из переменной цикла с типом данных,"
        },
        {
            "timestamp": [
                3156.18,
                3159.32
            ],
            "text": " точно таким же, как и тип данных у элемента массива."
        },
        {
            "timestamp": [
                3159.66,
                3161.66
            ],
            "text": " В нашем случае это целое число."
        },
        {
            "timestamp": [
                3162.76,
                3172.0
            ],
            "text": " Затем идет имя переменной, ключевое слово in и сам массив. Друзья,"
        },
        {
            "timestamp": [
                3172.0,
                3177.34
            ],
            "text": " обращение по индексу в этом цикле уже не используется. Тело цикла мы можем скопировать,"
        },
        {
            "timestamp": [
                3177.34,
                3182.34
            ],
            "text": " но необходимо сделать соответствующие замены. То есть, таким образом, обратиться к элементу"
        },
        {
            "timestamp": [
                3182.34,
                3186.64
            ],
            "text": " массива мы не сможем, поскольку у нас здесь работа с индексами отсутствует."
        },
        {
            "timestamp": [
                3186.98,
                3190.4
            ],
            "text": " Мы с вами должны пользоваться переменной цикла."
        },
        {
            "timestamp": [
                3190.7,
                3191.58
            ],
            "text": " В данном случае это E."
        },
        {
            "timestamp": [
                3193.34,
                3194.88
            ],
            "text": " Укажем переменную E."
        },
        {
            "timestamp": [
                3196.58,
                3198.74
            ],
            "text": " Логика работы никак не меняется."
        },
        {
            "timestamp": [
                3199.34,
                3202.38
            ],
            "text": " Меняется способ обращения к элементу массива."
        },
        {
            "timestamp": [
                3213.86,
                3223.32
            ],
            "text": " обращения к элементу массива. Итак, выведем результат работы цикла на экран, запустим наш код, ожидаем увидеть также величину 9. Да, наше ожидание соответствует выводу. Друзья, на этом"
        },
        {
            "timestamp": [
                3223.32,
                3226.44
            ],
            "text": " практическая часть лекции заканчивается. И в заключении давайте"
        },
        {
            "timestamp": [
                3226.44,
                3228.16
            ],
            "text": " обсудим, насколько нам нужен"
        },
        {
            "timestamp": [
                3228.16,
                3230.16
            ],
            "text": " технический английский при"
        },
        {
            "timestamp": [
                3230.16,
                3232.66
            ],
            "text": " разработке программ. При разработке"
        },
        {
            "timestamp": [
                3232.66,
                3234.54
            ],
            "text": " программного обеспечения специалист"
        },
        {
            "timestamp": [
                3234.54,
                3237.0
            ],
            "text": " зачастую сталкивается с терминологией"
        },
        {
            "timestamp": [
                3237.0,
                3238.1
            ],
            "text": " на английском языке."
        },
        {
            "timestamp": [
                3238.68,
                3240.68
            ],
            "text": " Мы с вами в процессе решения задач"
        },
        {
            "timestamp": [
                3240.68,
                3242.88
            ],
            "text": " построения алгоритмов, блок-схем"
        },
        {
            "timestamp": [
                3242.88,
                3244.96
            ],
            "text": " часто сталкивались с терминологией"
        },
        {
            "timestamp": [
                3244.96,
                3246.3
            ],
            "text": " на английском. Это"
        },
        {
            "timestamp": [
                3246.3,
                3252.78
            ],
            "text": " были имена переменных, функции, а также сообщения об ошибках. Давайте резюмируем основные моменты,"
        },
        {
            "timestamp": [
                3252.78,
                3259.38
            ],
            "text": " где знание английского будет для нас хорошим подспорьем. Первый аспект применения языка – это"
        },
        {
            "timestamp": [
                3259.38,
                3269.84
            ],
            "text": " именование объектов. Для лучшего восприятия исходного кода мы стараемся давать переменным, функциям и другим объектам осмысленные имена, разумеется, на английском языке."
        },
        {
            "timestamp": [
                3270.22,
                3275.14
            ],
            "text": " В примере приведены три имени переменных с достаточно популярными названиями."
        },
        {
            "timestamp": [
                3275.2,
                3281.8
            ],
            "text": " Это цифра, да, от английского, digit, количество, amount и среднее, average."
        },
        {
            "timestamp": [
                3282.94,
                3286.3
            ],
            "text": " Давайте забежим немного вперед и рассмотрим несколько примеров"
        },
        {
            "timestamp": [
                3286.3,
                3293.04
            ],
            "text": " именований функций. Отмечу, что зачастую имена функций состоят из нескольких слов,"
        },
        {
            "timestamp": [
                3293.04,
                3299.1
            ],
            "text": " одной из которых является глагол. Первая функция осуществляет чтение файла по"
        },
        {
            "timestamp": [
                3299.1,
                3304.96
            ],
            "text": " некоторому пути, вторая пишет в журнал сообщение и третья сканирует директорию"
        },
        {
            "timestamp": [
                3304.96,
                3307.7
            ],
            "text": " на предмет наличия интересующих файлов"
        },
        {
            "timestamp": [
                3307.7,
                3311.5
            ],
            "text": " Друзья, о функциях мы будем говорить подробнее на следующей лекции."
        },
        {
            "timestamp": [
                3311.5,
                3324.62
            ],
            "text": " Чтобы вести разработку программного обеспечения быстро и не обращаться к переводчику за именованием для каждой переменной, требуется пополнять свой словарный запас английскими техническими терминами."
        },
        {
            "timestamp": [
                3325.16,
                3329.4
            ],
            "text": " Следующий аспект, где английский может существенно нас выручить, это чтение ошибок."
        },
        {
            "timestamp": [
                3329.88,
                3332.24
            ],
            "text": " Будь то от редактора Visual Studio Code,"
        },
        {
            "timestamp": [
                3332.68,
                3335.38
            ],
            "text": " будь то сообщение об ошибках от компилятора,"
        },
        {
            "timestamp": [
                3335.82,
                3338.8
            ],
            "text": " или же, как в этом примере, от среды выполнения."
        },
        {
            "timestamp": [
                3339.3,
                3342.08
            ],
            "text": " Дело в том, что даже в русифицированных средах разработки"
        },
        {
            "timestamp": [
                3342.08,
                3346.78
            ],
            "text": " сообщения об ошибках могут появляться на английском языке."
        },
        {
            "timestamp": [
                3347.32,
                3353.58
            ],
            "text": " Связано это с тем, что далеко не все строки, не все сообщения имеют перевод на русский. Соответственно,"
        },
        {
            "timestamp": [
                3353.68,
                3360.02
            ],
            "text": " знание английского языка поможет вам оперативно читать сообщения об ошибках, улавливать их суть"
        },
        {
            "timestamp": [
                3360.02,
                3366.08
            ],
            "text": " и не прибегать к помощи переводчика. Здесь я уже не говорю о том, что большое число инструментов для разработки"
        },
        {
            "timestamp": [
                3366.08,
                3369.78
            ],
            "text": " в принципе не имеют локализации на русском языке."
        },
        {
            "timestamp": [
                3370.44,
                3374.68
            ],
            "text": " Третий аспект применения английского – это поиск путей, способов,"
        },
        {
            "timestamp": [
                3375.22,
                3378.94
            ],
            "text": " решения возникающих проблем при разработке программного обеспечения."
        },
        {
            "timestamp": [
                3380.1,
                3382.2
            ],
            "text": " Давайте рассмотрим пример поиска информации"
        },
        {
            "timestamp": [
                3382.2,
                3387.82
            ],
            "text": " о совместимости некоторого программного средства OpenSSL с операционной системой Windows 7."
        },
        {
            "timestamp": [
                3388.42,
                3397.02
            ],
            "text": " Друзья, подскажу, OpenSSL это достаточно распространенный продукт, одно из направлений в использовании которого – шифрование данных."
        },
        {
            "timestamp": [
                3397.38,
                3401.44
            ],
            "text": " Кому знакомы термины шифрования, криптография, можете написать об этом в чат."
        },
        {
            "timestamp": [
                3401.58,
                3405.56
            ],
            "text": " Так вот, обратите внимание, что попытка сформировать запрос на русском языке"
        },
        {
            "timestamp": [
                3405.56,
                3407.84
            ],
            "text": " к явному ответу не приводит."
        },
        {
            "timestamp": [
                3408.7,
                3413.7
            ],
            "text": " Среди первых результатов в списке упоминания о средствах OpenSSL отсутствует совсем."
        },
        {
            "timestamp": [
                3414.08,
                3420.24
            ],
            "text": " Я уже не говорю о том, насколько это средство совместимо с операционной системой Windows 7."
        },
        {
            "timestamp": [
                3420.24,
                3426.46
            ],
            "text": " Давайте рассмотрим результат поисковой выдачи, но при формировании запроса на английском языке."
        },
        {
            "timestamp": [
                3426.96,
                3433.32
            ],
            "text": " Как можете видеть, уже в первой ссылке находится наш вопрос о совместимости программных средств."
        },
        {
            "timestamp": [
                3433.74,
                3451.36
            ],
            "text": " Друзья, можете поверить мне на слово, что подобные ситуации встречаются достаточно часто. будь то в форумах, порталах, иных ресурсах, подходящая техническая информация может попросту отсутствовать или же иметь неудовлетворительное качество."
        },
        {
            "timestamp": [
                3451.96,
                3458.44
            ],
            "text": " Ну и четвертый аспект применения английского, который я вынес на рассмотрение, это изучение технической документации."
        },
        {
            "timestamp": [
                3458.96,
                3466.26
            ],
            "text": " Документация у большинства инструментов разработки программного обеспечения изначально пишется на английском языке и не всегда"
        },
        {
            "timestamp": [
                3466.26,
                3471.76
            ],
            "text": " получается найти качественный перевод на русский. Да, здесь можно пользоваться переводчиками,"
        },
        {
            "timestamp": [
                3471.76,
                3477.34
            ],
            "text": " в том числе автоматизированным переводом. Но, друзья, часто случается, что при автоматизированном"
        },
        {
            "timestamp": [
                3477.34,
                3484.06
            ],
            "text": " переводе некоторые технические термины теряют свой смысл или он искажается. И зачастую приходится"
        },
        {
            "timestamp": [
                3484.06,
                3485.82
            ],
            "text": " обращаться к первоисточнику."
        },
        {
            "timestamp": [
                3486.36,
                3489.2
            ],
            "text": " Итак, друзья, мы с вами рассмотрели несколько важных аспектов"
        },
        {
            "timestamp": [
                3489.2,
                3491.44
            ],
            "text": " применения технического английского языка."
        },
        {
            "timestamp": [
                3491.9,
                3493.56
            ],
            "text": " Но здесь может возникнуть вопрос,"
        },
        {
            "timestamp": [
                3493.96,
                3495.74
            ],
            "text": " а с чего, собственно, начать изучение?"
        },
        {
            "timestamp": [
                3496.34,
                3498.6
            ],
            "text": " Особенно, если ранее такого опыта у вас не было."
        },
        {
            "timestamp": [
                3498.98,
                3501.22
            ],
            "text": " Друзья, позвольте мне дать небольшую рекомендацию,"
        },
        {
            "timestamp": [
                3501.5,
                3504.26
            ],
            "text": " выполнить которую большого труда не составит,"
        },
        {
            "timestamp": [
                3504.26,
                3506.46
            ],
            "text": " но пользу от нее вы сможете"
        },
        {
            "timestamp": [
                3506.46,
                3507.7
            ],
            "text": " получить достаточно быстро."
        },
        {
            "timestamp": [
                3508.28,
                3510.02
            ],
            "text": " Рекомендация эта достаточно нехитрая"
        },
        {
            "timestamp": [
                3510.02,
                3512.18
            ],
            "text": " и заключается она в введении"
        },
        {
            "timestamp": [
                3512.18,
                3514.7
            ],
            "text": " словаря или тетради с техническими"
        },
        {
            "timestamp": [
                3514.7,
                3515.94
            ],
            "text": " терминами. То есть,"
        },
        {
            "timestamp": [
                3516.22,
                3517.54
            ],
            "text": " если в процессе разработки"
        },
        {
            "timestamp": [
                3517.54,
                3520.18
            ],
            "text": " вам встречается тот или иной термин,"
        },
        {
            "timestamp": [
                3520.26,
                3522.02
            ],
            "text": " будь то от компилятора, будь то"
        },
        {
            "timestamp": [
                3522.02,
                3524.08
            ],
            "text": " от среды разработки, будь то"
        },
        {
            "timestamp": [
                3524.08,
                3526.18
            ],
            "text": " от сообщений среды выполнения."
        },
        {
            "timestamp": [
                3526.18,
                3533.02
            ],
            "text": " Вы этот термин отмечаете себе в тетрадь или ваш конспект и снабжаете его переводом. Такой словарь"
        },
        {
            "timestamp": [
                3533.02,
                3538.1
            ],
            "text": " или тетрадь может получиться достаточно большим, поэтому чтобы эти термины откладывались в"
        },
        {
            "timestamp": [
                3538.1,
                3543.88
            ],
            "text": " долговременную память и вы их со временем запоминали, рекомендую этот конспект время"
        },
        {
            "timestamp": [
                3543.88,
                3545.28
            ],
            "text": " от времени перечитывать."
        },
        {
            "timestamp": [
                3545.54,
                3548.52
            ],
            "text": " Таким образом, количество незнакомых терминов или"
        },
        {
            "timestamp": [
                3548.52,
                3551.52
            ],
            "text": " же сообщений об ошибках, будь то в редакторе Visual"
        },
        {
            "timestamp": [
                3551.52,
                3555.62
            ],
            "text": " Studio Code, или же от платформы.NET, или же от среды исполнения"
        },
        {
            "timestamp": [
                3555.62,
                3557.14
            ],
            "text": " будет сокращаться."
        },
        {
            "timestamp": [
                3557.64,
                3560.82
            ],
            "text": " Это вам позволит улавливать основной смысл сообщений"
        },
        {
            "timestamp": [
                3560.82,
                3564.24
            ],
            "text": " об ошибках, давать именам и функциям более качественные"
        },
        {
            "timestamp": [
                3564.24,
                3566.32
            ],
            "text": " названия, а также оперативно"
        },
        {
            "timestamp": [
                3566.32,
                3573.14
            ],
            "text": " искать причины проблем в вашем коде. Ну что, друзья, на этом лекция о массивах подошла к концу."
        },
        {
            "timestamp": [
                3573.14,
                3579.44
            ],
            "text": " Давайте подведем ее основные итоги. Итак, в начале занятия мы с вами рассмотрели базовое определение"
        },
        {
            "timestamp": [
                3579.44,
                3587.32
            ],
            "text": " касающиеся массивов, рассмотрели их основные характеристики. После вводного экскурса мы с вами решили блок"
        },
        {
            "timestamp": [
                3587.32,
                3594.7
            ],
            "text": " задач на базовую обработку массивов, будь то создание, вывод на экран, заполнение, а также поиск"
        },
        {
            "timestamp": [
                3594.7,
                3602.86
            ],
            "text": " элементов. Далее мы рассмотрели две разновидности циклов for и for each, а также обсудили особенности"
        },
        {
            "timestamp": [
                3602.86,
                3606.28
            ],
            "text": " их применения на конкретных задачах. И в заключение,"
        },
        {
            "timestamp": [
                3606.38,
                3607.66
            ],
            "text": " друзья, мы поговорили о"
        },
        {
            "timestamp": [
                3607.66,
                3609.82
            ],
            "text": " важности изучения технического"
        },
        {
            "timestamp": [
                3609.82,
                3612.16
            ],
            "text": " английского и пользы,"
        },
        {
            "timestamp": [
                3612.38,
                3613.9
            ],
            "text": " которую от этого вы можете получить."
        },
        {
            "timestamp": [
                3614.26,
                3615.84
            ],
            "text": " На этом, друзья, я с вами прощаюсь."
        },
        {
            "timestamp": [
                3616.22,
                3618.12
            ],
            "text": " Благодарю вас за внимание. Увидимся"
        },
        {
            "timestamp": [
                3618.12,
                3620.1
            ],
            "text": " на следующей лекции и на семинарах."
        }
    ]
}