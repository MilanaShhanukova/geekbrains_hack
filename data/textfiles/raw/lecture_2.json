{
    "text": " you you you you Друзья, всех приветствую! Поздравляю вас с выходом на финишную прямую нашего курса. Сегодня мы рассматриваем заключительные тематики, а также подводим итоги проведенных занятий. План на сегодня у нас следующий. Дадим определение рекурсии, рассмотрим, что она из себя представляет, а также приведем примеры из жизни. Далее мы поговорим о рекурсии в контексте программирования, рассмотрим ее составные части и решим блок задач. Отдельным пунктом обсудим, что такое отладка программ. И примерим два способа отладки на наших программах. В заключение рассмотрим три полезных принципа разработки программ, а также приведем небольшое собеседование по тематике рекурсия. Итак, давайте начнем. Для новичков в программировании тематика рекурсии, рекурсивные алгоритмы обычно дается сложно. Поэтому перед тем, как говорить о рекурсии в контексте языка программирования, давайте рассмотрим это понятие в более широком смысле и приведем реальные примеры из жизни. Под рекурсией в широком смысле мы понимаем описание объекта или процесса, который находится в этом же самом объекте или же процессе. То есть объект является частью самого себя. Наиболее широкое применение рекурсия имеет в математике и информатике. Но мы с вами начнем знакомство с рекурсией на более простых примерах, чтобы уловить ее основные идеи. Первый пример, который мы рассмотрим, это техника изображения рекурсии. Суть ее в том, что внутри изображения размещается его уменьшенная копия, как вы можете видеть на картинке справа. Внутри этой уменьшенной копии копия предыдущего изображения и так далее теоретически до бесконечности. На практике же до пределов допустимого качества изображения. То есть пока его можно разглядеть на картинке. Второй пример рекурсии, с которым, я думаю, каждый из вас сталкивался, это набор матрешек. Обратите внимание, что здесь выполняется определение рекурсии. Описание объекта, например, одна из матрешек, который находится в этом же объекте, в некоторой более крупной матрешке. Отмечу, что эта рекурсия не бесконечна, поскольку какую бы большую матрешку мы изначально не взяли, допустим, вот которая здесь в правой части экрана, мы дойдем до таких размеров, меньше которых изготовить фигууры уже физически будет невозможно. Третий пример похож на первый. Здесь также применяется техника размещения уменьшенной копии изображения в нем же самом. В этом примере рекурсия также будет ограничена возможностью изобразить мелкие детали рисунка. Подобное изображение можно увидеть при работе за компьютером. Здесь изображено окно программы для удаленного управления с включенной демонстрацией рабочего стола. Если расшарить экран на обоих компьютерах, на управляющем и на управляемом, то можно увидеть подобную картинку. В данном примере, друзья, изображение рабочего стола будет уменьшаться, пока не достигнет размеров буквально в 1 пиксель. И в заключение этой рубрики давайте рассмотрим пример, который показывает принцип самовоспроизведения. Здесь акцент делается не на использовании уменьшенной копии изображения, как мы делали в предыдущих примерах. Здесь же акцент делается на самовоспроизведении, а также одновременном усложнении системы. Базовой фигурой в этом рисунке является пара соединенных линий, которые образуют одну ветку. Ветки большего размера строятся из базовой фигуры. Простая ветка самовоспроизводится и одновременно фигура усложняется, то есть веток становится больше. То есть вторая фигура построена, как вы можете видеть, из трех базовых веток. Первая ветка, вторая и третья в самом низу. Третья фигура уже состоит из семи веток и четвертая заключает в себе 15 веток. По мере добавления в рисунок новых веток они уменьшаются в размерах, чтобы соблюдать пропорции дерева. Обратите внимание, что на второй фигуре можно видеть два уровня веток, на третьей – три и на четвертой – четыре уровня веток. Вопрос для любителей математики. А как вы думаете, есть ли какая-то закономерность между количеством уровней и числом веток в дереве? Свои предположения можете написать в чат. Итак, друзья, после экскурса в рекурсию в широком смысле, давайте поговорим о ней в контексте программирования. Дадим более точное определение, рассмотрим, с каких частей она состоит и, самое главное, попытаемся понять, а как же она работает. Для того, чтобы определить рекурсию в программировании, мы задействуем знакомый нам термин функции. Итак, под рекурсией мы будем понимать некоторый процесс, в котором функция вызывает саму себя. Такую функцию мы будем называть рекурсивной, а подобный вызов называется рекурсивным вызовом. Чтобы было понимание, как это выглядит на практике, давайте рассмотрим фрагмент кода, который имитирует открытие матрешки. На экране представлена функция, которая уведомляет, что открывает матрешку и выводит на экран ее размер. Затем можно видеть вызов этой же функции openMatryoshka и как раз таки этот вызов, друзья, и называется рекурсивным. А сама функция openMatрешка называется рекурсивной функцией. Процесс работы такой функции мы называем рекурсией. Чтобы все это дело запустить, нам необходимо один раз вызвать функцию open матрешка и передать ей некоторое значение. Параметр функции говорит о суммарном количестве матрешек. Друзья, с точки зрения логики этот пример содержит ошибки, которые мы исправим далее. Цель этого примера показать основные компоненты рекурсии, которые мы ввели ранее. Следующим этапом давайте рассмотрим их более детально. Первый элемент это рекурсивный вызов. Давайте отметим себе, что целью рекурсивного вызова является решение более простой задачи или же более меньшей, чем текущая. Здесь я попытался изобразить набор вызовов, где на каждом этапе решается более простая задача, чем текущая. Под более простой задачей понимается задача с меньшим объемом вычислений. В данной схеме последним вызовом будет выполняться задача, которая является тривиальной. И упрощать ее уже некуда. Отметьте себе, что такая задача называется базовым случаем. Если говорить про пример с матрешками, то базовый случай это самая вложенная или самая маленькая матрешка. Вы можете задаться вопросом, а как сделать задачу более простой? Как ее уменьшить? Ведь функция, в которой производится вычисление, никаким образом не меняется. Набор инструкций, из которых состоит тело функции, остается неизменным. Друзья, здесь все дело в параметрах функции. Именно за счет них мы можем влиять на ее поведение. В самом простом случае мы можем уменьшить величину параметров. Если это размер матрешки, как в приведенном примере, то можно просто уменьшить его на 1. Тем самым мы упростим решаемую задачу и приблизим ее к базовому случаю. Вот эта вот функция function может открывать матрешку, может выводить на экран какие-то данные, а может произвести вычисления. Для нас главное, что за счет изменения параметра мы делаем задачу каждый раз проще. Приводим ее к базовому случаю. Вернемся к примеру. Основное действие функции это имитация открытия матрешки с выводом ее размера. Далее мы видим рекурсивный вызов – один из основных компонентов рекурсии. Но обратите внимание, что вызов осуществляется с тем же значением параметра size. То есть он никак не меняется. Здесь не выполняется требование, что рекурсивный вызов должен приводить к решению более простой задачи. Давайте подумаем, как можно его оформить, чтобы он приблизил нас к базовому случаю. Чтобы этого достичь, можно сделать рекурсивный вызов со значением параметра, допустим, на единицу меньше. Тем самым мы будем приближаться к базовому случаю можно считать это открытие матрешки размером 1 открытие матрешки единичного размера будем считать тривиальной задачи после выполнения которой нужно остановиться запустим рекурсию для этого вызовем функцию с некоторым значением допустустим равным 5. На экране мы видим процесс открытия матрешек размером от 5 до 1. Однако после открытия матрешки с размером 1, как можно видеть, процедура продолжается. Размеры матрешек уже стали отрицательными. Возникает вопрос, остановится ли когда-нибудь этот процесс. Ответ – нет, не остановится, поскольку он работает как бесконечный цикл. Каких-либо условий для остановки рекурсии в коде мы с вами не писали. Друзья, мы подошли ко второй составляющей рекурсии. Это условия для ее остановки. Если этого не делать, то рекурсивные вызовы будут выполняться бесконечно, что в итоге приведет к зацикливанию или же ошибке во время выполнения. Рекурсию останавливают, когда на очередном вызове становится понятно, что задача стала простейшей. То есть мы подошли к базовому случаю. Обычно на это указывает значение параметра. В этом случае рекурсийный вызов не делается и функцию завершают инструкции return. При необходимости возвращают значение. Вернемся к нашему примеру и посмотрим, а как можно остановить рекурсию в нужный момент. Для этого нужно понять, а каким должно быть значение параметра size, чтобы считать эту задачу тривиальной, или же простейшей, или другими словами базовым случаем. Как мы сказали ранее, эта функция открывает матрешки до единичного размера. Следовательно, открытие матрешки размером 1 мы можем считать базовым случаем. Добавим условие, которое проверит равенство параметра единиц. Если это так, то завершим выполнение функции без рекурсивного вызова. Воспользуемся инструкцией return. Также для информативности добавим соответствующее сообщение о том, что мы достигли самой маленькой матрешки. Посмотрим, каким будет результат работы программы. В окне вывода мы видим последовательность открытия матрешек с размерами от 5 и до единичного размера. На этом рекурсивные вызовы останавливаются и мы видим соответствующее уведомление. Друзья, мы с вами рассмотрели достаточно простой вариант применения рекурсии. Когда функция сначала делает некоторую работу и в конце вызывает себя рекурсивным. Однако, если функция будет вначале иметь рекурсивный вызов, а затем выполнение работы, то ее поведение будет несколько отличаться. Вернемся к нашему примеру. В нем рекурсивный вызов происходит после выполнения основных действий, после вывода на экран информации об открытии очередной матрешки. Давайте немного перепишем функцию так, чтобы сначала шел рекурсивный вызов, а затем выполнялась основная работа. Теперь вывод сообщения на экран находится в конце функции. Вначале мы видим рекурсивный вызов, также с проверкой условий на базовый случай. Посмотрим на результат работы этой функции и сравним его с предыдущим выводом. В консоли мы видим все тот же набор сообщений об открытии матрешек, но в этом случае размеры идут по возрастанию от двойки и до суммарного количества матрешек. Функция у нас вызывается все с тем же аргументом равным 5, однако размеры идут в обратном порядке. Попробуем разобраться, как работает рекурсия в этом случае. Изобразим схематически, что будет происходить при вызове функции с аргументом равным 4. На схеме изображены 4 вызова функции open матрешка. Первый вызов – это первоначальный вызов функции с аргументом равным четырем. Второй вызов, как вы можете видеть, это уже рекурсивный с аргументом на единицу меньше, чем предыдущий, то есть с тройкой. Этот вызов, обратите внимание, происходит вот здесь на 8 строке кода. Он рекурсивный. На строку номер 5 до 6 мы не попадем, поскольку базовый случай размер матрешки единицы еще не достигнут. Также мы с вами не попадем и на 9 строчку, поскольку при рекурсивном вызове на 8 строчке мы снова попадем в начало функции. Третий вызов является рекурсивным, но уже с параметром 2 на единицу меньше, чем предыдущий. Ну и четвертый вызов все так же рекурсивный, его аргумент равен единице. Вызов функции с аргументом 1 приведет к следующему. Мы попадаем в тело условного оператора if. На экран выводится соответствующее сообщение о том, что достигнута самая маленькая матрешка и выполняется инструкция return на шестой строке кода. Друзья, это как раз-таки тот момент, когда череда рекурсивных вызовов останавливается. Но что будет происходить дальше? Предлагаю подумать над этим вопросом пару минут самостоятельно, а затем мы обсудим ваши догадки. you you you you На этом моменте начинается самое интересное. Предлагаю собраться с силами и внимательно проследить за следующими этапами. Мы достигли инструкции Return, на которой череда вызовов останавливается. То есть мы находимся вот здесь, сразу же после вывода сообщения. После выполнения Return мы должны вернуться в то место, откуда нас вызвали. А это, друзья, как раз-таки предыдущий шаг с номером 4, на котором отмечен вызов функции с аргументом равным единице. Мы окажемся сразу после вот этой инструкции вызова. То есть после нее давайте посмотрим, что идет. Вывод на экран. Консоль в WriteLine. Для ясности покажу суть этого возврата на простом примере. Здесь функция выводит на экран некоторое сообщение и сразу же завершается. Давайте перейдем к моменту ее вызова. Шестая строка. Вызов функцию ShowMessage. Возникает вопрос. Куда мы попадем после ее завершения? Конечно же, мы попадаем сразу же на следующую строку после вызова функции. То есть это строка номер 7, где у нас располагается некоторый вывод на экран. То же самое произойдет и при рекурсивном вызове. После вызова функции openMatryoshka находится вывод на экран. Вот здесь строка номер 9. Она и будет выполнена с аргументом, который в данный момент равен 2. То есть вот эта строчка 9 будет выполнена. На схеме она отмечена вот здесь. Обращаю внимание, друзья, size переменная равна 2. Это мы увидим на экране в консоли. Вот здесь вот в левой части экрана. Далее инструкция у нас заканчивается и функция завершается. То есть после 9 строки кода функция у нас прекращает свою работу. Но не забываем, что эта функция была вызвана ранее, на шаге номер 3. Вот здесь. И мы точно таким же образом вернемся туда вместо ее вызова вот по этой стрелке несмотря на то что здесь явно не прописан оператор return после девятой строчки он будет выполнен неявно и произойдет возврат после вызова функции open матрешка с аргументом 2 идет инструкция вывода на консоль на На схеме она изображена здесь. Она выведет переменную size, значение которой равно 3. Мы это увидим на экране. На этом инструкции функции закончатся. И мы таким же образом отправимся на место предыдущего вызова. Здесь выполняются те же действия, что и ранее. На экране мы с вами увидим об открытии матрешки с размером 4. После этого мы вернемся на место первоначального вызова функции. То есть вот по этой стрелке мы возвращаемся на первоначальный вызов. И на этом, друзья, рекурсия завершится. Друзья, для понимания давайте отметим себе несколько важных моментов, которые происходят при рекурсе. Во-первых, процесс возврата, который мы видели на схеме к местам вызовов, называется раскручиванием рекурсии. Во-вторых, в процессе раскручивания рекурсии мы как бы возвращаемся во времени назад к местам вызова функции. Отметьте себе, что места вызовов сохраняются в памяти, чтобы потом можно было к ним вернуться. То есть в памяти будет сохранен вызов первый, второй, третий. И потом в эти сохраненные места мы будем уже делать возврат. То есть места вызова функции с аргументами 4, 3, 2, 1 будут сохранены в памяти. И затем начнется раскручивание рекурсии. То есть проход по вот этим стрелочкам, которые у нас изображены на схеме. В-третьих, помимо места, куда нужно вернуться, это у нас строка номер 8, при раскручивании, в памяти сохраняются значения параметров, с которыми была вызвана функция. То есть 4, 3, 2, 1. Делается для того, чтобы при выводе на консоль строка номер 9 выводилось корректное значение матрешки. То есть размер 2, 3, 4. Если это не сохранять, то размер у нас будет всегда один и тот же. Давайте отметим себе, что область памяти, куда сохраняется вся эта информация, называется стэком. Резюмируем сказанное и отметим основные особенности. Под раскручиванием рекурсии мы понимаем возвраты к местам вызова функций. При вызове функции в памяти сохраняются место возврата, то есть куда нам возвращаться при раскручивании, а также значение параметров при вызове. И эта область памяти называется стэк. Мы с вами рассмотрели механизм работы рекурсии на примере открытия набора матрешек на некоторой вложности. Но обратили ли вы внимание на некоторую странность, которая происходит при открытии? Если рекурсивный вызов располагается до основной работы, то матрешки у нас как бы открываются изнутри. То есть от самой маленькой до самой большой. Посмотрим еще раз на вывод. Видно, что открытие происходит от самой маленькой к самой большой матрешке Что в действительности практически нереализуемо И в целом звучит странно Мы привыкли, что матрешка открывается в обратном порядке То есть сначала самая большая и до самой вложенной Друзья, здесь дело в том, что расположение рекурсивного вызова влияет на последовательность действий в алгоритме. Некоторые алгоритмы могут корректно работать с расположением рекурсивного вызова как до, так и после основной работы. А некоторые алгоритмы, в частности, как наш пример, могут от этого пострадать. Поэтому рекомендую внимательно относиться к месту размещения рекурсивного вызова. Он будет влиять, от него будет зависеть последовательность операций в алгоритме. И отметьте себе важный момент, что раскручивание рекурсии будет происходить независимо от того, где расположен рекурсивный вызов. Будь то он расположен после основной работы, как в примере слева, или же он находится до запуска основных действий. Сам принцип работы рекурсии от этого не изменится. Друзья, задача с открытием матрешек вполне неплохой пример для демонстрации работы рекурсии. Как в случае нормального поведения, то есть открытия от больше и к меньше, так и в случае открытия матрешек как бы изнутри. Но хотелось бы выяснить, в каких задачах рекурсия реально полезна и упрощает их решение. Давайте рассмотрим несколько примеров рекурсии, где ее применение действительно себя оправдывает. На экране представлен пример структуры данных, которая носит название дерево. Дерево – это один из способов хранения и упорядочивания данных, наряду с массивом. Деревья используются для хранения данных в иерархическом порядке, для поисковых задач и для сортировок. Рекурсия здесь применяется для наиболее компактной и понятной реализации обхода его элементов. Под обходом мы понимаем обеспечение доступа или же проход по всем элементам дерева. Похожую задачу мы с вами решали с массивами. Если же использовать итеративную версию обхода такой структуры данных, то она будет значительно больше по объему кода. И, кроме того, потребует использования дополнительных структур данных, таких как стэк или очередь. Второй пример – это алгоритм быстрой сортировки, также его называют Quick Sort. Является одним из самых быстрых алгоритмов. Превосходит по скорости пузырьковую сортировку, сортировку выбором, вставками и многие другие. Рекурсия здесь является одним из основных компонентов. Именно за счет нее и достигается высокая скорость работы. Ну и третий пример это обход каталогов файловой системы. Здесь рекурсивные алгоритмы используются для поисков файлов, папок, а также для формирования листингов содержимого. Язык C-S C Sharp и платформа.NET представляют достаточно удобные методы получения списка файлов. Однако, если нам потребуется получить список файлов на всю глубину каталогов, то есть на всю глубину каталогов урок 1, урок 2 или вложенных, то рекурсия здесь будет как нельзя кстати. Она позволит организовать этот алгоритм просто и компактно. Предлагаю немного попартиковаться и решить классическую задачу на вычисление факториала с использованием рекурсии. Для начала давайте разберемся, что такое факториал числа. Факториалом натурального числа n называется произведение чисел от 1 и до самого числа n включительно. Чтобы вычислить факториал числа 5, необходимо единицу умножить на следующее число, то есть на 2. Полученный результат необходимо умножить на следующее число, после двойки, то есть на число 3. И так далее, пока мы не дойдем до самого числа. Для обозначения этой операции мы используем восклицательный знак. Отметим, что эта функция,ториал растет крайне быстро. О чем речь? При небольшом увеличении числа n, то есть то число, от которого считается факториал, значение факториала увеличивается весьма существенно. То есть факториал от 3 равен 6, от 5 он будет равен 120, но при увеличении до 10 мы уже получаем число порядка 3 миллионов. Факториал от 1 у нас равен 1, и факториал 0 равен также 1 по определению. Такое значение примето математиками. Перед тем, как начать писать код, а на первых порах может быть вообще непонятно с чего начать, как подступиться к написанию, предлагаю рассмотреть основные компоненты рекурсии для этой задачи. Первый элемент это рекурсивный вызов. Напомню, он нужен для того, чтобы решить более простую задачу и приблизиться к тривиальному случаю. Самый очевидный решить более простую задачу и приблизиться к тривиальному случаю. Самый очевидный способ получить более простую задачу, если мы говорим про факториал, то это вычислить его от меньшего числа, чем исходное. То есть, например, уменьшить его на единицу. Тем самым задача будет упрощена. Следующее, над чем нам нужно подумать, это как использовать решение более простой задачи в рекурсивном вызове. Отмечу, что эта задача может быть непростой. Представим формулу факториала несколько иначе. А именно, переставим сомножители наоборот. То есть от большего до числу к наименьшему. Ну и помним, что перестановка сомножителей на результат не влияет, как и при сложении. А теперь давайте внимательно посмотрим на формулу и подумаем, можно ли в ней выделить наиболее простую задачу. То есть можно ли в этой формуле использовать формулу, которую мы написали ранее. n-1 факториал. Заметьте, что последние n-1 сомножители, то есть начиная от n-1, n-1 факториал. Заметьте, что последние n-1 со множителей, то есть начиная от n-1, n-2 и так далее до единицы, как раз таки составляют формулу для решения более простой задачи. Итоговая формула примет следующий вид. В нее войдет решение более простой задачи, которое мы вывели ранее. И важный момент. В этой формуле также используется функция факториал. То есть формула задается рекурсивно. А это как раз-таки то, что нам нужно. Второй компонент – это условия остановки рекурсии. Напомню, рекурсивные вызовы нужно остановить, как только решаемая задача станет тривиальной. Или же мы подойдем к базовому случаю. Давайте посмотрим, например, вычисление факториала от числа 3 с применением рекурсии. Итак, более простая задача в этом примере это факториал от 2. В итоге мы имеем формулу как 3 умножить на факториал 2. Теперь рассмотрим задачу факториал от числа 2. Как можно ее представить с применением рекурсии? 2 факториал представляется как 2 умножить на факториал от единицы. Как раз таки факториал от числа 1 и будет тривиальная задача. Это является базовым случаем, который решать дальше с применением рекурсии уже нет смысла. По определению, помните, 1 факториал равен единице. На этом, друзья, с основными компонентами, которые составляют рекурсию, все. Предлагаю оформить решение на C-Sharp. Работаем мы сегодня в каталоге урок 5. Создадим проект под каталоги с первым заданием. Итак, перейдем в файл с исходным кодом. Функция будет возвращать целое число, значение факториал. Поэтому сразу укажем тип возвращаемого значения как int. Далее дадим название функции, допустим, факт. И укажем ее параметр, который будет также целым числом. Именно от него и будем вычислять значение факториала. Далее давайте оформим рекурсивный вызов. Вернем в качестве значения функции, согласно сформированной нами формуле, n умножить на факториал от n-1. Ну а, друзья, конечно же, помним, что C-sharp в таком виде формулу факториала, конечно же, не приемлем. Для него восклицательный знак является несколько другой операцией. Поэтому напишем корректно и укажем именно функцию факт. То есть мы вычислим факториал от параметра, уменьшенного на единицу. Попробуем запустить этот код, не используя условия для остановки рекурсии. То есть укажем имя функции факт и допустим передадим ей какой-нибудь параметр, пускай будет 5. Сохраним изменения и стартанем код. Что мы видим на экране? Давайте посмотрим. Нам среда выполнения написала сообщение stack overflow. Это, друзья, значит, что область памяти, которая именуется стэком, помните, мы про него говорили, переполнилась, поскольку мы никаким образом с вами рекурсию не остановили. Условий мы для остановки не использовали. Вопрос на засыпку. А как вы думаете, какими данными заполнился стэк в нашей задаче? Подскажу. Эти данные мы обсуждали, когда разбирали работу рекурсии на примере с матрешками. Предлагаю в течение минуты подумать над этим вопросом и свои предложения написать в чат. you Да, вы были совершенно правы, если вспомнили про место возврата функции, а также значение параметров при рекурсивном вызове. В стэк помещаются именно эти данные. Если запустить бесконечную рекурсию, то стэк достаточно быстро переполнится. В принципе, что мы увидели на экране. Итак, добавим условия для остановки рекурсии. Напомню, это случай, когда текущая задача стала тривиальной или мы приблизились к базовому случаю. Но как в этой функции нам понять, что текущая задача тривиальна? Как мы говорили ранее, в большинстве случаев на это указывает параметр функции. Давайте проверим этот параметр на равенство единицы, поскольку при формировании этапов с основных частей рекурсии мы это отметили. Если параметр будет равен единице, мы рекурсию остановим и вернем единицу, поскольку по определению факториал единицы равен единице. В остальные уже случаи, если у нас условие n равно единице не выполняется, будет производиться рекурсивный вызов. Запустим код еще раз. Предлагаю добавить вывод полученного значения на экран, чтобы можно было проверить правильность работы. Сохраним изменения и запустим еще раз. Ну и также, конечно, не забываем о форматировании кода. Либо контекстное меню Format Document, либо сочетание клавиш Shift Alt F. Итак, давайте посмотрим. На экране мы видим 120, что говорит о правильной работе рекурсии. Также можно проверить, правильно ли работает рекурсия при нуле. Давайте посмотрим. При нуле у нас должна рекурсия завершаться единицей, то есть возвращаться значение единицы. Но мы видим стэк слова переполняется, поскольку у нас это условие не отработало. Предлагаю это требование учесть, эту особенность, и в проверке просто добавить. Если у нас параметр равен единице или, подскажу, друзья, такой оператор или, который служит для объединения условий. Параметр равен 0, то тогда вернуть единицу. Сохраним и попробуем запустить еще раз. Да, действительно, теперь у нас факториал 0 равен 1. Друзья, отмечу, что использование рекурсии для вычисления факториала на практике не используется. Рекурсивные способы решения подобных задач мы используем исключительно для демонстрации и изучения работы рекурсии. Факториал имеет более простое решение с применением цикла. В данном случае демонстрируется цикл for. Напомню, for мы используем, когда количество итераций у нас заранее известно. Кроме того, итеративное решение не опасно переполнением стека, которое может возникать при рекурсивных вызовах. В качестве альтернативы рекурсии здесь создается цикл на n-1 итерации, то есть от 2 и до n включительным, где происходит умножение переменной result на очередное число от 2 до n. И после окончания работы цикла результат возвращается на место вызова. Мы познакомились с рекурсией в контексте языка C-sharp. Предлагаю посмотреть, как она будет выглядеть в других языках. Посмотреть, в чем будет отличие, а какие моменты будут схожи. Рассмотрим рекурсивную функцию для открытия матрешки. В языке C++ отличия минимальны. И они находятся на строке с выводом сообщения. Здесь используется конструкция std cout, которая свойственна именно языку C++. C-sharp представитель C-подобных языков. Он также имеет статическую типизацию и схожий синтаксис. В JavaScript отличий несколько больше. Во-первых, это также вывод сообщения. Используется конструкция console.log. Во-вторых, динамическая типизация. Обратите внимание, что типы возвращаемого значения у функции, а также тип параметра не указываются. Вместо этого мы видим ключевое слово function, что говорит интерпретатору JavaScript о том, что создается функция. Кстати, вопрос на засыпку. Все ли помнят, что такое интерпретатор и компилятор? Ну и третий пример – это Python. Здесь уже видны существенные отличия в синтезе и оформлении блоков. Фигурных скобок здесь уже не используется. В отсутствии указания типа данных возвращаемое значение функции, тип данных у параметра а также при выводе на экран здесь используется функция print с отличиями все понятно давайте посмотрим на общие части во всех этих трех примеров не трудно видеть что все составные части рекурсии в том или ином виде да присутствуют во всех трех примерах будь то компилируемые в языке C++, будь то интерпретируемые в JavaScript и Python. Что мы имеем? Основную работу – это вывод, сообщение об открытии матрешки, проверка условия, не достигли ли мы базового случая, также присутствует во всех трех языках. Ну и, конечно же, рекурсивный вызов, если размер матрешки позволяет ее открывать. Друзья, отвлечемся от рекурсии и поговорим о такой тематике, как отладка. Посмотрим, что она из себя представляет, какие разновидности имеются, а также попробуем применить несколько методик отладки на наших задачах. Под отладкой мы понимаем процесс поиска и исправление ошибок в коде. То есть отладку мы можем использовать, если у нас есть подозрение, что в коде есть ошибки или, другими словами, баги. Кроме того, отладка может быть применена, если не совсем понятно или же совсем непонятно, как работает программа. Отладку можно проводить путем вывода интересующей информации на консоль. Или, например, в файл. Также можно пользоваться специальными инструментами среды разработчиков. Давайте рассмотрим каждый из этих способов подробнее. Итак, первый способ – это вывод информации о ходе работы программы на консоль. Или, допустим, в файл. Возникает вопрос, а какая информация может быть выведена? Можно выводить значение переменных, значение параметров функции, а также просто сообщение о том, что выполняется та или иная строка кода. Последний способ при выводе сообщений позволяет понять попали ли мы в конкретный участок кода или нет. Давайте попробуем применить этот способ отладки на нашей задаче. Вернемся к задаче с факториалом и давайте закомментируем участок, который отвечает за остановку рекурсии. Напомню, что при запуске функции без остановки рекурсии мы получим ошибку переполнения стек. Давайте еще раз на всякий случай проверим. Допустим, да, факториал от 5. Видим, да, что происходит ошибка. После выполнения функции, то есть попытки запуске порядка 24 тысяч раз стек переполнился. Чтобы посмотреть, что происходит при работе этой функции, давайте добавим отталочный вывод на консоль. Выведем значение параметра в начале функции. Допустим, вот здесь напишем консол.writeLine. Ну и, соответственно, сам параметр. Он равен у нас n. Сохраним изменения и запустим код еще раз. Видно, как на экран вводится значение параметра, и каждый раз он уменьшается. Обратите внимание, что параметр при выводе, который мы видели ранее, не остановился на значении 0 или 1. Он уменьшался до тех пор, пока у нас не произошла ошибка, сообщение которой мы, в принципе, видим на экране. Как раз для этого мы с вами используем остановку рекурсии, чтобы избежать бесконечного числа вызовов. Еще раз, чтобы проследить, запустим код. И я остановлю нажатием клавиш Ctrl-C. То есть мы видим, что количество вызовов уже ушло за 6000 и продолжает расти. Вернем остановку рекурсии и давайте запустим код еще раз. Раскомментируем этот фрагмент, сохраним и запустим. На экране видим последовательность значений параметров от 5 до 2. При значении параметра равном единице, согласно коду, в принципе, мы это видим при выводе, рекурсия завершается. И мы видим ответ, который мы пишем на строке номер 11, это 120. Чтобы понять, да, именно что мы попали вот сюда, в условие if, да, в ветку до условия if, давайте здесь добавим также отладочный вывод на экран. Ну, допустим, напишем следующее, что рекурсия остановилась. Стоп. И укажем значение параметра. И не забываем указать, что это не просто строка, а строка с форматированием. Или же более правильный термин – интерполяция строки. Сохраним наработки. Запустим еще раз. В конце мы видим попадание в ветку условной конструкции if. И, соответственно, после этого видим ответ. А теперь вопрос, друзья. А как проследить за процессом раскручивания рекурсий? Сейчас мы с вами пронаблюдали процесс вызовов. Но когда начинается череда возвратов после рекурсивных вызовов, этот момент также хотелось бы увидеть на экране. Предлагаю подумать над этим моментом самостоятельно и оставляю его в качестве домашнего задания. То есть необходимо добавить в код некоторый отладочный вывод на правильные места, который позволит увидеть, как раскручивается рекурсия, то есть как формируется значение факториала. Сначала равно единице, затем двойки, тройки, шестерки и так далее. То есть постепенно эти умножения. Или же другими словами процесс возвратов к местам вызовов. Вывод на экран может иметь следующий вид, когда вы уже примените отладочный вывод. Желательно увидеть значение параметра функции при раскручивании рекурсии. То есть параметр вот он 2, 3, 4, 5. А также вычисленное значение факториала на каждом шаге. Как можно видеть из примера, факториал считается постепенным. На каждом возврате к месту вызова он у нас увеличивается. От 1 и так далее до 120. Дам небольшую подсказку. Скорее всего, вычисление факториала на строке 9 можно разделить на составные части. То есть вот здесь, когда мы возвращаем ответ. Это позволит встроить отладочный вывод на нужную позицию. Двигаемся далее и рассмотрим более продвинутый способ отладки. Отладки – это использование специального инструмента или же отладчика. Отметим себе, что отладчик – это программа, которая позволяет запустить программу в особом режиме, который так и называется режим отладки. Обычно этот инструмент встроен в среду разработки, но может устанавливаться и отдельно. В редакторе VS Code нам понадобится расширение C-Sharp Development Kit, чтобы воспользоваться отладчиком. Отладчик позволяет запускать код построчно, вручную переходя от инструкции к инструкции. Мы можем вручную выполнять первую строку, затем вторую, третью, четвертую и так далее, пока не дойдем до конца программы. С его помощью можно выполнять циклы, контролируя каждую итерацию. Первая итерация, вторая, третья. То есть выполнение тела цикла. Мы можем приостановить программу во время ее выполнения на указанной строке. Это указано в примере на шестой строчке. То есть отладчик здесь приостановил выполнение кода и ожидает команды от программиста. В ходе работы также можно просматривать значения переменных и массивов. Для этого используются отдельные окна, отображение которых можно включать в настройках. Здесь мы наблюдаем переменную n, ее значение наравно 5, переменную i, у нее нулевое значение, ну и здесь я немного подскажу, это массив с аргументами программы. В данном случае он у нас нулевой. Мы аргументы на вход программы никакие не передаем. Давайте вернемся к задаче с факториалом и попробуем запустить программу в режиме отладки. Для запуска отладчика нам потребуется установить расширение C-Sharp DevKit. Давайте посмотрим, как он выглядит. У меня он уже установлен. Это официальное расширение от Microsoft, которое и содержит в себе инструменты отладки. Итак, перейдем в код. После установки отладчика в правом верхнем углу становится доступна кнопка для его запуска. Итак, давайте нажмем «Стартануть отладку» проекта, который ассоциирован с этим файлом исходного кода. Итак, мы видим, что отладчик стартует. Сообщения желтым цветом говорят о инициализации запуске отладчика. Мы видим, что программа отработала. Видим полностью вывод на экран с ее сообщениями. Однако выполнение программы не остановилось. Она полностью отработала и завершилась. Дело в том, что мы не указали отладчику, а на какой строчке ему нужно остановить выполнение. То есть, допустим, на 5, на 7, на 10 и так далее. Возможно, некоторые из вас замечали, что слева от номеров строк можно ставить красные точки. Так вот, друзья, это и есть точки остановки программы, которую использует отладчик. То есть, когда отладчик запускается, он обращает внимание на эти точки и как бы приостанавливает работу программы в тех местах, где вы ему указали. Попадая на строчку, допустим, на эту с красной точкой, выполнение приостанавливается, и отладчик будет ожидать команды от программиста. Итак, давайте поставим точку останова на строке номер 10, там где выводится очередное значение параметра. И таким же образом запустим отладку. Итак, отладчик запускается, мы видим, что запустилась функция и выполнился код до поставленной точки. Строка, которая подсвечена желтым, где здесь есть желтый индикатор, еще не выполнилась. Отладчик в данный момент ожидает от нас команду. Обратите внимание на панель управления отладкой в верхней части экрана. Нам здесь наиболее интересны кнопки. Продолжить от английского continue, клавиши F5. Сделать шаг с обходом, клавиши F10, step over. Сделать шаг с заходом, клавиши F11. А также остановить отладку, shift F5. Давайте отметим себе, можно даже в комментариях, что кнопка шаг с заходом, то есть F11, выполняет инструкцию, на которой находится курсор и переходит к следующей. Соответственно, напишем себе шаг с заходом. Откуда такое название? Шаг с заходом. Дело в том, что если на пути отладчика встречается функция, то отладчик зайдет в тело этой функции и будет уже идти по ней. Кнопка шаг с обходом также выполняет инструкцию, на которой находится курсор и переходит к следующей. Давайте себе это отметим. F10 это у нас шаг с обходом. С обходом тоже имеет свой смысл выражение. Это значит, что если на пути отладчика встречается вызов функции, допустим, факт, то отладчик в эту функцию заходить не будет, а перейдет сразу к следующей инструкции. То есть, допустим, если бы здесь была бы какая-то инструкция сразу же после вызова функции факт, то он перешел бы к этой инструкции. Давайте нажмем F10 и перейдем к следующей инструкции. Видно, как выполнение перешло на следующую строку. Индикатор загорелся на 11 строке. И давайте посмотрим на консоль. Здесь появился вывод параметра функции 5. То есть отработала функция вывода параметра на экран. Текущая строка номер 11 содержит вызов функции. Факториал от n-1. Давайте нажмем клавишу F11, чтобы отладчик зашел в эту функцию. Мы снова оказались в функции факториал, поскольку вызов был рекурсивным. Нажатием клавиши F10 можно выполнить инструкции далее, вплоть до рекурсивного вызова. Давайте это проверим. Нажимаем F10, выполняем проверку условной конструкции. Внутрь условия мы не попадаем и отправляемся на строчку номер 10. Нажимаем F10 еще раз и видите на консоли появляется значение параметра уже 4, на единицу меньше чем предыдущие. Отметим себе, что клавиша F5 может использоваться для команды продолженная. Это значит, чтобы перейти к выполнению инструкции, на которой установлена точка останова. То есть мы перейдем вот на эту инструкцию при нажатии клавиши F5. Давайте нажмем клавишу F5 и мы снова попадаем на десятую строку. То есть мы зашли в функцию factorial, сделали проверку в условной конструкции и снова оказались на точке остановы, которая была поставлена. Таким образом мы можем несколько раз нажать клавишу F5 и поочередно увидеть параметры при рекурсивных вызовах. При некотором нажатии начнется раскручивание рекурсии, которая завершит в целом алгоритм. Также отмечу, что точки останова могут добавляться во время работы отладчика. Можно поставить точку в начале функции и запустить отладку. Давайте попробуем это сделать. Итак, поставим точку в самом начале функции, запустим отладку. Мы оказались на первой строке функции факт и прямо в режиме отладки можно добавить точку на произвольную строку, допустим на 11. Для того чтобы переместиться сразу на 11 строчку кода, то есть выполнить все что было до, мы нажимаем клавишу F5, то есть продолжить. Это значит у нас до следующей точки. у нас до следующей точки. Нажимаем F5 и оказываемся на строке 11, там где стоит точка. На консоли мы также видим отладочный вывод. Отладчик останавливается в ожидании следующей команды. Таким образом, нажимая клавишу F5, мы перемещаемся между двумя этими точками останова, тем самым постепенно выполняя алгоритм. Друзья, при отладке вы, наверное, обратили внимание на окно слева. Оно содержит имена переменных и значения их в определенный момент отладки. Обратите внимание, что при продвижении по алгоритму, я нажимаю клавишу F5, значение переменная n уменьшается от 5 до и стремится к 1. После чего выполнение будет завершено. Как мы говорили ранее, это достаточно удобный инструмент отлаживания циклов, когда нужно следить за значениями счетчиков и другими переменными. Итак, друзья, давайте резюмируем основные моменты по отладке. Основное назначение отладки – это поиск ошибок в коде. Основное назначение отладки – это поиск ошибок в коде. Также отладку можно использовать, если не совсем понятно, как программа работает. Самый простой способ отладки – это отладочная печать. То есть вывод информации в определенных местах кода. Мы можем выводить значения переменных, элементы массива или какие-либо сообщения. Отладочная печать позволяет нам понять, допустим, запустилась функция или нет, на какой строчке произошла ошибка, а также запускается ли программа вообще. Более продвинутый способ отладки – это использование специального инструмента, который называется отладчик. Отладчик позволяет нам запустить программу построечно и отслеживая значение переменных, как мы это делали ранее, на каждом участке. Однако стоит заметить, что использование отладчика не всегда возможно. Связано это с тем, что программа может запускаться каким-либо нестандартным образом или запускается в условиях, в окружении, где запуск отладчика попросту невозможен. В таких случаях я бы предложил использовать отладочный вывод в файл. Запускаем программу и направляем сообщение в файл. Затем мы анализируем этот файл либо по окончании работы программы, либо же во время. Следующая тематика, которую мы рассмотрим, это принципы разработки программного обеспечения. Некоторые из них мы так или иначе использовали в наших задачах. Предлагаю их резюмировать. На экране представлены достаточно популярные принципы, которые позволяют улучшать структуру кода и бороться с его сложностью. Первый принцип говорит нам о том, чтобы не дублировать фрагменты кода, которые уже написаны. То есть от английского он переводится как «не повторяй себя» или покороче «не повторяйся». Второй принцип призывает не усложнять код без необходимости, сохраняя его простым, собственно, как здесь и написано. То есть keep it simple,раняйте простым. Максимально простым. Третий принцип. Предлагает отказаться от функциональности, которая в продукте не требуется. Расшифровывается, как вам это не потребуется. Рассмотрим принципы подробнее и приведем примеры их нарушения. Некоторые из примеров сгенерировал я, а некоторые взял из работ студентов на текущем курсе. Первый принцип рекомендует избегать дублирования одинаковых фрагментов кода. Мы с вами им неоднократно пользовались, когда разрабатывали функции. Пример. Использование функции для вывода массива на экран. Вместо того, чтобы писать цикл для вывода массива несколько раз, мы вызывали соответствующую функцию. Почему дублирование кода это пустая трата времени? Дело в том, что вам придется будет поддерживать логику программы, а также тестировать код сразу в двух местах. Причем, если код изменится в одном месте, то вам необходимо его будет править и во втором. В большинстве случаев дублирование кода происходит из-за незнания особенностей системы. То есть мы не знаем, что какие-то компоненты уже есть, а также, что они могут отсутствовать. Как здесь сказано, прежде чем что-либо писать, необходимо осмотреться и подумать. Возможно, эта функция уже реализована. Возможно, эта бизнес-логика присутствует в каком-то другом месте. Повторное использование функции – это хорошее решение данной проблемы. Одно из самых простых способов – это введение в программу функций. Рассмотрим пример. Это решение одного из студентов задачи с выводом на экран четных чисел. От одного и до некоторого введенного n. Вначале считывается число с консоли, затем запускается цикл, в котором перебираются числа от 1 до n и каждый раз проверяются на четность. Если это так, то число выводится на экран. Как вы думаете, есть ли здесь нарушение принципа do not repeat yourself? Свои предположения можете написать в чат. К этому примеру мы еще вернемся. Следующий принцип говорит о том, что не нужно усложнять решение задачи, когда можно обойтись более простым решением. Одна из распространенных ошибок – это использование новых инструментов исключительно из-за того, что они красивые и блестят. Некоторые программисты таким образом стремятся продемонстрировать знания технологии, даже если эти инструменты не совсем подходят для решения задач. Этот принцип подразумевает написание понятного кода. Если код непонятен, то он автоматически становится сложным для его сопровождения, как указано здесь, для понимания последующей модификации. Рассмотрим такой пример. Цель программы – посчитать сумму элементов массива. В ней создается массив на 5 элементов, затем переменная для хранения суммы, и в нее помещается первый элемент. Далее организуется цикл от последнего элемента до первого, в котором осуществляется суммирование. Друзья, видите ли вы в этом решении что-нибудь странное и нетиповое? Можно ли сказать, что это решение было искусственно усложнено? Предлагаю подумать над этим вопросом самостоятельно и обсудить на семинаре. Резюмируя сказанное и принцип Keep it simple, stupid в целом, приведу цитату уже знакомого вам автора Стива Макону. Он считает управление сложностью самым важным техническим аспектом в разработке программ. Более того, управление сложностью Стив Макону считает главным техническим императивом в разработке ПУ. И на протяжении всей своей книги совершенный код к этому термину обращается. Ну и третий принцип – это отказ от избыточной и ненужной функциональности. Он говорит нам о том, чтобы реализовывать только то, что нужно в данный момент. Программист не должен добавлять в функционал программы те компоненты, которые не значатся в техническом задании. Перечислим остальные идеи, которые лежат в основе этого принципа. Не стоит писать код, который может пригодиться позже. Например, пусть стоит задача вычислить среднее арифметическое от элементов массива. После реализации такой функции по вычислению среднего арифметического мы решили еще реализовать и функцию по вычислению среднего гефметического, мы решили еще реализовать и функцию по вычислению среднего геометрического. Просто так, на всякий случай. Так вот, друзья, от этой идеи лучше отказаться, если оснований для использования этой функции среднего геометрического нет. Не стоит бояться удалять лишний код. Его всегда можно восстановить из репозитория. Конечно же, если он сохранен соответствующими коммитами. Вы, должно быть, заметили, что этот принцип Ягни, который мы рассматриваем, похож на принцип Кис. Он старается делать вещи как можно проще. Но дело в том, что принцип Кис старается искать более простые решения, в то время как принцип Ягни не делает никаких решений. Вернемся к примеру с подсчетом количества четных чисел от 1 до n. Обратите внимание на код в блоках if и else. И в первом, и во втором блоке присутствует инструкция увеличения переменной на n. Она увеличивается на единицу. Также переменная i также увеличивается на единицу. Также переменная i также увеличивается на единицу. В подобных случаях повторяющийся код выносят за пределы операторов if-else. Например, размещая его сразу после них. Давайте применим принцип do not repeat yourself. После рефакторинга код примет следующий вид. Действительно, вне зависимости от того, является ли число четным или нет, нам необходимо перейти к проверке следующего числа. Для этого мы вынесли указанную операцию за блок if else. То есть вот этот блок, переходу к следующему числу, увеличивает его на единицу. Затем его проверяют. Обратите внимание, что блок else стал пустым. Разумеется, от него можно избавиться, просто удалив его. Друзья, на этом рефакторе этого фрагмента кода не заканчивается. И я предлагаю вам подумать, а как здесь применить принцип Ягнида, то есть избавиться от избыточной функциональности. Подскажу. В качестве личных фрагментов можно рассмотреть переменные. В качестве второго примера, где я бы хотел продемонстрировать нарушение принципа Ягни, это заполнение массива случайными числами. Здесь создается массив на 10 элементов. Далее в цикле for он инициализируется нулями и затем, предварительно создав объекта Random, он уже инициализируется случайными числами. Как вы думаете, есть ли в этом примере избыточная функциональность? То есть операции, от которых можно было бы избавиться. Необходимости в зануление массива здесь нет. Поскольку при его создании элементам присваивается значение по умолчанию. Если речь идет о числах, то это нули. Цикл на строчках 4-7 можно полностью удалить. На поведении программы это никак не скажется. Резюмируем рассмотренные принципы на приведенной картинке. В качестве фигур могут выступать фрагменты кода, над которыми будем применять принципы избавиться от лишней функциональности, упростить код и, соответственно, избавиться от дублирования. На первом переходе мы отказываемся от избыточной функциональности, удаляя лишние фигуры. Второй переход упрощает оставшиеся программные сущности, применяясь принцип KeepItSimpleStupid. Ну и третий переход объединяет сущности одинаковые в единое целое. Например, одинаковые фрагменты кода могут быть заменены на вызовы функций. В заключение сегодняшнего занятия давайте рассмотрим несколько типовых вопросов по рекурсии, которые вы можете услышать на собеседовании. Так же, как и на предыдущем занятии, рассмотрим теоретические вопросы, а также вопросы, касающиеся практики. Первый вопрос вероятен на собеседование джуниор-программиста. Его цель понять, может ли программист объяснить, что такое рекурсия как в широком, так и в узком смысле. Напомню, в широком смысле рекурсия – это описание объекта или процесса в рамках этого же объекта или процесса. Если речь идет о программировании, то здесь уже понимается некий процесс, в котором функцию вызывает сама себя. Второй вопрос касается основных компонентов рекурсий. Требуется их перечислить и кратко описать. Рекурсивная функция состоит из блока основной работы, рекурсивного вызова, который предназначен для решения более простой задачи, а также базового случая, который предназначен для остановки рекурсивных вызовов. В этом вопросе вас могут попросить привести пример рекурсивной функции и показать ее составляющие части. Третий вопрос проверяет, есть ли у вас понимание механизма работы рекурсии. Его основная идея – это вызов функции в самой себе для решения более простой задачи, чем текущей. С каждым новым вызовом задача становится проще. В частности, уменьшается объем вычислений. Эти вызовы называются рекурсивными и продолжаются до тех пор, пока мы не дойдем до некоторого базового случая, где рекурсивный вызов уже не требуется. После достижения базового случая начинается процесс раскручивания рекурсии. Последовательность возвратов к местам вызовов функций. Этот процесс мы подробно рассматривали на примере с матрешками. Следующий вопрос охватывает не только алгоритм работы рекурсии, но и особенности хранения данных в памяти. Вернемся к примеру с матрешками. Напомню, в процессе рекурсивных вызовов в памяти сохраняются места этих вызовов, как мы видели в коде, а также значение параметров, с которыми они вызывались, то есть от 4 до 1. Эта область памяти называется стэком. Информация о работе рекурсии, о вызовах помещается в стек по мере работы рекурсии. Сначала помещается информация о вызове с параметром 4, затем с параметром 3, 2 и последнюю очередь поместится информация о вызове с параметром 1. При раскручивании рекурсии информация о вызове будет браться именно из стека. Но, друзья, обратите внимание, обязательно в обратном порядке. То есть сначала будет браться информация о первом вызове, о втором, о третьем и о четвертом. Помните, мы с вами шли в обратном порядке по местам вызова функций. Точно так же информация извлекается тэка в обратном порядке, начиная от самого последнего вызова до самого первого. Давайте подумаем, а что произойдет, если условие для остановки рекурсии написано неправильно или же отсутствует совсем. Рекурсивные вызовы будут выполняться бесконечно, каждый раз с меньшим значением аргумента. После достижения базового случая, допустим это open матрешка с аргументом 1, вызовы продолжаются, несмотря на то, что аргумент уже уходит в отрицательные значения. Это говорит о том, что условие остановки не работает. Но самое важное, что информация о вызовах будет также помещаться в стэк. Стэк имеет фиксированный размер. Обычно он занимает порядка 1-2 мегабайт. В некоторый момент его свободное место закончится и он будет заполнен. В этом случае информацию об очередном вызове попросту будет некуда сохранить. В данном случае стэк у нас заполнился на количестве вызовов 5 и информацию о 6 вызове его уже сохранять некуда. Друзья, здесь, конечно же, синтезированный пример с стэком небольшого размера, буквально на 5 вызовов. На практике, как мы видели, число вызовов может достигать порядка десятков тысяч, после чего происходит ошибка. При совершении очередного рекурсивного вызова программа попытается сохранить в стеке информацию о нем. В данном примере это вызов с аргументом минус 1, однако места там уже свободного нет. Как раз таки здесь, друзья, мы увидим информацию о том, что стэк переполнен. Чтобы это не допустить, мы используем базовый случай, при достижении которого рекурсивные вызовы вот здесь мы останавливали. Еще раз. Под переполнением стэка мы понимаем ситуацию, при которой его свободный объем полностью исчерпан и предпринимается попытка добавить в него данные. На этом лекция подходит к концу. Давайте подведем ее итоги. Если мы говорим про рекурсию, то стоит помнить про определение в широком смысле и более узком, которое уже относится непосредственно к программированию. Напомню, что рекурсия состоит из рекурсивного вызова, основных вычислений, некого простейшего или базового случая, который служит для остановки рекурсии. Наиболее популярные области применения рекурсии – это обходы деревьев, сортировки, а также поиск файлов и подкаталогов в каких-либо директориях. Рекурсию следует применять с осторожностью, в тех случаях, когда она действительно оправдывает свое применение и упрощает алгоритмы или делает их более компактными. После блога задач на рекурсию мы с вами рассмотрели два способа отладки программ. Это с использованием отладочной печати на консоль или файл, а также с использованием особого инструмента. В заключении лекции мы обсудили принципы создания хороших программ и рассмотрели несколько возможных вопросов в собеседовании на тематику рекурсии. Ну что, друзья, на этом теоретическая часть курса заканчивается. Впереди у нас семинар. Несмотря на небольшое количество лекций, мы с командой Geekbrains, помимо базовых тематик, таких как арифметика, условные операторы, циклы, массивы, функции, постарались поместить туда и дополнительные разделы. Такие как рекомендации по написанию хорошего кода, особенности работы с текстовым типом данных, отладка программ, блок вопросов с собеседованием и несколько других. Если какие-то тематики остались непонятными, то я рекомендую ознакомиться с дополнительной литературой. Дополнительными источниками я рекомендую пользоваться для закрепления материала, а также для более глубокого его изучения. Позвольте пожелать вам успехов в дальнейшем освоении профессии, грамотных преподавателей и интересных задач. На этом, друзья, курс знакомства с языками программирования завершается. Всем большое спасибо за работу и внимание. И до новых встреч! you",
    "chunks": [
        {
            "timestamp": [
                0.0,
                97.68
            ],
            "text": " you you you you Друзья, всех приветствую!"
        },
        {
            "timestamp": [
                98.3,
                101.44
            ],
            "text": " Поздравляю вас с выходом на финишную прямую нашего курса."
        },
        {
            "timestamp": [
                102.02,
                104.64
            ],
            "text": " Сегодня мы рассматриваем заключительные тематики,"
        },
        {
            "timestamp": [
                106.06,
                111.46
            ],
            "text": " а также подводим итоги проведенных занятий. План на сегодня у нас следующий. Дадим определение рекурсии,"
        },
        {
            "timestamp": [
                111.46,
                119.26
            ],
            "text": " рассмотрим, что она из себя представляет, а также приведем примеры из жизни. Далее мы поговорим о"
        },
        {
            "timestamp": [
                119.26,
                125.32
            ],
            "text": " рекурсии в контексте программирования, рассмотрим ее составные части и решим блок задач."
        },
        {
            "timestamp": [
                126.16,
                129.5
            ],
            "text": " Отдельным пунктом обсудим, что такое отладка программ."
        },
        {
            "timestamp": [
                130.5,
                133.8
            ],
            "text": " И примерим два способа отладки на наших программах."
        },
        {
            "timestamp": [
                134.04,
                137.34
            ],
            "text": " В заключение рассмотрим три полезных принципа разработки программ,"
        },
        {
            "timestamp": [
                137.46,
                142.08
            ],
            "text": " а также приведем небольшое собеседование по тематике рекурсия."
        },
        {
            "timestamp": [
                142.54,
                143.66
            ],
            "text": " Итак, давайте начнем."
        },
        {
            "timestamp": [
                144.36,
                146.88
            ],
            "text": " Для новичков в программировании тематика рекурсии,"
        },
        {
            "timestamp": [
                147.14,
                152.28
            ],
            "text": " рекурсивные алгоритмы обычно дается сложно. Поэтому перед тем, как говорить о рекурсии в"
        },
        {
            "timestamp": [
                152.28,
                159.14
            ],
            "text": " контексте языка программирования, давайте рассмотрим это понятие в более широком смысле и приведем"
        },
        {
            "timestamp": [
                159.14,
                166.62
            ],
            "text": " реальные примеры из жизни. Под рекурсией в широком смысле мы понимаем описание объекта или процесса, который находится"
        },
        {
            "timestamp": [
                166.62,
                174.06
            ],
            "text": " в этом же самом объекте или же процессе. То есть объект является частью самого себя. Наиболее"
        },
        {
            "timestamp": [
                174.06,
                179.88
            ],
            "text": " широкое применение рекурсия имеет в математике и информатике. Но мы с вами начнем знакомство с"
        },
        {
            "timestamp": [
                179.88,
                187.76
            ],
            "text": " рекурсией на более простых примерах, чтобы уловить ее основные идеи. Первый пример, который мы рассмотрим, это техника изображения рекурсии."
        },
        {
            "timestamp": [
                187.76,
                193.58
            ],
            "text": " Суть ее в том, что внутри изображения размещается его уменьшенная копия,"
        },
        {
            "timestamp": [
                193.58,
                198.72
            ],
            "text": " как вы можете видеть на картинке справа. Внутри этой уменьшенной копии копия"
        },
        {
            "timestamp": [
                198.72,
                204.46
            ],
            "text": " предыдущего изображения и так далее теоретически до бесконечности."
        },
        {
            "timestamp": [
                204.46,
                207.86
            ],
            "text": " На практике же до пределов допустимого качества изображения."
        },
        {
            "timestamp": [
                208.38,
                210.86
            ],
            "text": " То есть пока его можно разглядеть на картинке."
        },
        {
            "timestamp": [
                211.36,
                214.6
            ],
            "text": " Второй пример рекурсии, с которым, я думаю, каждый из вас сталкивался,"
        },
        {
            "timestamp": [
                214.8,
                215.8
            ],
            "text": " это набор матрешек."
        },
        {
            "timestamp": [
                216.86,
                220.06
            ],
            "text": " Обратите внимание, что здесь выполняется определение рекурсии."
        },
        {
            "timestamp": [
                220.76,
                224.04
            ],
            "text": " Описание объекта, например, одна из матрешек,"
        },
        {
            "timestamp": [
                225.1,
                227.38
            ],
            "text": " который находится в этом же объекте,"
        },
        {
            "timestamp": [
                227.96,
                230.44
            ],
            "text": " в некоторой более крупной матрешке."
        },
        {
            "timestamp": [
                230.82,
                232.84
            ],
            "text": " Отмечу, что эта рекурсия не бесконечна,"
        },
        {
            "timestamp": [
                233.44,
                236.46
            ],
            "text": " поскольку какую бы большую матрешку мы изначально не взяли,"
        },
        {
            "timestamp": [
                237.2,
                239.56
            ],
            "text": " допустим, вот которая здесь в правой части экрана,"
        },
        {
            "timestamp": [
                239.56,
                241.38
            ],
            "text": " мы дойдем до таких размеров,"
        },
        {
            "timestamp": [
                241.74,
                245.58
            ],
            "text": " меньше которых изготовить фигууры уже физически будет невозможно."
        },
        {
            "timestamp": [
                246.0,
                247.58
            ],
            "text": " Третий пример похож на первый."
        },
        {
            "timestamp": [
                248.18,
                253.22
            ],
            "text": " Здесь также применяется техника размещения уменьшенной копии изображения в нем же самом."
        },
        {
            "timestamp": [
                253.9,
                259.52
            ],
            "text": " В этом примере рекурсия также будет ограничена возможностью изобразить мелкие детали рисунка."
        },
        {
            "timestamp": [
                259.52,
                263.02
            ],
            "text": " Подобное изображение можно увидеть при работе за компьютером."
        },
        {
            "timestamp": [
                263.24,
                265.76
            ],
            "text": " Здесь изображено окно программы для удаленного"
        },
        {
            "timestamp": [
                265.76,
                271.32
            ],
            "text": " управления с включенной демонстрацией рабочего стола. Если расшарить экран на обоих компьютерах,"
        },
        {
            "timestamp": [
                271.32,
                277.94
            ],
            "text": " на управляющем и на управляемом, то можно увидеть подобную картинку. В данном примере, друзья,"
        },
        {
            "timestamp": [
                277.94,
                284.18
            ],
            "text": " изображение рабочего стола будет уменьшаться, пока не достигнет размеров буквально в 1 пиксель."
        },
        {
            "timestamp": [
                284.18,
                287.94
            ],
            "text": " И в заключение этой рубрики давайте рассмотрим пример,"
        },
        {
            "timestamp": [
                287.94,
                290.42
            ],
            "text": " который показывает принцип самовоспроизведения."
        },
        {
            "timestamp": [
                290.42,
                293.2
            ],
            "text": " Здесь акцент делается не на использовании уменьшенной"
        },
        {
            "timestamp": [
                293.2,
                296.56
            ],
            "text": " копии изображения, как мы делали в предыдущих примерах."
        },
        {
            "timestamp": [
                296.56,
                299.38
            ],
            "text": " Здесь же акцент делается на самовоспроизведении,"
        },
        {
            "timestamp": [
                299.38,
                302.02
            ],
            "text": " а также одновременном усложнении системы."
        },
        {
            "timestamp": [
                302.02,
                304.56
            ],
            "text": " Базовой фигурой в этом рисунке является пара"
        },
        {
            "timestamp": [
                304.56,
                305.62
            ],
            "text": " соединенных линий,"
        },
        {
            "timestamp": [
                305.62,
                312.72
            ],
            "text": " которые образуют одну ветку. Ветки большего размера строятся из базовой фигуры. Простая"
        },
        {
            "timestamp": [
                312.72,
                319.56
            ],
            "text": " ветка самовоспроизводится и одновременно фигура усложняется, то есть веток становится больше. То"
        },
        {
            "timestamp": [
                319.56,
                329.48
            ],
            "text": " есть вторая фигура построена, как вы можете видеть, из трех базовых веток. Первая ветка, вторая и третья в самом низу."
        },
        {
            "timestamp": [
                329.48,
                334.88
            ],
            "text": " Третья фигура уже состоит из семи веток и четвертая"
        },
        {
            "timestamp": [
                334.88,
                337.18
            ],
            "text": " заключает в себе 15 веток."
        },
        {
            "timestamp": [
                337.18,
                340.22
            ],
            "text": " По мере добавления в рисунок новых веток они уменьшаются"
        },
        {
            "timestamp": [
                340.22,
                343.02
            ],
            "text": " в размерах, чтобы соблюдать пропорции дерева."
        },
        {
            "timestamp": [
                343.02,
                346.1
            ],
            "text": " Обратите внимание, что на второй фигуре можно"
        },
        {
            "timestamp": [
                346.1,
                350.26
            ],
            "text": " видеть два уровня веток, на третьей – три и на четвертой"
        },
        {
            "timestamp": [
                350.26,
                352.04
            ],
            "text": " – четыре уровня веток."
        },
        {
            "timestamp": [
                352.04,
                353.78
            ],
            "text": " Вопрос для любителей математики."
        },
        {
            "timestamp": [
                353.78,
                356.7
            ],
            "text": " А как вы думаете, есть ли какая-то закономерность"
        },
        {
            "timestamp": [
                356.7,
                361.24
            ],
            "text": " между количеством уровней и числом веток в дереве?"
        },
        {
            "timestamp": [
                361.24,
                363.52
            ],
            "text": " Свои предположения можете написать в чат."
        },
        {
            "timestamp": [
                363.52,
                366.06
            ],
            "text": " Итак, друзья, после экскурса в рекурсию в"
        },
        {
            "timestamp": [
                366.06,
                372.12
            ],
            "text": " широком смысле, давайте поговорим о ней в контексте программирования. Дадим более точное определение,"
        },
        {
            "timestamp": [
                372.12,
                377.76
            ],
            "text": " рассмотрим, с каких частей она состоит и, самое главное, попытаемся понять, а как же она работает."
        },
        {
            "timestamp": [
                377.76,
                385.5
            ],
            "text": " Для того, чтобы определить рекурсию в программировании, мы задействуем знакомый нам термин функции. Итак, под рекурсией мы"
        },
        {
            "timestamp": [
                385.5,
                391.1
            ],
            "text": " будем понимать некоторый процесс, в котором функция вызывает саму себя."
        },
        {
            "timestamp": [
                391.1,
                397.18
            ],
            "text": " Такую функцию мы будем называть рекурсивной, а подобный вызов называется"
        },
        {
            "timestamp": [
                397.18,
                402.02
            ],
            "text": " рекурсивным вызовом. Чтобы было понимание, как это выглядит на практике, давайте"
        },
        {
            "timestamp": [
                402.02,
                405.18
            ],
            "text": " рассмотрим фрагмент кода, который имитирует открытие матрешки."
        },
        {
            "timestamp": [
                405.18,
                412.56
            ],
            "text": " На экране представлена функция, которая уведомляет, что открывает матрешку и выводит на экран ее"
        },
        {
            "timestamp": [
                412.56,
                418.76
            ],
            "text": " размер. Затем можно видеть вызов этой же функции openMatryoshka и как раз таки этот вызов, друзья,"
        },
        {
            "timestamp": [
                418.76,
                426.42
            ],
            "text": " и называется рекурсивным. А сама функция openMatрешка называется рекурсивной функцией. Процесс"
        },
        {
            "timestamp": [
                426.42,
                430.86
            ],
            "text": " работы такой функции мы называем рекурсией. Чтобы все это дело запустить,"
        },
        {
            "timestamp": [
                430.86,
                435.68
            ],
            "text": " нам необходимо один раз вызвать функцию open матрешка и передать ей некоторое"
        },
        {
            "timestamp": [
                435.68,
                441.66
            ],
            "text": " значение. Параметр функции говорит о суммарном количестве матрешек. Друзья, с"
        },
        {
            "timestamp": [
                441.66,
                446.7
            ],
            "text": " точки зрения логики этот пример содержит ошибки, которые мы исправим далее."
        },
        {
            "timestamp": [
                446.98,
                453.36
            ],
            "text": " Цель этого примера показать основные компоненты рекурсии, которые мы ввели ранее. Следующим"
        },
        {
            "timestamp": [
                453.36,
                459.94
            ],
            "text": " этапом давайте рассмотрим их более детально. Первый элемент это рекурсивный вызов. Давайте"
        },
        {
            "timestamp": [
                459.94,
                466.12
            ],
            "text": " отметим себе, что целью рекурсивного вызова является решение более простой задачи или же более"
        },
        {
            "timestamp": [
                466.12,
                473.24
            ],
            "text": " меньшей, чем текущая. Здесь я попытался изобразить набор вызовов, где на каждом этапе решается"
        },
        {
            "timestamp": [
                473.24,
                479.78
            ],
            "text": " более простая задача, чем текущая. Под более простой задачей понимается задача с меньшим объемом"
        },
        {
            "timestamp": [
                479.78,
                486.56
            ],
            "text": " вычислений. В данной схеме последним вызовом будет выполняться задача, которая является тривиальной."
        },
        {
            "timestamp": [
                487.6,
                489.14
            ],
            "text": " И упрощать ее уже некуда."
        },
        {
            "timestamp": [
                489.44,
                493.22
            ],
            "text": " Отметьте себе, что такая задача называется базовым случаем."
        },
        {
            "timestamp": [
                493.62,
                500.56
            ],
            "text": " Если говорить про пример с матрешками, то базовый случай это самая вложенная или самая маленькая матрешка."
        },
        {
            "timestamp": [
                501.1,
                504.56
            ],
            "text": " Вы можете задаться вопросом, а как сделать задачу более простой?"
        },
        {
            "timestamp": [
                504.82,
                507.28
            ],
            "text": " Как ее уменьшить? Ведь"
        },
        {
            "timestamp": [
                507.28,
                513.12
            ],
            "text": " функция, в которой производится вычисление, никаким образом не меняется. Набор инструкций,"
        },
        {
            "timestamp": [
                513.22,
                520.96
            ],
            "text": " из которых состоит тело функции, остается неизменным. Друзья, здесь все дело в параметрах функции."
        },
        {
            "timestamp": [
                521.48,
                526.96
            ],
            "text": " Именно за счет них мы можем влиять на ее поведение. В самом простом случае мы можем"
        },
        {
            "timestamp": [
                526.96,
                530.46
            ],
            "text": " уменьшить величину параметров. Если это размер матрешки,"
        },
        {
            "timestamp": [
                530.46,
                533.22
            ],
            "text": " как в приведенном примере, то можно просто уменьшить"
        },
        {
            "timestamp": [
                533.22,
                538.68
            ],
            "text": " его на 1. Тем самым мы упростим решаемую задачу и приблизим"
        },
        {
            "timestamp": [
                538.68,
                543.56
            ],
            "text": " ее к базовому случаю. Вот эта вот функция function может"
        },
        {
            "timestamp": [
                543.56,
                548.56
            ],
            "text": " открывать матрешку, может выводить на экран какие-то данные, а может произвести вычисления."
        },
        {
            "timestamp": [
                549.3,
                558.2
            ],
            "text": " Для нас главное, что за счет изменения параметра мы делаем задачу каждый раз проще."
        },
        {
            "timestamp": [
                558.66,
                560.78
            ],
            "text": " Приводим ее к базовому случаю."
        },
        {
            "timestamp": [
                561.22,
                562.22
            ],
            "text": " Вернемся к примеру."
        },
        {
            "timestamp": [
                562.3,
                568.0
            ],
            "text": " Основное действие функции это имитация открытия матрешки с выводом ее размера."
        },
        {
            "timestamp": [
                568.0,
                573.0
            ],
            "text": " Далее мы видим рекурсивный вызов – один из основных компонентов рекурсии."
        },
        {
            "timestamp": [
                573.0,
                580.0
            ],
            "text": " Но обратите внимание, что вызов осуществляется с тем же значением параметра size."
        },
        {
            "timestamp": [
                580.0,
                590.0
            ],
            "text": " То есть он никак не меняется. Здесь не выполняется требование, что рекурсивный вызов должен приводить к решению более простой задачи."
        },
        {
            "timestamp": [
                591.54,
                596.34
            ],
            "text": " Давайте подумаем, как можно его оформить, чтобы он приблизил нас к базовому случаю."
        },
        {
            "timestamp": [
                596.7,
                603.22
            ],
            "text": " Чтобы этого достичь, можно сделать рекурсивный вызов со значением параметра, допустим, на единицу меньше."
        },
        {
            "timestamp": [
                603.62,
                605.52
            ],
            "text": " Тем самым мы будем приближаться к"
        },
        {
            "timestamp": [
                605.52,
                611.78
            ],
            "text": " базовому случаю можно считать это открытие матрешки размером 1 открытие"
        },
        {
            "timestamp": [
                611.78,
                616.0
            ],
            "text": " матрешки единичного размера будем считать тривиальной задачи после"
        },
        {
            "timestamp": [
                616.0,
                620.76
            ],
            "text": " выполнения которой нужно остановиться запустим рекурсию для этого вызовем"
        },
        {
            "timestamp": [
                620.76,
                629.88
            ],
            "text": " функцию с некоторым значением допустустим равным 5. На экране мы видим процесс открытия матрешек размером от 5 до 1."
        },
        {
            "timestamp": [
                631.22,
                636.62
            ],
            "text": " Однако после открытия матрешки с размером 1, как можно видеть, процедура продолжается."
        },
        {
            "timestamp": [
                637.5,
                639.58
            ],
            "text": " Размеры матрешек уже стали отрицательными."
        },
        {
            "timestamp": [
                639.92,
                642.82
            ],
            "text": " Возникает вопрос, остановится ли когда-нибудь этот процесс."
        },
        {
            "timestamp": [
                643.76,
                647.78
            ],
            "text": " Ответ – нет, не остановится, поскольку он работает как бесконечный цикл."
        },
        {
            "timestamp": [
                648.42,
                653.64
            ],
            "text": " Каких-либо условий для остановки рекурсии в коде мы с вами не писали."
        },
        {
            "timestamp": [
                654.26,
                657.72
            ],
            "text": " Друзья, мы подошли ко второй составляющей рекурсии."
        },
        {
            "timestamp": [
                658.48,
                660.58
            ],
            "text": " Это условия для ее остановки."
        },
        {
            "timestamp": [
                660.58,
                666.4
            ],
            "text": " Если этого не делать, то рекурсивные вызовы будут выполняться бесконечно, что в итоге"
        },
        {
            "timestamp": [
                666.4,
                672.54
            ],
            "text": " приведет к зацикливанию или же ошибке во время выполнения. Рекурсию останавливают, когда на"
        },
        {
            "timestamp": [
                672.54,
                679.9
            ],
            "text": " очередном вызове становится понятно, что задача стала простейшей. То есть мы подошли к базовому"
        },
        {
            "timestamp": [
                679.9,
                687.5
            ],
            "text": " случаю. Обычно на это указывает значение параметра. В этом случае рекурсийный вызов не делается и"
        },
        {
            "timestamp": [
                687.5,
                693.2
            ],
            "text": " функцию завершают инструкции return. При необходимости возвращают значение."
        },
        {
            "timestamp": [
                693.2,
                698.6
            ],
            "text": " Вернемся к нашему примеру и посмотрим, а как можно остановить рекурсию в нужный момент."
        },
        {
            "timestamp": [
                698.6,
                705.46
            ],
            "text": " Для этого нужно понять, а каким должно быть значение параметра size, чтобы считать эту задачу тривиальной,"
        },
        {
            "timestamp": [
                705.46,
                710.44
            ],
            "text": " или же простейшей, или другими словами базовым случаем. Как мы сказали ранее,"
        },
        {
            "timestamp": [
                710.44,
                716.56
            ],
            "text": " эта функция открывает матрешки до единичного размера. Следовательно, открытие матрешки размером"
        },
        {
            "timestamp": [
                716.56,
                729.04
            ],
            "text": " 1 мы можем считать базовым случаем. Добавим условие, которое проверит равенство параметра единиц. Если это так, то завершим выполнение функции без рекурсивного вызова."
        },
        {
            "timestamp": [
                729.78,
                731.3
            ],
            "text": " Воспользуемся инструкцией return."
        },
        {
            "timestamp": [
                731.68,
                739.48
            ],
            "text": " Также для информативности добавим соответствующее сообщение о том, что мы достигли самой маленькой матрешки."
        },
        {
            "timestamp": [
                740.02,
                750.6
            ],
            "text": " Посмотрим, каким будет результат работы программы. В окне вывода мы видим последовательность открытия матрешек с размерами от 5 и до единичного размера."
        },
        {
            "timestamp": [
                750.72,
                756.1
            ],
            "text": " На этом рекурсивные вызовы останавливаются и мы видим соответствующее уведомление."
        },
        {
            "timestamp": [
                756.1,
                761.44
            ],
            "text": " Друзья, мы с вами рассмотрели достаточно простой вариант применения рекурсии."
        },
        {
            "timestamp": [
                761.92,
                768.28
            ],
            "text": " Когда функция сначала делает некоторую работу и в конце вызывает себя"
        },
        {
            "timestamp": [
                768.28,
                775.3
            ],
            "text": " рекурсивным. Однако, если функция будет вначале иметь рекурсивный вызов, а затем выполнение работы,"
        },
        {
            "timestamp": [
                775.3,
                781.24
            ],
            "text": " то ее поведение будет несколько отличаться. Вернемся к нашему примеру. В нем рекурсивный"
        },
        {
            "timestamp": [
                781.24,
                789.3
            ],
            "text": " вызов происходит после выполнения основных действий, после вывода на экран информации об открытии очередной матрешки."
        },
        {
            "timestamp": [
                789.62,
                795.0
            ],
            "text": " Давайте немного перепишем функцию так, чтобы сначала шел рекурсивный вызов, а затем выполнялась основная работа."
        },
        {
            "timestamp": [
                795.84,
                799.86
            ],
            "text": " Теперь вывод сообщения на экран находится в конце функции."
        },
        {
            "timestamp": [
                800.52,
                806.9
            ],
            "text": " Вначале мы видим рекурсивный вызов, также с проверкой условий на базовый случай."
        },
        {
            "timestamp": [
                806.9,
                811.56
            ],
            "text": " Посмотрим на результат работы этой функции и сравним его с предыдущим выводом."
        },
        {
            "timestamp": [
                811.56,
                815.54
            ],
            "text": " В консоли мы видим все тот же набор сообщений об открытии матрешек,"
        },
        {
            "timestamp": [
                815.54,
                822.76
            ],
            "text": " но в этом случае размеры идут по возрастанию от двойки и до суммарного количества матрешек."
        },
        {
            "timestamp": [
                822.76,
                825.64
            ],
            "text": " Функция у нас вызывается все с тем же аргументом равным 5,"
        },
        {
            "timestamp": [
                825.98,
                828.88
            ],
            "text": " однако размеры идут в обратном порядке."
        },
        {
            "timestamp": [
                829.06,
                831.58
            ],
            "text": " Попробуем разобраться, как работает рекурсия в этом случае."
        },
        {
            "timestamp": [
                831.98,
                837.98
            ],
            "text": " Изобразим схематически, что будет происходить при вызове функции с аргументом равным 4."
        },
        {
            "timestamp": [
                837.98,
                841.34
            ],
            "text": " На схеме изображены 4 вызова функции open матрешка."
        },
        {
            "timestamp": [
                841.58,
                846.76
            ],
            "text": " Первый вызов – это первоначальный вызов функции с аргументом равным"
        },
        {
            "timestamp": [
                846.76,
                853.68
            ],
            "text": " четырем. Второй вызов, как вы можете видеть, это уже рекурсивный с аргументом на единицу меньше,"
        },
        {
            "timestamp": [
                853.68,
                860.34
            ],
            "text": " чем предыдущий, то есть с тройкой. Этот вызов, обратите внимание, происходит вот здесь на 8"
        },
        {
            "timestamp": [
                860.34,
                865.98
            ],
            "text": " строке кода. Он рекурсивный. На строку номер 5 до 6 мы не попадем,"
        },
        {
            "timestamp": [
                866.44,
                867.78
            ],
            "text": " поскольку базовый случай"
        },
        {
            "timestamp": [
                867.78,
                870.22
            ],
            "text": " размер матрешки единицы"
        },
        {
            "timestamp": [
                870.22,
                871.82
            ],
            "text": " еще не достигнут. Также"
        },
        {
            "timestamp": [
                871.82,
                874.22
            ],
            "text": " мы с вами не попадем и на 9 строчку,"
        },
        {
            "timestamp": [
                874.48,
                876.02
            ],
            "text": " поскольку при рекурсивном"
        },
        {
            "timestamp": [
                876.02,
                878.02
            ],
            "text": " вызове на 8 строчке мы"
        },
        {
            "timestamp": [
                878.02,
                880.28
            ],
            "text": " снова попадем в начало функции."
        },
        {
            "timestamp": [
                880.92,
                881.62
            ],
            "text": " Третий вызов"
        },
        {
            "timestamp": [
                881.62,
                884.0
            ],
            "text": " является рекурсивным, но уже"
        },
        {
            "timestamp": [
                884.0,
                887.56
            ],
            "text": " с параметром 2 на единицу меньше, чем предыдущий."
        },
        {
            "timestamp": [
                887.56,
                893.26
            ],
            "text": " Ну и четвертый вызов все так же рекурсивный, его аргумент равен единице."
        },
        {
            "timestamp": [
                893.26,
                896.72
            ],
            "text": " Вызов функции с аргументом 1 приведет к следующему."
        },
        {
            "timestamp": [
                896.72,
                901.12
            ],
            "text": " Мы попадаем в тело условного оператора if."
        },
        {
            "timestamp": [
                901.12,
                906.88
            ],
            "text": " На экран выводится соответствующее сообщение о том, что достигнута самая маленькая"
        },
        {
            "timestamp": [
                906.88,
                914.44
            ],
            "text": " матрешка и выполняется инструкция return на шестой строке кода. Друзья, это как раз-таки тот момент,"
        },
        {
            "timestamp": [
                914.44,
                920.28
            ],
            "text": " когда череда рекурсивных вызовов останавливается. Но что будет происходить дальше? Предлагаю"
        },
        {
            "timestamp": [
                920.28,
                1048.68
            ],
            "text": " подумать над этим вопросом пару минут самостоятельно, а затем мы обсудим ваши догадки. you you you you На этом моменте начинается самое интересное."
        },
        {
            "timestamp": [
                1049.32,
                1053.56
            ],
            "text": " Предлагаю собраться с силами и внимательно проследить за следующими этапами."
        },
        {
            "timestamp": [
                1053.56,
                1058.38
            ],
            "text": " Мы достигли инструкции Return, на которой череда вызовов останавливается."
        },
        {
            "timestamp": [
                1058.58,
                1062.5
            ],
            "text": " То есть мы находимся вот здесь, сразу же после вывода сообщения."
        },
        {
            "timestamp": [
                1062.92,
                1065.92
            ],
            "text": " После выполнения Return мы должны вернуться в то место,"
        },
        {
            "timestamp": [
                1066.52,
                1067.52
            ],
            "text": " откуда нас вызвали."
        },
        {
            "timestamp": [
                1067.92,
                1072.06
            ],
            "text": " А это, друзья, как раз-таки предыдущий шаг с номером 4,"
        },
        {
            "timestamp": [
                1072.74,
                1077.18
            ],
            "text": " на котором отмечен вызов функции с аргументом равным единице."
        },
        {
            "timestamp": [
                1077.54,
                1081.36
            ],
            "text": " Мы окажемся сразу после вот этой инструкции вызова."
        },
        {
            "timestamp": [
                1081.96,
                1083.5
            ],
            "text": " То есть после нее давайте посмотрим,"
        },
        {
            "timestamp": [
                1083.66,
                1084.02
            ],
            "text": " что идет."
        },
        {
            "timestamp": [
                1084.6,
                1085.5
            ],
            "text": " Вывод на экран."
        },
        {
            "timestamp": [
                1086.0,
                1087.06
            ],
            "text": " Консоль в WriteLine."
        },
        {
            "timestamp": [
                1087.56,
                1091.44
            ],
            "text": " Для ясности покажу суть этого возврата на простом примере."
        },
        {
            "timestamp": [
                1091.44,
                1097.18
            ],
            "text": " Здесь функция выводит на экран некоторое сообщение и сразу же завершается."
        },
        {
            "timestamp": [
                1097.72,
                1100.02
            ],
            "text": " Давайте перейдем к моменту ее вызова."
        },
        {
            "timestamp": [
                1100.14,
                1100.88
            ],
            "text": " Шестая строка."
        },
        {
            "timestamp": [
                1101.1,
                1102.62
            ],
            "text": " Вызов функцию ShowMessage."
        },
        {
            "timestamp": [
                1103.02,
                1103.86
            ],
            "text": " Возникает вопрос."
        },
        {
            "timestamp": [
                1104.46,
                1107.36
            ],
            "text": " Куда мы попадем после ее завершения?"
        },
        {
            "timestamp": [
                1107.78,
                1112.76
            ],
            "text": " Конечно же, мы попадаем сразу же на следующую строку после вызова функции."
        },
        {
            "timestamp": [
                1112.88,
                1117.48
            ],
            "text": " То есть это строка номер 7, где у нас располагается некоторый вывод на экран."
        },
        {
            "timestamp": [
                1117.48,
                1120.62
            ],
            "text": " То же самое произойдет и при рекурсивном вызове."
        },
        {
            "timestamp": [
                1121.36,
                1127.38
            ],
            "text": " После вызова функции openMatryoshka находится вывод на экран. Вот здесь строка"
        },
        {
            "timestamp": [
                1127.38,
                1134.08
            ],
            "text": " номер 9. Она и будет выполнена с аргументом, который в данный момент равен 2. То есть вот"
        },
        {
            "timestamp": [
                1134.08,
                1140.7
            ],
            "text": " эта строчка 9 будет выполнена. На схеме она отмечена вот здесь. Обращаю внимание, друзья,"
        },
        {
            "timestamp": [
                1140.7,
                1148.0
            ],
            "text": " size переменная равна 2. Это мы увидим на экране в консоли. Вот здесь вот в левой части"
        },
        {
            "timestamp": [
                1148.0,
                1155.24
            ],
            "text": " экрана. Далее инструкция у нас заканчивается и функция завершается. То есть после 9 строки кода"
        },
        {
            "timestamp": [
                1155.24,
                1161.16
            ],
            "text": " функция у нас прекращает свою работу. Но не забываем, что эта функция была вызвана ранее,"
        },
        {
            "timestamp": [
                1161.16,
                1169.9
            ],
            "text": " на шаге номер 3. Вот здесь. И мы точно таким же образом вернемся туда вместо ее вызова вот по этой стрелке несмотря на то что здесь"
        },
        {
            "timestamp": [
                1169.9,
                1174.94
            ],
            "text": " явно не прописан оператор return после девятой строчки он будет выполнен"
        },
        {
            "timestamp": [
                1174.94,
                1179.98
            ],
            "text": " неявно и произойдет возврат после вызова функции open матрешка с аргументом 2"
        },
        {
            "timestamp": [
                1179.98,
                1186.04
            ],
            "text": " идет инструкция вывода на консоль на На схеме она изображена здесь. Она выведет переменную size,"
        },
        {
            "timestamp": [
                1186.38,
                1188.64
            ],
            "text": " значение которой равно 3."
        },
        {
            "timestamp": [
                1188.96,
                1191.24
            ],
            "text": " Мы это увидим на экране."
        },
        {
            "timestamp": [
                1191.54,
                1193.66
            ],
            "text": " На этом инструкции функции закончатся."
        },
        {
            "timestamp": [
                1194.04,
                1196.6
            ],
            "text": " И мы таким же образом отправимся на место"
        },
        {
            "timestamp": [
                1196.6,
                1198.38
            ],
            "text": " предыдущего вызова."
        },
        {
            "timestamp": [
                1198.84,
                1201.32
            ],
            "text": " Здесь выполняются те же действия, что и ранее."
        },
        {
            "timestamp": [
                1202.0,
                1204.64
            ],
            "text": " На экране мы с вами увидим об открытии матрешки"
        },
        {
            "timestamp": [
                1204.64,
                1206.08
            ],
            "text": " с размером 4."
        },
        {
            "timestamp": [
                1206.7,
                1210.12
            ],
            "text": " После этого мы вернемся на место первоначального вызова функции."
        },
        {
            "timestamp": [
                1210.7,
                1214.9
            ],
            "text": " То есть вот по этой стрелке мы возвращаемся на первоначальный вызов."
        },
        {
            "timestamp": [
                1215.7,
                1218.28
            ],
            "text": " И на этом, друзья, рекурсия завершится."
        },
        {
            "timestamp": [
                1218.28,
                1223.1
            ],
            "text": " Друзья, для понимания давайте отметим себе несколько важных моментов,"
        },
        {
            "timestamp": [
                1223.54,
                1225.18
            ],
            "text": " которые происходят при рекурсе."
        },
        {
            "timestamp": [
                1225.42,
                1234.38
            ],
            "text": " Во-первых, процесс возврата, который мы видели на схеме к местам вызовов, называется раскручиванием рекурсии."
        },
        {
            "timestamp": [
                1234.72,
                1242.24
            ],
            "text": " Во-вторых, в процессе раскручивания рекурсии мы как бы возвращаемся во времени назад к местам вызова функции."
        },
        {
            "timestamp": [
                1242.48,
                1246.48
            ],
            "text": " Отметьте себе, что места вызовов сохраняются в памяти,"
        },
        {
            "timestamp": [
                1246.74,
                1248.56
            ],
            "text": " чтобы потом можно было к ним вернуться."
        },
        {
            "timestamp": [
                1249.14,
                1254.74
            ],
            "text": " То есть в памяти будет сохранен вызов первый, второй, третий."
        },
        {
            "timestamp": [
                1254.9,
                1259.12
            ],
            "text": " И потом в эти сохраненные места мы будем уже делать возврат."
        },
        {
            "timestamp": [
                1259.12,
                1267.36
            ],
            "text": " То есть места вызова функции с аргументами 4, 3, 2, 1 будут сохранены в памяти."
        },
        {
            "timestamp": [
                1268.08,
                1270.66
            ],
            "text": " И затем начнется раскручивание рекурсии."
        },
        {
            "timestamp": [
                1270.66,
                1276.38
            ],
            "text": " То есть проход по вот этим стрелочкам, которые у нас изображены на схеме."
        },
        {
            "timestamp": [
                1276.42,
                1279.1
            ],
            "text": " В-третьих, помимо места, куда нужно вернуться,"
        },
        {
            "timestamp": [
                1279.7,
                1283.4
            ],
            "text": " это у нас строка номер 8, при раскручивании,"
        },
        {
            "timestamp": [
                1283.66,
                1286.5
            ],
            "text": " в памяти сохраняются значения параметров, с которыми"
        },
        {
            "timestamp": [
                1286.5,
                1296.68
            ],
            "text": " была вызвана функция. То есть 4, 3, 2, 1. Делается для того, чтобы при выводе на консоль строка номер"
        },
        {
            "timestamp": [
                1296.68,
                1307.68
            ],
            "text": " 9 выводилось корректное значение матрешки. То есть размер 2, 3, 4. Если это не сохранять, то размер у нас будет всегда один и тот же."
        },
        {
            "timestamp": [
                1307.98,
                1313.5
            ],
            "text": " Давайте отметим себе, что область памяти, куда сохраняется вся эта информация, называется стэком."
        },
        {
            "timestamp": [
                1314.0,
                1316.66
            ],
            "text": " Резюмируем сказанное и отметим основные особенности."
        },
        {
            "timestamp": [
                1317.08,
                1327.62
            ],
            "text": " Под раскручиванием рекурсии мы понимаем возвраты к местам вызова функций. При вызове функции в памяти сохраняются место возврата, то есть куда нам"
        },
        {
            "timestamp": [
                1327.62,
                1334.64
            ],
            "text": " возвращаться при раскручивании, а также значение параметров при вызове. И эта область памяти"
        },
        {
            "timestamp": [
                1334.64,
                1341.48
            ],
            "text": " называется стэк. Мы с вами рассмотрели механизм работы рекурсии на примере открытия набора матрешек"
        },
        {
            "timestamp": [
                1341.48,
                1346.82
            ],
            "text": " на некоторой вложности. Но обратили ли вы внимание на некоторую странность,"
        },
        {
            "timestamp": [
                1346.82,
                1353.56
            ],
            "text": " которая происходит при открытии? Если рекурсивный вызов располагается до основной работы, то"
        },
        {
            "timestamp": [
                1353.56,
                1360.88
            ],
            "text": " матрешки у нас как бы открываются изнутри. То есть от самой маленькой до самой большой. Посмотрим"
        },
        {
            "timestamp": [
                1360.88,
                1367.46
            ],
            "text": " еще раз на вывод. Видно, что открытие происходит от самой маленькой к самой большой матрешке"
        },
        {
            "timestamp": [
                1367.46,
                1371.14
            ],
            "text": " Что в действительности практически нереализуемо"
        },
        {
            "timestamp": [
                1371.14,
                1372.96
            ],
            "text": " И в целом звучит странно"
        },
        {
            "timestamp": [
                1372.96,
                1376.92
            ],
            "text": " Мы привыкли, что матрешка открывается в обратном порядке"
        },
        {
            "timestamp": [
                1376.92,
                1380.56
            ],
            "text": " То есть сначала самая большая и до самой вложенной"
        },
        {
            "timestamp": [
                1380.56,
                1386.04
            ],
            "text": " Друзья, здесь дело в том, что расположение рекурсивного вызова влияет"
        },
        {
            "timestamp": [
                1386.04,
                1388.12
            ],
            "text": " на последовательность действий в алгоритме."
        },
        {
            "timestamp": [
                1389.26,
                1390.16
            ],
            "text": " Некоторые алгоритмы"
        },
        {
            "timestamp": [
                1390.16,
                1392.28
            ],
            "text": " могут корректно работать с расположением"
        },
        {
            "timestamp": [
                1392.28,
                1393.8
            ],
            "text": " рекурсивного вызова как"
        },
        {
            "timestamp": [
                1393.8,
                1395.84
            ],
            "text": " до, так и"
        },
        {
            "timestamp": [
                1395.84,
                1397.32
            ],
            "text": " после основной работы."
        },
        {
            "timestamp": [
                1397.94,
                1399.68
            ],
            "text": " А некоторые алгоритмы, в частности,"
        },
        {
            "timestamp": [
                1399.78,
                1401.16
            ],
            "text": " как наш пример,"
        },
        {
            "timestamp": [
                1402.04,
                1403.62
            ],
            "text": " могут от этого пострадать."
        },
        {
            "timestamp": [
                1404.02,
                1409.1
            ],
            "text": " Поэтому рекомендую внимательно относиться к месту размещения рекурсивного вызова."
        },
        {
            "timestamp": [
                1410.28,
                1415.76
            ],
            "text": " Он будет влиять, от него будет зависеть последовательность операций в алгоритме."
        },
        {
            "timestamp": [
                1416.06,
                1421.62
            ],
            "text": " И отметьте себе важный момент, что раскручивание рекурсии будет происходить независимо от того,"
        },
        {
            "timestamp": [
                1422.04,
                1423.66
            ],
            "text": " где расположен рекурсивный вызов."
        },
        {
            "timestamp": [
                1423.66,
                1428.32
            ],
            "text": " Будь то он расположен после основной работы, как в примере слева,"
        },
        {
            "timestamp": [
                1428.72,
                1432.78
            ],
            "text": " или же он находится до запуска основных действий."
        },
        {
            "timestamp": [
                1433.06,
                1435.74
            ],
            "text": " Сам принцип работы рекурсии от этого не изменится."
        },
        {
            "timestamp": [
                1436.18,
                1442.14
            ],
            "text": " Друзья, задача с открытием матрешек вполне неплохой пример для демонстрации работы рекурсии."
        },
        {
            "timestamp": [
                1442.22,
                1448.02
            ],
            "text": " Как в случае нормального поведения, то есть открытия от больше и к меньше,"
        },
        {
            "timestamp": [
                1448.4,
                1450.88
            ],
            "text": " так и в случае открытия матрешек как бы изнутри."
        },
        {
            "timestamp": [
                1451.28,
                1455.0
            ],
            "text": " Но хотелось бы выяснить, в каких задачах рекурсия реально полезна"
        },
        {
            "timestamp": [
                1455.0,
                1456.32
            ],
            "text": " и упрощает их решение."
        },
        {
            "timestamp": [
                1456.96,
                1459.16
            ],
            "text": " Давайте рассмотрим несколько примеров рекурсии,"
        },
        {
            "timestamp": [
                1459.52,
                1462.24
            ],
            "text": " где ее применение действительно себя оправдывает."
        },
        {
            "timestamp": [
                1462.24,
                1464.52
            ],
            "text": " На экране представлен пример структуры данных,"
        },
        {
            "timestamp": [
                1464.8,
                1469.32
            ],
            "text": " которая носит название дерево. Дерево – это один из способов хранения и упорядочивания данных,"
        },
        {
            "timestamp": [
                1469.32,
                1473.5
            ],
            "text": " наряду с массивом. Деревья используются для хранения данных в иерархическом порядке,"
        },
        {
            "timestamp": [
                1473.5,
                1478.76
            ],
            "text": " для поисковых задач и для сортировок. Рекурсия здесь применяется для наиболее"
        },
        {
            "timestamp": [
                1478.76,
                1487.98
            ],
            "text": " компактной и понятной реализации обхода его элементов. Под обходом мы понимаем обеспечение доступа или же проход по"
        },
        {
            "timestamp": [
                1487.98,
                1493.36
            ],
            "text": " всем элементам дерева. Похожую задачу мы с вами решали с массивами. Если же использовать"
        },
        {
            "timestamp": [
                1493.36,
                1500.9
            ],
            "text": " итеративную версию обхода такой структуры данных, то она будет значительно больше по объему кода."
        },
        {
            "timestamp": [
                1500.9,
                1506.72
            ],
            "text": " И, кроме того, потребует использования дополнительных структур данных, таких как стэк"
        },
        {
            "timestamp": [
                1506.72,
                1507.96
            ],
            "text": " или очередь."
        },
        {
            "timestamp": [
                1507.96,
                1511.6
            ],
            "text": " Второй пример – это алгоритм быстрой сортировки, также"
        },
        {
            "timestamp": [
                1511.6,
                1513.56
            ],
            "text": " его называют Quick Sort."
        },
        {
            "timestamp": [
                1513.56,
                1516.6
            ],
            "text": " Является одним из самых быстрых алгоритмов."
        },
        {
            "timestamp": [
                1516.6,
                1519.56
            ],
            "text": " Превосходит по скорости пузырьковую сортировку,"
        },
        {
            "timestamp": [
                1519.56,
                1522.84
            ],
            "text": " сортировку выбором, вставками и многие другие."
        },
        {
            "timestamp": [
                1522.84,
                1527.0
            ],
            "text": " Рекурсия здесь является одним из основных компонентов. Именно"
        },
        {
            "timestamp": [
                1527.0,
                1532.5
            ],
            "text": " за счет нее и достигается высокая скорость работы. Ну и третий пример это обход каталогов файловой"
        },
        {
            "timestamp": [
                1532.5,
                1540.7
            ],
            "text": " системы. Здесь рекурсивные алгоритмы используются для поисков файлов, папок, а также для формирования"
        },
        {
            "timestamp": [
                1540.7,
                1548.44
            ],
            "text": " листингов содержимого. Язык C-S C Sharp и платформа.NET представляют достаточно удобные методы получения списка файлов."
        },
        {
            "timestamp": [
                1548.44,
                1552.9
            ],
            "text": " Однако, если нам потребуется получить список файлов на всю глубину каталогов,"
        },
        {
            "timestamp": [
                1552.98,
                1557.52
            ],
            "text": " то есть на всю глубину каталогов урок 1, урок 2 или вложенных,"
        },
        {
            "timestamp": [
                1557.82,
                1559.82
            ],
            "text": " то рекурсия здесь будет как нельзя кстати."
        },
        {
            "timestamp": [
                1560.56,
                1564.56
            ],
            "text": " Она позволит организовать этот алгоритм просто и компактно."
        },
        {
            "timestamp": [
                1564.72,
                1571.44
            ],
            "text": " Предлагаю немного попартиковаться и решить классическую задачу на вычисление факториала с использованием рекурсии."
        },
        {
            "timestamp": [
                1572.18,
                1575.38
            ],
            "text": " Для начала давайте разберемся, что такое факториал числа."
        },
        {
            "timestamp": [
                1575.92,
                1586.78
            ],
            "text": " Факториалом натурального числа n называется произведение чисел от 1 и до самого числа n включительно. Чтобы вычислить факториал числа 5,"
        },
        {
            "timestamp": [
                1587.5,
                1590.7
            ],
            "text": " необходимо единицу умножить на следующее число, то есть на 2."
        },
        {
            "timestamp": [
                1591.0,
                1593.9
            ],
            "text": " Полученный результат необходимо умножить на следующее число,"
        },
        {
            "timestamp": [
                1593.98,
                1596.52
            ],
            "text": " после двойки, то есть на число 3."
        },
        {
            "timestamp": [
                1596.52,
                1600.06
            ],
            "text": " И так далее, пока мы не дойдем до самого числа."
        },
        {
            "timestamp": [
                1600.54,
                1604.72
            ],
            "text": " Для обозначения этой операции мы используем восклицательный знак."
        },
        {
            "timestamp": [
                1605.1,
                1609.3
            ],
            "text": " Отметим, что эта функция,ториал растет крайне быстро."
        },
        {
            "timestamp": [
                1609.86,
                1610.36
            ],
            "text": " О чем речь?"
        },
        {
            "timestamp": [
                1610.68,
                1616.2
            ],
            "text": " При небольшом увеличении числа n, то есть то число, от которого считается факториал,"
        },
        {
            "timestamp": [
                1616.28,
                1619.48
            ],
            "text": " значение факториала увеличивается весьма существенно."
        },
        {
            "timestamp": [
                1619.48,
                1626.56
            ],
            "text": " То есть факториал от 3 равен 6, от 5 он будет равен 120,"
        },
        {
            "timestamp": [
                1627.46,
                1633.6
            ],
            "text": " но при увеличении до 10 мы уже получаем число порядка 3 миллионов."
        },
        {
            "timestamp": [
                1634.0,
                1640.96
            ],
            "text": " Факториал от 1 у нас равен 1, и факториал 0 равен также 1 по определению."
        },
        {
            "timestamp": [
                1641.44,
                1643.64
            ],
            "text": " Такое значение примето математиками."
        },
        {
            "timestamp": [
                1643.64,
                1646.32
            ],
            "text": " Перед тем, как начать писать код, а на первых"
        },
        {
            "timestamp": [
                1646.32,
                1648.18
            ],
            "text": " порах может быть вообще непонятно"
        },
        {
            "timestamp": [
                1648.18,
                1650.22
            ],
            "text": " с чего начать, как подступиться"
        },
        {
            "timestamp": [
                1650.22,
                1652.16
            ],
            "text": " к написанию, предлагаю рассмотреть"
        },
        {
            "timestamp": [
                1652.16,
                1654.2
            ],
            "text": " основные компоненты рекурсии"
        },
        {
            "timestamp": [
                1654.2,
                1656.14
            ],
            "text": " для этой задачи."
        },
        {
            "timestamp": [
                1656.22,
                1658.32
            ],
            "text": " Первый элемент это рекурсивный вызов."
        },
        {
            "timestamp": [
                1659.04,
                1660.38
            ],
            "text": " Напомню, он нужен для того,"
        },
        {
            "timestamp": [
                1660.74,
                1662.12
            ],
            "text": " чтобы решить более"
        },
        {
            "timestamp": [
                1662.12,
                1664.12
            ],
            "text": " простую задачу и приблизиться"
        },
        {
            "timestamp": [
                1664.12,
                1665.7
            ],
            "text": " к тривиальному случаю. Самый очевидный решить более простую задачу и приблизиться к тривиальному случаю."
        },
        {
            "timestamp": [
                1666.1,
                1668.86
            ],
            "text": " Самый очевидный способ получить более простую задачу,"
        },
        {
            "timestamp": [
                1668.92,
                1670.32
            ],
            "text": " если мы говорим про факториал,"
        },
        {
            "timestamp": [
                1670.58,
                1673.72
            ],
            "text": " то это вычислить его от меньшего числа, чем исходное."
        },
        {
            "timestamp": [
                1674.66,
                1677.72
            ],
            "text": " То есть, например, уменьшить его на единицу."
        },
        {
            "timestamp": [
                1678.36,
                1680.32
            ],
            "text": " Тем самым задача будет упрощена."
        },
        {
            "timestamp": [
                1680.92,
                1682.66
            ],
            "text": " Следующее, над чем нам нужно подумать,"
        },
        {
            "timestamp": [
                1683.32,
                1686.58
            ],
            "text": " это как использовать решение более простой задачи в"
        },
        {
            "timestamp": [
                1686.58,
                1693.16
            ],
            "text": " рекурсивном вызове. Отмечу, что эта задача может быть непростой. Представим формулу факториала"
        },
        {
            "timestamp": [
                1693.16,
                1701.3
            ],
            "text": " несколько иначе. А именно, переставим сомножители наоборот. То есть от большего до числу к наименьшему."
        },
        {
            "timestamp": [
                1701.3,
                1705.44
            ],
            "text": " Ну и помним, что перестановка сомножителей на результат"
        },
        {
            "timestamp": [
                1705.44,
                1707.62
            ],
            "text": " не влияет, как и при сложении."
        },
        {
            "timestamp": [
                1707.92,
                1709.58
            ],
            "text": " А теперь давайте внимательно посмотрим"
        },
        {
            "timestamp": [
                1709.58,
                1710.78
            ],
            "text": " на формулу и подумаем,"
        },
        {
            "timestamp": [
                1711.32,
                1712.92
            ],
            "text": " можно ли в ней выделить"
        },
        {
            "timestamp": [
                1712.92,
                1715.46
            ],
            "text": " наиболее простую задачу."
        },
        {
            "timestamp": [
                1715.54,
                1717.18
            ],
            "text": " То есть можно ли в этой формуле"
        },
        {
            "timestamp": [
                1717.18,
                1719.52
            ],
            "text": " использовать формулу, которую мы написали"
        },
        {
            "timestamp": [
                1719.52,
                1721.46
            ],
            "text": " ранее. n-1 факториал."
        },
        {
            "timestamp": [
                1722.28,
                1723.32
            ],
            "text": " Заметьте, что"
        },
        {
            "timestamp": [
                1723.32,
                1725.62
            ],
            "text": " последние n-1 сомножители, то есть начиная от n-1, n-1 факториал. Заметьте, что последние n-1 со множителей,"
        },
        {
            "timestamp": [
                1726.62,
                1731.18
            ],
            "text": " то есть начиная от n-1, n-2 и так далее до единицы,"
        },
        {
            "timestamp": [
                1732.3,
                1736.04
            ],
            "text": " как раз таки составляют формулу для решения более простой задачи."
        },
        {
            "timestamp": [
                1736.26,
                1738.06
            ],
            "text": " Итоговая формула примет следующий вид."
        },
        {
            "timestamp": [
                1738.94,
                1741.18
            ],
            "text": " В нее войдет решение более простой задачи,"
        },
        {
            "timestamp": [
                1741.84,
                1743.72
            ],
            "text": " которое мы вывели ранее."
        },
        {
            "timestamp": [
                1743.72,
                1744.96
            ],
            "text": " И важный момент."
        },
        {
            "timestamp": [
                1745.32,
                1748.64
            ],
            "text": " В этой формуле также используется функция факториал."
        },
        {
            "timestamp": [
                1749.18,
                1751.3
            ],
            "text": " То есть формула задается рекурсивно."
        },
        {
            "timestamp": [
                1751.64,
                1753.28
            ],
            "text": " А это как раз-таки то, что нам нужно."
        },
        {
            "timestamp": [
                1754.12,
                1756.92
            ],
            "text": " Второй компонент – это условия остановки рекурсии."
        },
        {
            "timestamp": [
                1757.34,
                1759.74
            ],
            "text": " Напомню, рекурсивные вызовы нужно остановить,"
        },
        {
            "timestamp": [
                1760.0,
                1762.82
            ],
            "text": " как только решаемая задача станет тривиальной."
        },
        {
            "timestamp": [
                1763.0,
                1766.06
            ],
            "text": " Или же мы подойдем к базовому случаю."
        },
        {
            "timestamp": [
                1766.06,
                1770.66
            ],
            "text": " Давайте посмотрим, например, вычисление факториала от числа 3 с применением рекурсии."
        },
        {
            "timestamp": [
                1771.08,
                1774.86
            ],
            "text": " Итак, более простая задача в этом примере это факториал от 2."
        },
        {
            "timestamp": [
                1775.42,
                1780.12
            ],
            "text": " В итоге мы имеем формулу как 3 умножить на факториал 2."
        },
        {
            "timestamp": [
                1780.48,
                1783.7
            ],
            "text": " Теперь рассмотрим задачу факториал от числа 2."
        },
        {
            "timestamp": [
                1784.1,
                1787.66
            ],
            "text": " Как можно ее представить с применением рекурсии?"
        },
        {
            "timestamp": [
                1787.94,
                1792.9
            ],
            "text": " 2 факториал представляется как 2 умножить на факториал от единицы."
        },
        {
            "timestamp": [
                1793.5,
                1798.08
            ],
            "text": " Как раз таки факториал от числа 1 и будет тривиальная задача."
        },
        {
            "timestamp": [
                1798.3,
                1799.96
            ],
            "text": " Это является базовым случаем,"
        },
        {
            "timestamp": [
                1800.32,
                1804.24
            ],
            "text": " который решать дальше с применением рекурсии уже нет смысла."
        },
        {
            "timestamp": [
                1804.24,
                1809.18
            ],
            "text": " По определению, помните, 1 факториал равен единице."
        },
        {
            "timestamp": [
                1809.62,
                1814.04
            ],
            "text": " На этом, друзья, с основными компонентами, которые составляют рекурсию, все."
        },
        {
            "timestamp": [
                1814.5,
                1816.38
            ],
            "text": " Предлагаю оформить решение на C-Sharp."
        },
        {
            "timestamp": [
                1816.84,
                1818.86
            ],
            "text": " Работаем мы сегодня в каталоге урок 5."
        },
        {
            "timestamp": [
                1819.76,
                1822.36
            ],
            "text": " Создадим проект под каталоги с первым заданием."
        },
        {
            "timestamp": [
                1824.34,
                1827.46
            ],
            "text": " Итак, перейдем в файл с исходным кодом."
        },
        {
            "timestamp": [
                1827.46,
                1831.68
            ],
            "text": " Функция будет возвращать целое число, значение факториал."
        },
        {
            "timestamp": [
                1831.68,
                1834.46
            ],
            "text": " Поэтому сразу укажем тип возвращаемого значения"
        },
        {
            "timestamp": [
                1834.46,
                1835.46
            ],
            "text": " как int."
        },
        {
            "timestamp": [
                1835.46,
                1839.14
            ],
            "text": " Далее дадим название функции, допустим, факт."
        },
        {
            "timestamp": [
                1839.14,
                1843.0
            ],
            "text": " И укажем ее параметр, который будет также целым числом."
        },
        {
            "timestamp": [
                1843.0,
                1845.98
            ],
            "text": " Именно от него и будем вычислять значение факториала."
        },
        {
            "timestamp": [
                1847.24,
                1850.0
            ],
            "text": " Далее давайте оформим рекурсивный вызов."
        },
        {
            "timestamp": [
                1850.58,
                1853.62
            ],
            "text": " Вернем в качестве значения функции,"
        },
        {
            "timestamp": [
                1854.18,
                1856.96
            ],
            "text": " согласно сформированной нами формуле,"
        },
        {
            "timestamp": [
                1857.44,
                1860.48
            ],
            "text": " n умножить на факториал от n-1."
        },
        {
            "timestamp": [
                1861.2,
                1862.6
            ],
            "text": " Ну а, друзья, конечно же, помним,"
        },
        {
            "timestamp": [
                1862.6,
                1866.48
            ],
            "text": " что C-sharp в таком виде формулу факториала, конечно же,"
        },
        {
            "timestamp": [
                1866.48,
                1872.82
            ],
            "text": " не приемлем. Для него восклицательный знак является несколько другой операцией. Поэтому"
        },
        {
            "timestamp": [
                1872.82,
                1881.16
            ],
            "text": " напишем корректно и укажем именно функцию факт. То есть мы вычислим факториал от параметра,"
        },
        {
            "timestamp": [
                1881.16,
                1886.34
            ],
            "text": " уменьшенного на единицу. Попробуем запустить этот код, не используя"
        },
        {
            "timestamp": [
                1886.34,
                1888.18
            ],
            "text": " условия для остановки рекурсии."
        },
        {
            "timestamp": [
                1888.34,
                1890.2
            ],
            "text": " То есть укажем имя функции"
        },
        {
            "timestamp": [
                1890.2,
                1892.4
            ],
            "text": " факт и допустим передадим"
        },
        {
            "timestamp": [
                1892.4,
                1894.24
            ],
            "text": " ей какой-нибудь параметр, пускай"
        },
        {
            "timestamp": [
                1894.24,
                1896.3
            ],
            "text": " будет 5. Сохраним"
        },
        {
            "timestamp": [
                1896.3,
                1898.14
            ],
            "text": " изменения и"
        },
        {
            "timestamp": [
                1898.14,
                1899.8
            ],
            "text": " стартанем код."
        },
        {
            "timestamp": [
                1901.92,
                1904.34
            ],
            "text": " Что мы видим на экране? Давайте посмотрим."
        },
        {
            "timestamp": [
                1904.34,
                1908.9
            ],
            "text": " Нам среда выполнения написала сообщение stack overflow."
        },
        {
            "timestamp": [
                1908.9,
                1913.4
            ],
            "text": " Это, друзья, значит, что область памяти, которая именуется стэком,"
        },
        {
            "timestamp": [
                1913.78,
                1916.58
            ],
            "text": " помните, мы про него говорили, переполнилась,"
        },
        {
            "timestamp": [
                1917.3,
                1919.9
            ],
            "text": " поскольку мы никаким образом с вами рекурсию не остановили."
        },
        {
            "timestamp": [
                1920.84,
                1923.94
            ],
            "text": " Условий мы для остановки не использовали."
        },
        {
            "timestamp": [
                1924.46,
                1928.02
            ],
            "text": " Вопрос на засыпку. А как вы думаете, какими данными"
        },
        {
            "timestamp": [
                1928.02,
                1932.98
            ],
            "text": " заполнился стэк в нашей задаче? Подскажу. Эти данные"
        },
        {
            "timestamp": [
                1932.98,
                1937.28
            ],
            "text": " мы обсуждали, когда разбирали работу рекурсии на примере"
        },
        {
            "timestamp": [
                1937.28,
                1939.8
            ],
            "text": " с матрешками. Предлагаю в течение минуты подумать"
        },
        {
            "timestamp": [
                1939.8,
                2006.82
            ],
            "text": " над этим вопросом и свои предложения написать в чат. you Да, вы были совершенно правы, если вспомнили про место"
        },
        {
            "timestamp": [
                2006.82,
                2012.06
            ],
            "text": " возврата функции, а также значение параметров при"
        },
        {
            "timestamp": [
                2012.06,
                2013.56
            ],
            "text": " рекурсивном вызове."
        },
        {
            "timestamp": [
                2013.56,
                2015.76
            ],
            "text": " В стэк помещаются именно эти данные."
        },
        {
            "timestamp": [
                2015.76,
                2018.98
            ],
            "text": " Если запустить бесконечную рекурсию, то стэк достаточно"
        },
        {
            "timestamp": [
                2018.98,
                2020.52
            ],
            "text": " быстро переполнится."
        },
        {
            "timestamp": [
                2020.52,
                2023.34
            ],
            "text": " В принципе, что мы увидели на экране."
        },
        {
            "timestamp": [
                2023.34,
                2026.78
            ],
            "text": " Итак, добавим условия для остановки рекурсии. Напомню,"
        },
        {
            "timestamp": [
                2026.78,
                2032.3
            ],
            "text": " это случай, когда текущая задача стала тривиальной или мы приблизились к базовому"
        },
        {
            "timestamp": [
                2032.3,
                2038.46
            ],
            "text": " случаю. Но как в этой функции нам понять, что текущая задача тривиальна? Как мы говорили ранее,"
        },
        {
            "timestamp": [
                2038.46,
                2047.32
            ],
            "text": " в большинстве случаев на это указывает параметр функции. Давайте проверим этот параметр на равенство"
        },
        {
            "timestamp": [
                2047.32,
                2055.42
            ],
            "text": " единицы, поскольку при формировании этапов с основных частей рекурсии мы это отметили. Если"
        },
        {
            "timestamp": [
                2055.42,
                2066.64
            ],
            "text": " параметр будет равен единице, мы рекурсию остановим и вернем единицу, поскольку по определению факториал единицы равен единице."
        },
        {
            "timestamp": [
                2067.44,
                2072.72
            ],
            "text": " В остальные уже случаи, если у нас условие n равно единице не выполняется,"
        },
        {
            "timestamp": [
                2072.72,
                2075.84
            ],
            "text": " будет производиться рекурсивный вызов."
        },
        {
            "timestamp": [
                2076.28,
                2077.88
            ],
            "text": " Запустим код еще раз."
        },
        {
            "timestamp": [
                2078.52,
                2083.4
            ],
            "text": " Предлагаю добавить вывод полученного значения на экран,"
        },
        {
            "timestamp": [
                2083.52,
                2086.84
            ],
            "text": " чтобы можно было проверить правильность работы."
        },
        {
            "timestamp": [
                2086.84,
                2096.5
            ],
            "text": " Сохраним изменения и запустим еще раз. Ну и также, конечно, не забываем о форматировании"
        },
        {
            "timestamp": [
                2096.5,
                2104.26
            ],
            "text": " кода. Либо контекстное меню Format Document, либо сочетание клавиш Shift Alt F. Итак,"
        },
        {
            "timestamp": [
                2104.26,
                2106.38
            ],
            "text": " давайте посмотрим. На экране мы видим 120,"
        },
        {
            "timestamp": [
                2106.82,
                2113.02
            ],
            "text": " что говорит о правильной работе рекурсии. Также можно проверить, правильно ли работает рекурсия"
        },
        {
            "timestamp": [
                2113.02,
                2127.82
            ],
            "text": " при нуле. Давайте посмотрим. При нуле у нас должна рекурсия завершаться единицей, то есть возвращаться значение единицы. Но мы видим стэк слова переполняется, поскольку у нас"
        },
        {
            "timestamp": [
                2127.82,
                2134.94
            ],
            "text": " это условие не отработало. Предлагаю это требование учесть, эту особенность, и в проверке просто"
        },
        {
            "timestamp": [
                2134.94,
                2148.32
            ],
            "text": " добавить. Если у нас параметр равен единице или, подскажу, друзья, такой оператор или, который служит для объединения условий. Параметр равен 0, то тогда вернуть единицу."
        },
        {
            "timestamp": [
                2148.7,
                2150.98
            ],
            "text": " Сохраним и попробуем запустить еще раз."
        },
        {
            "timestamp": [
                2151.32,
                2154.7
            ],
            "text": " Да, действительно, теперь у нас факториал 0 равен 1."
        },
        {
            "timestamp": [
                2155.24,
                2160.56
            ],
            "text": " Друзья, отмечу, что использование рекурсии для вычисления факториала на практике не используется."
        },
        {
            "timestamp": [
                2160.98,
                2165.18
            ],
            "text": " Рекурсивные способы решения подобных задач мы используем исключительно для"
        },
        {
            "timestamp": [
                2165.18,
                2170.7
            ],
            "text": " демонстрации и изучения работы рекурсии. Факториал имеет более простое решение с применением"
        },
        {
            "timestamp": [
                2170.7,
                2177.92
            ],
            "text": " цикла. В данном случае демонстрируется цикл for. Напомню, for мы используем, когда количество"
        },
        {
            "timestamp": [
                2177.92,
                2185.88
            ],
            "text": " итераций у нас заранее известно. Кроме того, итеративное решение не опасно переполнением стека, которое может возникать"
        },
        {
            "timestamp": [
                2185.88,
                2193.86
            ],
            "text": " при рекурсивных вызовах. В качестве альтернативы рекурсии здесь создается цикл на n-1 итерации,"
        },
        {
            "timestamp": [
                2193.86,
                2201.56
            ],
            "text": " то есть от 2 и до n включительным, где происходит умножение переменной result на очередное число от"
        },
        {
            "timestamp": [
                2201.56,
                2207.6
            ],
            "text": " 2 до n. И после окончания работы цикла результат возвращается на место вызова."
        },
        {
            "timestamp": [
                2207.86,
                2210.66
            ],
            "text": " Мы познакомились с рекурсией в контексте языка C-sharp."
        },
        {
            "timestamp": [
                2210.66,
                2213.7
            ],
            "text": " Предлагаю посмотреть, как она будет выглядеть в других языках."
        },
        {
            "timestamp": [
                2214.12,
                2217.64
            ],
            "text": " Посмотреть, в чем будет отличие, а какие моменты будут схожи."
        },
        {
            "timestamp": [
                2217.8,
                2220.24
            ],
            "text": " Рассмотрим рекурсивную функцию для открытия матрешки."
        },
        {
            "timestamp": [
                2220.48,
                2222.76
            ],
            "text": " В языке C++ отличия минимальны."
        },
        {
            "timestamp": [
                2223.24,
                2226.32
            ],
            "text": " И они находятся на строке с выводом сообщения."
        },
        {
            "timestamp": [
                2226.32,
                2232.9
            ],
            "text": " Здесь используется конструкция std cout, которая свойственна именно языку C++."
        },
        {
            "timestamp": [
                2232.9,
                2239.2
            ],
            "text": " C-sharp представитель C-подобных языков. Он также имеет статическую типизацию и схожий синтаксис."
        },
        {
            "timestamp": [
                2239.2,
                2247.62
            ],
            "text": " В JavaScript отличий несколько больше. Во-первых, это также вывод сообщения. Используется конструкция console.log."
        },
        {
            "timestamp": [
                2248.56,
                2250.3
            ],
            "text": " Во-вторых, динамическая типизация."
        },
        {
            "timestamp": [
                2250.3,
                2254.46
            ],
            "text": " Обратите внимание, что типы возвращаемого значения у функции,"
        },
        {
            "timestamp": [
                2254.72,
                2257.74
            ],
            "text": " а также тип параметра не указываются."
        },
        {
            "timestamp": [
                2257.98,
                2260.2
            ],
            "text": " Вместо этого мы видим ключевое слово function,"
        },
        {
            "timestamp": [
                2260.78,
                2264.92
            ],
            "text": " что говорит интерпретатору JavaScript о том, что создается функция."
        },
        {
            "timestamp": [
                2269.62,
                2275.42
            ],
            "text": " Кстати, вопрос на засыпку. Все ли помнят, что такое интерпретатор и компилятор? Ну и третий пример – это Python. Здесь уже видны существенные отличия в синтезе и оформлении"
        },
        {
            "timestamp": [
                2275.42,
                2281.76
            ],
            "text": " блоков. Фигурных скобок здесь уже не используется. В отсутствии указания типа данных возвращаемое"
        },
        {
            "timestamp": [
                2281.76,
                2286.78
            ],
            "text": " значение функции, тип данных у параметра а также при выводе на"
        },
        {
            "timestamp": [
                2286.78,
                2291.9
            ],
            "text": " экран здесь используется функция print с отличиями все понятно давайте посмотрим"
        },
        {
            "timestamp": [
                2291.9,
                2297.1
            ],
            "text": " на общие части во всех этих трех примеров не трудно видеть что все"
        },
        {
            "timestamp": [
                2297.1,
                2301.84
            ],
            "text": " составные части рекурсии в том или ином виде да присутствуют во всех трех"
        },
        {
            "timestamp": [
                2301.84,
                2305.28
            ],
            "text": " примерах будь то компилируемые в языке C++,"
        },
        {
            "timestamp": [
                2308.12,
                2308.5
            ],
            "text": " будь то интерпретируемые в JavaScript и Python."
        },
        {
            "timestamp": [
                2309.1,
                2309.38
            ],
            "text": " Что мы имеем?"
        },
        {
            "timestamp": [
                2313.7,
                2314.2
            ],
            "text": " Основную работу – это вывод, сообщение об открытии матрешки,"
        },
        {
            "timestamp": [
                2317.24,
                2317.82
            ],
            "text": " проверка условия, не достигли ли мы базового случая,"
        },
        {
            "timestamp": [
                2319.64,
                2322.26
            ],
            "text": " также присутствует во всех трех языках. Ну и, конечно же, рекурсивный вызов,"
        },
        {
            "timestamp": [
                2322.82,
                2326.68
            ],
            "text": " если размер матрешки позволяет ее открывать."
        },
        {
            "timestamp": [
                2327.04,
                2331.84
            ],
            "text": " Друзья, отвлечемся от рекурсии и поговорим о такой тематике, как отладка."
        },
        {
            "timestamp": [
                2331.84,
                2336.42
            ],
            "text": " Посмотрим, что она из себя представляет, какие разновидности имеются,"
        },
        {
            "timestamp": [
                2336.84,
                2341.26
            ],
            "text": " а также попробуем применить несколько методик отладки на наших задачах."
        },
        {
            "timestamp": [
                2341.66,
                2347.76
            ],
            "text": " Под отладкой мы понимаем процесс поиска и исправление ошибок в коде."
        },
        {
            "timestamp": [
                2348.18,
                2350.14
            ],
            "text": " То есть отладку мы можем использовать,"
        },
        {
            "timestamp": [
                2350.48,
                2351.7
            ],
            "text": " если у нас есть подозрение,"
        },
        {
            "timestamp": [
                2351.88,
                2355.16
            ],
            "text": " что в коде есть ошибки или, другими словами, баги."
        },
        {
            "timestamp": [
                2355.24,
                2357.54
            ],
            "text": " Кроме того, отладка может быть применена,"
        },
        {
            "timestamp": [
                2358.04,
                2361.44
            ],
            "text": " если не совсем понятно или же совсем непонятно,"
        },
        {
            "timestamp": [
                2361.58,
                2362.7
            ],
            "text": " как работает программа."
        },
        {
            "timestamp": [
                2362.9,
                2364.86
            ],
            "text": " Отладку можно проводить путем вывода"
        },
        {
            "timestamp": [
                2364.86,
                2367.48
            ],
            "text": " интересующей информации на консоль."
        },
        {
            "timestamp": [
                2368.32,
                2369.46
            ],
            "text": " Или, например, в файл."
        },
        {
            "timestamp": [
                2369.8,
                2374.32
            ],
            "text": " Также можно пользоваться специальными инструментами среды разработчиков."
        },
        {
            "timestamp": [
                2374.5,
                2377.36
            ],
            "text": " Давайте рассмотрим каждый из этих способов подробнее."
        },
        {
            "timestamp": [
                2378.0,
                2382.66
            ],
            "text": " Итак, первый способ – это вывод информации о ходе работы программы на консоль."
        },
        {
            "timestamp": [
                2383.62,
                2384.94
            ],
            "text": " Или, допустим, в файл."
        },
        {
            "timestamp": [
                2384.94,
                2387.44
            ],
            "text": " Возникает вопрос, а какая информация может"
        },
        {
            "timestamp": [
                2387.44,
                2394.88
            ],
            "text": " быть выведена? Можно выводить значение переменных, значение параметров функции, а также просто"
        },
        {
            "timestamp": [
                2394.88,
                2400.82
            ],
            "text": " сообщение о том, что выполняется та или иная строка кода. Последний способ при выводе сообщений"
        },
        {
            "timestamp": [
                2400.82,
                2409.24
            ],
            "text": " позволяет понять попали ли мы в конкретный участок кода или нет. Давайте попробуем применить этот способ отладки на нашей задаче. Вернемся к"
        },
        {
            "timestamp": [
                2409.24,
                2413.66
            ],
            "text": " задаче с факториалом и давайте закомментируем участок, который отвечает"
        },
        {
            "timestamp": [
                2413.66,
                2420.56
            ],
            "text": " за остановку рекурсии. Напомню, что при запуске функции без остановки рекурсии"
        },
        {
            "timestamp": [
                2420.56,
                2434.76
            ],
            "text": " мы получим ошибку переполнения стек. Давайте еще раз на всякий случай проверим. Допустим, да, факториал от 5. Видим, да, что происходит ошибка. После выполнения функции,"
        },
        {
            "timestamp": [
                2434.76,
                2441.36
            ],
            "text": " то есть попытки запуске порядка 24 тысяч раз стек переполнился. Чтобы посмотреть,"
        },
        {
            "timestamp": [
                2441.36,
                2446.26
            ],
            "text": " что происходит при работе этой функции, давайте добавим отталочный вывод на консоль."
        },
        {
            "timestamp": [
                2446.76,
                2449.56
            ],
            "text": " Выведем значение параметра в начале функции."
        },
        {
            "timestamp": [
                2449.98,
                2455.2
            ],
            "text": " Допустим, вот здесь напишем консол.writeLine."
        },
        {
            "timestamp": [
                2455.8,
                2459.72
            ],
            "text": " Ну и, соответственно, сам параметр. Он равен у нас n."
        },
        {
            "timestamp": [
                2460.08,
                2462.8
            ],
            "text": " Сохраним изменения и запустим код еще раз."
        },
        {
            "timestamp": [
                2463.8,
                2468.22
            ],
            "text": " Видно, как на экран вводится значение параметра, и каждый раз он уменьшается."
        },
        {
            "timestamp": [
                2468.9,
                2473.58
            ],
            "text": " Обратите внимание, что параметр при выводе, который мы видели ранее,"
        },
        {
            "timestamp": [
                2473.92,
                2476.66
            ],
            "text": " не остановился на значении 0 или 1."
        },
        {
            "timestamp": [
                2476.92,
                2480.4
            ],
            "text": " Он уменьшался до тех пор, пока у нас не произошла ошибка,"
        },
        {
            "timestamp": [
                2481.1,
                2483.66
            ],
            "text": " сообщение которой мы, в принципе, видим на экране."
        },
        {
            "timestamp": [
                2483.78,
                2487.18
            ],
            "text": " Как раз для этого мы с вами используем остановку рекурсии,"
        },
        {
            "timestamp": [
                2487.46,
                2489.92
            ],
            "text": " чтобы избежать бесконечного числа вызовов."
        },
        {
            "timestamp": [
                2489.92,
                2493.76
            ],
            "text": " Еще раз, чтобы проследить, запустим код."
        },
        {
            "timestamp": [
                2494.82,
                2498.4
            ],
            "text": " И я остановлю нажатием клавиш Ctrl-C."
        },
        {
            "timestamp": [
                2498.56,
                2506.16
            ],
            "text": " То есть мы видим, что количество вызовов уже ушло за 6000 и продолжает расти."
        },
        {
            "timestamp": [
                2506.92,
                2510.32
            ],
            "text": " Вернем остановку рекурсии и давайте запустим код еще раз."
        },
        {
            "timestamp": [
                2510.96,
                2515.64
            ],
            "text": " Раскомментируем этот фрагмент, сохраним и запустим."
        },
        {
            "timestamp": [
                2515.64,
                2522.12
            ],
            "text": " На экране видим последовательность значений параметров от 5 до 2."
        },
        {
            "timestamp": [
                2522.4,
                2526.1
            ],
            "text": " При значении параметра равном единице, согласно коду,"
        },
        {
            "timestamp": [
                2526.52,
                2530.3
            ],
            "text": " в принципе, мы это видим при выводе, рекурсия завершается."
        },
        {
            "timestamp": [
                2530.94,
                2535.1
            ],
            "text": " И мы видим ответ, который мы пишем на строке номер 11, это 120."
        },
        {
            "timestamp": [
                2535.66,
                2540.2
            ],
            "text": " Чтобы понять, да, именно что мы попали вот сюда, в условие if, да,"
        },
        {
            "timestamp": [
                2540.64,
                2545.64
            ],
            "text": " в ветку до условия if, давайте здесь добавим также отладочный вывод на экран."
        },
        {
            "timestamp": [
                2546.78,
                2548.3
            ],
            "text": " Ну, допустим, напишем следующее,"
        },
        {
            "timestamp": [
                2548.94,
                2550.14
            ],
            "text": " что рекурсия остановилась."
        },
        {
            "timestamp": [
                2551.96,
                2552.8
            ],
            "text": " Стоп."
        },
        {
            "timestamp": [
                2553.82,
                2555.68
            ],
            "text": " И укажем значение параметра."
        },
        {
            "timestamp": [
                2557.3,
                2557.96
            ],
            "text": " И не забываем"
        },
        {
            "timestamp": [
                2557.96,
                2559.94
            ],
            "text": " указать, что это не просто строка,"
        },
        {
            "timestamp": [
                2560.58,
                2562.38
            ],
            "text": " а строка с форматированием."
        },
        {
            "timestamp": [
                2563.18,
                2563.62
            ],
            "text": " Или же"
        },
        {
            "timestamp": [
                2563.62,
                2566.64
            ],
            "text": " более правильный термин – интерполяция строки."
        },
        {
            "timestamp": [
                2567.42,
                2568.5
            ],
            "text": " Сохраним наработки."
        },
        {
            "timestamp": [
                2569.72,
                2570.54
            ],
            "text": " Запустим еще раз."
        },
        {
            "timestamp": [
                2570.88,
                2577.08
            ],
            "text": " В конце мы видим попадание в ветку условной конструкции if."
        },
        {
            "timestamp": [
                2577.66,
                2579.78
            ],
            "text": " И, соответственно, после этого видим ответ."
        },
        {
            "timestamp": [
                2580.18,
                2581.1
            ],
            "text": " А теперь вопрос, друзья."
        },
        {
            "timestamp": [
                2581.52,
                2584.86
            ],
            "text": " А как проследить за процессом раскручивания рекурсий?"
        },
        {
            "timestamp": [
                2585.0,
                2588.16
            ],
            "text": " Сейчас мы с вами пронаблюдали процесс вызовов."
        },
        {
            "timestamp": [
                2588.26,
                2592.58
            ],
            "text": " Но когда начинается череда возвратов после рекурсивных вызовов,"
        },
        {
            "timestamp": [
                2592.6,
                2595.86
            ],
            "text": " этот момент также хотелось бы увидеть на экране."
        },
        {
            "timestamp": [
                2595.86,
                2598.98
            ],
            "text": " Предлагаю подумать над этим моментом самостоятельно"
        },
        {
            "timestamp": [
                2598.98,
                2601.74
            ],
            "text": " и оставляю его в качестве домашнего задания."
        },
        {
            "timestamp": [
                2602.28,
                2604.62
            ],
            "text": " То есть необходимо добавить в код"
        },
        {
            "timestamp": [
                2604.62,
                2605.72
            ],
            "text": " некоторый"
        },
        {
            "timestamp": [
                2605.72,
                2611.1
            ],
            "text": " отладочный вывод на правильные места, который позволит увидеть, как"
        },
        {
            "timestamp": [
                2611.1,
                2616.0
            ],
            "text": " раскручивается рекурсия, то есть как формируется значение факториала."
        },
        {
            "timestamp": [
                2616.0,
                2621.3
            ],
            "text": " Сначала равно единице, затем двойки, тройки, шестерки и так далее."
        },
        {
            "timestamp": [
                2621.3,
                2626.94
            ],
            "text": " То есть постепенно эти умножения. Или же другими словами процесс возвратов"
        },
        {
            "timestamp": [
                2626.94,
                2633.74
            ],
            "text": " к местам вызовов. Вывод на экран может иметь следующий вид, когда вы уже примените отладочный"
        },
        {
            "timestamp": [
                2633.74,
                2639.32
            ],
            "text": " вывод. Желательно увидеть значение параметра функции при раскручивании рекурсии. То есть"
        },
        {
            "timestamp": [
                2639.32,
                2647.12
            ],
            "text": " параметр вот он 2, 3, 4, 5. А также вычисленное значение факториала на каждом шаге."
        },
        {
            "timestamp": [
                2647.42,
                2650.64
            ],
            "text": " Как можно видеть из примера, факториал считается постепенным."
        },
        {
            "timestamp": [
                2651.28,
                2654.9
            ],
            "text": " На каждом возврате к месту вызова он у нас увеличивается."
        },
        {
            "timestamp": [
                2655.32,
                2657.54
            ],
            "text": " От 1 и так далее до 120."
        },
        {
            "timestamp": [
                2658.3,
                2659.56
            ],
            "text": " Дам небольшую подсказку."
        },
        {
            "timestamp": [
                2659.96,
                2665.0
            ],
            "text": " Скорее всего, вычисление факториала на строке 9 можно разделить на составные части."
        },
        {
            "timestamp": [
                2665.5,
                2667.44
            ],
            "text": " То есть вот здесь, когда мы возвращаем ответ."
        },
        {
            "timestamp": [
                2668.08,
                2671.66
            ],
            "text": " Это позволит встроить отладочный вывод на нужную позицию."
        },
        {
            "timestamp": [
                2672.1,
                2675.42
            ],
            "text": " Двигаемся далее и рассмотрим более продвинутый способ отладки."
        },
        {
            "timestamp": [
                2675.42,
                2680.44
            ],
            "text": " Отладки – это использование специального инструмента или же отладчика."
        },
        {
            "timestamp": [
                2680.72,
                2688.84
            ],
            "text": " Отметим себе, что отладчик – это программа, которая позволяет запустить программу в особом режиме, который так и называется режим отладки."
        },
        {
            "timestamp": [
                2689.14,
                2695.04
            ],
            "text": " Обычно этот инструмент встроен в среду разработки, но может устанавливаться и отдельно."
        },
        {
            "timestamp": [
                2695.4,
                2702.72
            ],
            "text": " В редакторе VS Code нам понадобится расширение C-Sharp Development Kit, чтобы воспользоваться отладчиком."
        },
        {
            "timestamp": [
                2702.72,
                2706.04
            ],
            "text": " Отладчик позволяет запускать код построчно, вручную"
        },
        {
            "timestamp": [
                2706.04,
                2708.16
            ],
            "text": " переходя от инструкции к инструкции."
        },
        {
            "timestamp": [
                2708.54,
                2709.96
            ],
            "text": " Мы можем вручную выполнять"
        },
        {
            "timestamp": [
                2709.96,
                2712.02
            ],
            "text": " первую строку, затем вторую,"
        },
        {
            "timestamp": [
                2712.48,
                2714.06
            ],
            "text": " третью, четвертую и так далее,"
        },
        {
            "timestamp": [
                2714.18,
                2716.32
            ],
            "text": " пока не дойдем до конца программы."
        },
        {
            "timestamp": [
                2716.42,
                2717.88
            ],
            "text": " С его помощью можно выполнять"
        },
        {
            "timestamp": [
                2717.88,
                2720.04
            ],
            "text": " циклы, контролируя каждую"
        },
        {
            "timestamp": [
                2720.04,
                2722.18
            ],
            "text": " итерацию. Первая итерация, вторая,"
        },
        {
            "timestamp": [
                2722.44,
                2724.18
            ],
            "text": " третья. То есть выполнение тела"
        },
        {
            "timestamp": [
                2724.18,
                2725.96
            ],
            "text": " цикла. Мы можем приостановить"
        },
        {
            "timestamp": [
                2725.96,
                2728.1
            ],
            "text": " программу во время ее выполнения на указанной"
        },
        {
            "timestamp": [
                2728.1,
                2729.62
            ],
            "text": " строке. Это указано"
        },
        {
            "timestamp": [
                2729.62,
                2732.22
            ],
            "text": " в примере на шестой строчке."
        },
        {
            "timestamp": [
                2732.46,
                2733.46
            ],
            "text": " То есть отладчик здесь"
        },
        {
            "timestamp": [
                2733.46,
                2735.94
            ],
            "text": " приостановил выполнение кода и"
        },
        {
            "timestamp": [
                2735.94,
                2738.1
            ],
            "text": " ожидает команды от программиста."
        },
        {
            "timestamp": [
                2738.44,
                2739.14
            ],
            "text": " В ходе работы"
        },
        {
            "timestamp": [
                2739.14,
                2741.94
            ],
            "text": " также можно просматривать значения переменных"
        },
        {
            "timestamp": [
                2741.94,
                2744.28
            ],
            "text": " и массивов. Для этого используются"
        },
        {
            "timestamp": [
                2744.28,
                2745.82
            ],
            "text": " отдельные окна, отображение"
        },
        {
            "timestamp": [
                2745.82,
                2747.82
            ],
            "text": " которых можно включать в настройках."
        },
        {
            "timestamp": [
                2747.82,
                2753.76
            ],
            "text": " Здесь мы наблюдаем переменную n, ее значение наравно 5,"
        },
        {
            "timestamp": [
                2753.76,
                2757.74
            ],
            "text": " переменную i, у нее нулевое значение, ну и здесь я немного"
        },
        {
            "timestamp": [
                2757.74,
                2761.64
            ],
            "text": " подскажу, это массив с аргументами программы."
        },
        {
            "timestamp": [
                2761.64,
                2764.18
            ],
            "text": " В данном случае он у нас нулевой."
        },
        {
            "timestamp": [
                2764.18,
                2767.2
            ],
            "text": " Мы аргументы на вход программы никакие не передаем."
        },
        {
            "timestamp": [
                2767.56,
                2769.44
            ],
            "text": " Давайте вернемся к задаче с факториалом"
        },
        {
            "timestamp": [
                2769.44,
                2771.88
            ],
            "text": " и попробуем запустить программу в режиме отладки."
        },
        {
            "timestamp": [
                2772.22,
                2776.26
            ],
            "text": " Для запуска отладчика нам потребуется установить расширение C-Sharp DevKit."
        },
        {
            "timestamp": [
                2776.5,
                2777.94
            ],
            "text": " Давайте посмотрим, как он выглядит."
        },
        {
            "timestamp": [
                2778.38,
                2779.84
            ],
            "text": " У меня он уже установлен."
        },
        {
            "timestamp": [
                2780.44,
                2782.34
            ],
            "text": " Это официальное расширение от Microsoft,"
        },
        {
            "timestamp": [
                2782.72,
                2785.86
            ],
            "text": " которое и содержит в себе инструменты отладки."
        },
        {
            "timestamp": [
                2786.28,
                2787.26
            ],
            "text": " Итак, перейдем в код."
        },
        {
            "timestamp": [
                2787.62,
                2794.3
            ],
            "text": " После установки отладчика в правом верхнем углу становится доступна кнопка для его запуска."
        },
        {
            "timestamp": [
                2794.3,
                2801.84
            ],
            "text": " Итак, давайте нажмем «Стартануть отладку» проекта, который ассоциирован с этим файлом исходного кода."
        },
        {
            "timestamp": [
                2802.22,
                2804.2
            ],
            "text": " Итак, мы видим, что отладчик стартует."
        },
        {
            "timestamp": [
                2804.82,
                2806.16
            ],
            "text": " Сообщения желтым цветом"
        },
        {
            "timestamp": [
                2806.16,
                2812.6
            ],
            "text": " говорят о инициализации запуске отладчика. Мы видим, что программа отработала. Видим полностью"
        },
        {
            "timestamp": [
                2812.6,
                2819.92
            ],
            "text": " вывод на экран с ее сообщениями. Однако выполнение программы не остановилось. Она полностью отработала"
        },
        {
            "timestamp": [
                2819.92,
                2825.68
            ],
            "text": " и завершилась. Дело в том, что мы не указали отладчику, а на какой строчке ему нужно"
        },
        {
            "timestamp": [
                2825.68,
                2828.04
            ],
            "text": " остановить выполнение. То есть, допустим, на"
        },
        {
            "timestamp": [
                2828.04,
                2832.6
            ],
            "text": " 5, на 7, на 10 и так далее. Возможно,"
        },
        {
            "timestamp": [
                2832.6,
                2834.4
            ],
            "text": " некоторые из вас замечали, что слева"
        },
        {
            "timestamp": [
                2834.4,
                2838.26
            ],
            "text": " от номеров строк можно ставить красные"
        },
        {
            "timestamp": [
                2838.26,
                2841.32
            ],
            "text": " точки. Так вот, друзья, это и есть точки"
        },
        {
            "timestamp": [
                2841.32,
                2844.06
            ],
            "text": " остановки программы, которую использует"
        },
        {
            "timestamp": [
                2844.06,
                2845.2
            ],
            "text": " отладчик."
        },
        {
            "timestamp": [
                2848.96,
                2854.82
            ],
            "text": " То есть, когда отладчик запускается, он обращает внимание на эти точки и как бы приостанавливает работу программы в тех местах, где вы ему указали."
        },
        {
            "timestamp": [
                2855.18,
                2859.04
            ],
            "text": " Попадая на строчку, допустим, на эту с красной точкой,"
        },
        {
            "timestamp": [
                2859.4,
                2864.5
            ],
            "text": " выполнение приостанавливается, и отладчик будет ожидать команды от программиста."
        },
        {
            "timestamp": [
                2864.5,
                2866.06
            ],
            "text": " Итак, давайте поставим"
        },
        {
            "timestamp": [
                2866.06,
                2873.98
            ],
            "text": " точку останова на строке номер 10, там где выводится очередное значение параметра. И таким"
        },
        {
            "timestamp": [
                2873.98,
                2880.52
            ],
            "text": " же образом запустим отладку. Итак, отладчик запускается, мы видим, что запустилась функция"
        },
        {
            "timestamp": [
                2880.52,
                2885.28
            ],
            "text": " и выполнился код до поставленной точки."
        },
        {
            "timestamp": [
                2889.86,
                2891.92
            ],
            "text": " Строка, которая подсвечена желтым, где здесь есть желтый индикатор, еще не выполнилась."
        },
        {
            "timestamp": [
                2892.42,
                2895.12
            ],
            "text": " Отладчик в данный момент ожидает от нас команду."
        },
        {
            "timestamp": [
                2895.92,
                2898.9
            ],
            "text": " Обратите внимание на панель управления отладкой в верхней"
        },
        {
            "timestamp": [
                2898.9,
                2899.76
            ],
            "text": " части экрана."
        },
        {
            "timestamp": [
                2900.02,
                2901.68
            ],
            "text": " Нам здесь наиболее интересны кнопки."
        },
        {
            "timestamp": [
                2902.08,
                2905.14
            ],
            "text": " Продолжить от английского continue, клавиши F5."
        },
        {
            "timestamp": [
                2905.5,
                2909.32
            ],
            "text": " Сделать шаг с обходом, клавиши F10, step over."
        },
        {
            "timestamp": [
                2910.26,
                2913.56
            ],
            "text": " Сделать шаг с заходом, клавиши F11."
        },
        {
            "timestamp": [
                2913.96,
                2917.02
            ],
            "text": " А также остановить отладку, shift F5."
        },
        {
            "timestamp": [
                2917.64,
                2920.1
            ],
            "text": " Давайте отметим себе, можно даже в комментариях,"
        },
        {
            "timestamp": [
                2920.1,
                2923.7
            ],
            "text": " что кнопка шаг с заходом, то есть F11,"
        },
        {
            "timestamp": [
                2924.5,
                2927.86
            ],
            "text": " выполняет инструкцию, на которой находится курсор"
        },
        {
            "timestamp": [
                2927.86,
                2929.26
            ],
            "text": " и переходит к следующей."
        },
        {
            "timestamp": [
                2929.86,
                2934.26
            ],
            "text": " Соответственно, напишем себе шаг с заходом."
        },
        {
            "timestamp": [
                2935.1,
                2937.38
            ],
            "text": " Откуда такое название? Шаг с заходом."
        },
        {
            "timestamp": [
                2937.92,
                2941.94
            ],
            "text": " Дело в том, что если на пути отладчика встречается функция,"
        },
        {
            "timestamp": [
                2942.48,
                2946.7
            ],
            "text": " то отладчик зайдет в тело этой функции и будет уже идти по ней."
        },
        {
            "timestamp": [
                2947.46,
                2952.9
            ],
            "text": " Кнопка шаг с обходом также выполняет инструкцию, на которой находится курсор и переходит к следующей."
        },
        {
            "timestamp": [
                2953.04,
                2954.14
            ],
            "text": " Давайте себе это отметим."
        },
        {
            "timestamp": [
                2955.66,
                2958.5
            ],
            "text": " F10 это у нас шаг с обходом."
        },
        {
            "timestamp": [
                2959.72,
                2969.0
            ],
            "text": " С обходом тоже имеет свой смысл выражение. Это значит, что если на пути отладчика встречается вызов функции, допустим, факт,"
        },
        {
            "timestamp": [
                2969.82,
                2975.2
            ],
            "text": " то отладчик в эту функцию заходить не будет, а перейдет сразу к следующей инструкции."
        },
        {
            "timestamp": [
                2975.46,
                2984.16
            ],
            "text": " То есть, допустим, если бы здесь была бы какая-то инструкция сразу же после вызова функции факт,"
        },
        {
            "timestamp": [
                2984.38,
                2985.94
            ],
            "text": " то он перешел бы к этой инструкции."
        },
        {
            "timestamp": [
                2986.44,
                2990.8
            ],
            "text": " Давайте нажмем F10 и перейдем к следующей инструкции."
        },
        {
            "timestamp": [
                2991.28,
                2993.54
            ],
            "text": " Видно, как выполнение перешло на следующую строку."
        },
        {
            "timestamp": [
                2993.74,
                2996.08
            ],
            "text": " Индикатор загорелся на 11 строке."
        },
        {
            "timestamp": [
                2997.16,
                2998.62
            ],
            "text": " И давайте посмотрим на консоль."
        },
        {
            "timestamp": [
                2998.62,
                3001.88
            ],
            "text": " Здесь появился вывод параметра функции 5."
        },
        {
            "timestamp": [
                3002.74,
                3006.46
            ],
            "text": " То есть отработала функция вывода параметра на экран."
        },
        {
            "timestamp": [
                3006.94,
                3010.46
            ],
            "text": " Текущая строка номер 11 содержит вызов функции."
        },
        {
            "timestamp": [
                3010.68,
                3012.74
            ],
            "text": " Факториал от n-1."
        },
        {
            "timestamp": [
                3012.74,
                3017.74
            ],
            "text": " Давайте нажмем клавишу F11, чтобы отладчик зашел в эту функцию."
        },
        {
            "timestamp": [
                3018.58,
                3022.74
            ],
            "text": " Мы снова оказались в функции факториал, поскольку вызов был рекурсивным."
        },
        {
            "timestamp": [
                3023.54,
                3026.76
            ],
            "text": " Нажатием клавиши F10 можно выполнить инструкции"
        },
        {
            "timestamp": [
                3026.76,
                3033.6
            ],
            "text": " далее, вплоть до рекурсивного вызова. Давайте это проверим. Нажимаем F10, выполняем проверку"
        },
        {
            "timestamp": [
                3033.6,
                3040.46
            ],
            "text": " условной конструкции. Внутрь условия мы не попадаем и отправляемся на строчку номер 10."
        },
        {
            "timestamp": [
                3040.46,
                3049.6
            ],
            "text": " Нажимаем F10 еще раз и видите на консоли появляется значение параметра уже 4, на единицу"
        },
        {
            "timestamp": [
                3049.6,
                3058.68
            ],
            "text": " меньше чем предыдущие. Отметим себе, что клавиша F5 может использоваться для команды продолженная."
        },
        {
            "timestamp": [
                3058.68,
                3067.44
            ],
            "text": " Это значит, чтобы перейти к выполнению инструкции, на которой установлена точка останова."
        },
        {
            "timestamp": [
                3067.62,
                3072.24
            ],
            "text": " То есть мы перейдем вот на эту инструкцию при нажатии клавиши F5."
        },
        {
            "timestamp": [
                3072.6,
                3076.6
            ],
            "text": " Давайте нажмем клавишу F5 и мы снова попадаем на десятую строку."
        },
        {
            "timestamp": [
                3076.6,
                3086.22
            ],
            "text": " То есть мы зашли в функцию factorial, сделали проверку в условной конструкции и снова оказались на точке остановы, которая была поставлена. Таким"
        },
        {
            "timestamp": [
                3086.22,
                3094.58
            ],
            "text": " образом мы можем несколько раз нажать клавишу F5 и поочередно увидеть параметры при рекурсивных"
        },
        {
            "timestamp": [
                3094.58,
                3102.98
            ],
            "text": " вызовах. При некотором нажатии начнется раскручивание рекурсии, которая завершит в целом алгоритм."
        },
        {
            "timestamp": [
                3102.98,
                3106.74
            ],
            "text": " Также отмечу, что точки останова могут добавляться во время работы"
        },
        {
            "timestamp": [
                3106.74,
                3113.16
            ],
            "text": " отладчика. Можно поставить точку в начале функции и запустить отладку. Давайте попробуем это сделать."
        },
        {
            "timestamp": [
                3113.5,
                3120.98
            ],
            "text": " Итак, поставим точку в самом начале функции, запустим отладку. Мы оказались на первой строке"
        },
        {
            "timestamp": [
                3120.98,
                3128.06
            ],
            "text": " функции факт и прямо в режиме отладки можно добавить точку на произвольную строку, допустим на"
        },
        {
            "timestamp": [
                3128.88,
                3133.64
            ],
            "text": " 11. Для того чтобы переместиться сразу на 11 строчку кода, то есть выполнить"
        },
        {
            "timestamp": [
                3134.16,
                3138.46
            ],
            "text": " все что было до, мы нажимаем клавишу F5, то есть продолжить."
        },
        {
            "timestamp": [
                3139.2,
                3141.2
            ],
            "text": " Это значит у нас до"
        },
        {
            "timestamp": [
                3142.32,
                3144.32
            ],
            "text": " следующей точки."
        },
        {
            "timestamp": [
                3150.44,
                3154.88
            ],
            "text": " у нас до следующей точки. Нажимаем F5 и оказываемся на строке 11, там где стоит точка. На консоли мы также видим отладочный вывод. Отладчик останавливается в ожидании следующей команды."
        },
        {
            "timestamp": [
                3154.88,
                3162.06
            ],
            "text": " Таким образом, нажимая клавишу F5, мы перемещаемся между двумя этими точками останова, тем самым"
        },
        {
            "timestamp": [
                3162.06,
                3168.66
            ],
            "text": " постепенно выполняя алгоритм. Друзья, при отладке вы, наверное, обратили внимание на окно слева."
        },
        {
            "timestamp": [
                3169.04,
                3174.42
            ],
            "text": " Оно содержит имена переменных и значения их в определенный момент отладки."
        },
        {
            "timestamp": [
                3174.94,
                3179.38
            ],
            "text": " Обратите внимание, что при продвижении по алгоритму, я нажимаю клавишу F5,"
        },
        {
            "timestamp": [
                3180.28,
                3185.2
            ],
            "text": " значение переменная n уменьшается от 5 до и стремится к 1."
        },
        {
            "timestamp": [
                3185.94,
                3187.82
            ],
            "text": " После чего выполнение будет завершено."
        },
        {
            "timestamp": [
                3188.18,
                3192.28
            ],
            "text": " Как мы говорили ранее, это достаточно удобный инструмент отлаживания циклов,"
        },
        {
            "timestamp": [
                3192.58,
                3196.58
            ],
            "text": " когда нужно следить за значениями счетчиков и другими переменными."
        },
        {
            "timestamp": [
                3197.22,
                3200.42
            ],
            "text": " Итак, друзья, давайте резюмируем основные моменты по отладке."
        },
        {
            "timestamp": [
                3201.22,
                3204.16
            ],
            "text": " Основное назначение отладки – это поиск ошибок в коде."
        },
        {
            "timestamp": [
                3206.5,
                3212.9
            ],
            "text": " Основное назначение отладки – это поиск ошибок в коде. Также отладку можно использовать, если не совсем понятно, как программа работает. Самый простой способ отладки – это отладочная"
        },
        {
            "timestamp": [
                3212.9,
                3219.86
            ],
            "text": " печать. То есть вывод информации в определенных местах кода. Мы можем выводить значения"
        },
        {
            "timestamp": [
                3219.86,
                3228.8
            ],
            "text": " переменных, элементы массива или какие-либо сообщения. Отладочная печать позволяет нам понять, допустим, запустилась функция или нет,"
        },
        {
            "timestamp": [
                3229.14,
                3233.54
            ],
            "text": " на какой строчке произошла ошибка, а также запускается ли программа вообще."
        },
        {
            "timestamp": [
                3234.02,
                3237.84
            ],
            "text": " Более продвинутый способ отладки – это использование специального инструмента,"
        },
        {
            "timestamp": [
                3237.86,
                3239.5
            ],
            "text": " который называется отладчик."
        },
        {
            "timestamp": [
                3240.16,
                3243.14
            ],
            "text": " Отладчик позволяет нам запустить программу построечно"
        },
        {
            "timestamp": [
                3243.14,
                3249.3
            ],
            "text": " и отслеживая значение переменных, как мы это делали ранее, на каждом участке."
        },
        {
            "timestamp": [
                3249.48,
                3254.1
            ],
            "text": " Однако стоит заметить, что использование отладчика не всегда возможно."
        },
        {
            "timestamp": [
                3254.8,
                3266.82
            ],
            "text": " Связано это с тем, что программа может запускаться каким-либо нестандартным образом или запускается в условиях, в окружении, где запуск отладчика попросту невозможен."
        },
        {
            "timestamp": [
                3267.12,
                3270.94
            ],
            "text": " В таких случаях я бы предложил использовать отладочный вывод в файл."
        },
        {
            "timestamp": [
                3271.5,
                3275.5
            ],
            "text": " Запускаем программу и направляем сообщение в файл."
        },
        {
            "timestamp": [
                3276.0,
                3281.86
            ],
            "text": " Затем мы анализируем этот файл либо по окончании работы программы, либо же во время."
        },
        {
            "timestamp": [
                3282.14,
                3287.46
            ],
            "text": " Следующая тематика, которую мы рассмотрим, это принципы разработки программного обеспечения."
        },
        {
            "timestamp": [
                3287.46,
                3289.78
            ],
            "text": " Некоторые из них мы так или иначе использовали"
        },
        {
            "timestamp": [
                3289.78,
                3290.78
            ],
            "text": " в наших задачах."
        },
        {
            "timestamp": [
                3290.78,
                3292.64
            ],
            "text": " Предлагаю их резюмировать."
        },
        {
            "timestamp": [
                3292.64,
                3295.34
            ],
            "text": " На экране представлены достаточно популярные"
        },
        {
            "timestamp": [
                3295.34,
                3298.12
            ],
            "text": " принципы, которые позволяют улучшать структуру кода"
        },
        {
            "timestamp": [
                3298.12,
                3299.94
            ],
            "text": " и бороться с его сложностью."
        },
        {
            "timestamp": [
                3299.94,
                3304.04
            ],
            "text": " Первый принцип говорит нам о том, чтобы не дублировать"
        },
        {
            "timestamp": [
                3304.04,
                3306.84
            ],
            "text": " фрагменты кода, которые уже написаны."
        },
        {
            "timestamp": [
                3307.2,
                3313.14
            ],
            "text": " То есть от английского он переводится как «не повторяй себя» или покороче «не повторяйся»."
        },
        {
            "timestamp": [
                3313.14,
                3321.86
            ],
            "text": " Второй принцип призывает не усложнять код без необходимости, сохраняя его простым, собственно, как здесь и написано."
        },
        {
            "timestamp": [
                3322.14,
                3325.84
            ],
            "text": " То есть keep it simple,раняйте простым."
        },
        {
            "timestamp": [
                3327.08,
                3327.26
            ],
            "text": " Максимально простым."
        },
        {
            "timestamp": [
                3332.36,
                3332.72
            ],
            "text": " Третий принцип. Предлагает отказаться от функциональности, которая в продукте не требуется."
        },
        {
            "timestamp": [
                3335.84,
                3336.38
            ],
            "text": " Расшифровывается, как вам это не потребуется."
        },
        {
            "timestamp": [
                3339.64,
                3340.36
            ],
            "text": " Рассмотрим принципы подробнее и приведем примеры их нарушения."
        },
        {
            "timestamp": [
                3345.08,
                3345.34
            ],
            "text": " Некоторые из примеров сгенерировал я, а некоторые взял из работ студентов на текущем курсе."
        },
        {
            "timestamp": [
                3350.66,
                3350.98
            ],
            "text": " Первый принцип рекомендует избегать дублирования одинаковых фрагментов кода."
        },
        {
            "timestamp": [
                3354.64,
                3355.08
            ],
            "text": " Мы с вами им неоднократно пользовались, когда разрабатывали функции."
        },
        {
            "timestamp": [
                3358.1,
                3358.94
            ],
            "text": " Пример. Использование функции для вывода массива на экран."
        },
        {
            "timestamp": [
                3364.62,
                3366.42
            ],
            "text": " Вместо того, чтобы писать цикл для вывода массива несколько раз, мы вызывали соответствующую функцию. Почему дублирование кода"
        },
        {
            "timestamp": [
                3366.42,
                3372.04
            ],
            "text": " это пустая трата времени? Дело в том, что вам придется будет поддерживать логику программы,"
        },
        {
            "timestamp": [
                3372.04,
                3378.92
            ],
            "text": " а также тестировать код сразу в двух местах. Причем, если код изменится в одном месте, то вам"
        },
        {
            "timestamp": [
                3378.92,
                3384.5
            ],
            "text": " необходимо его будет править и во втором. В большинстве случаев дублирование кода происходит"
        },
        {
            "timestamp": [
                3384.5,
                3386.2
            ],
            "text": " из-за незнания особенностей"
        },
        {
            "timestamp": [
                3386.2,
                3388.18
            ],
            "text": " системы. То есть мы не знаем, что"
        },
        {
            "timestamp": [
                3388.18,
                3389.88
            ],
            "text": " какие-то компоненты уже есть,"
        },
        {
            "timestamp": [
                3390.02,
                3392.2
            ],
            "text": " а также, что они"
        },
        {
            "timestamp": [
                3392.2,
                3394.18
            ],
            "text": " могут отсутствовать. Как здесь сказано,"
        },
        {
            "timestamp": [
                3394.74,
                3396.54
            ],
            "text": " прежде чем что-либо писать,"
        },
        {
            "timestamp": [
                3396.68,
                3397.88
            ],
            "text": " необходимо осмотреться"
        },
        {
            "timestamp": [
                3397.88,
                3400.26
            ],
            "text": " и подумать. Возможно,"
        },
        {
            "timestamp": [
                3400.6,
                3402.46
            ],
            "text": " эта функция уже реализована."
        },
        {
            "timestamp": [
                3402.98,
                3404.64
            ],
            "text": " Возможно, эта бизнес-логика"
        },
        {
            "timestamp": [
                3404.64,
                3406.56
            ],
            "text": " присутствует в каком-то другом месте."
        },
        {
            "timestamp": [
                3406.84,
                3411.1
            ],
            "text": " Повторное использование функции – это хорошее решение данной проблемы."
        },
        {
            "timestamp": [
                3412.08,
                3415.74
            ],
            "text": " Одно из самых простых способов – это введение в программу функций."
        },
        {
            "timestamp": [
                3416.12,
                3416.8
            ],
            "text": " Рассмотрим пример."
        },
        {
            "timestamp": [
                3417.08,
                3421.34
            ],
            "text": " Это решение одного из студентов задачи с выводом на экран четных чисел."
        },
        {
            "timestamp": [
                3421.34,
                3428.6
            ],
            "text": " От одного и до некоторого введенного n. Вначале считывается число с консоли, затем"
        },
        {
            "timestamp": [
                3428.6,
                3436.62
            ],
            "text": " запускается цикл, в котором перебираются числа от 1 до n и каждый раз проверяются на четность. Если"
        },
        {
            "timestamp": [
                3436.62,
                3443.58
            ],
            "text": " это так, то число выводится на экран. Как вы думаете, есть ли здесь нарушение принципа do not repeat yourself?"
        },
        {
            "timestamp": [
                3443.58,
                3446.5
            ],
            "text": " Свои предположения можете написать в чат."
        },
        {
            "timestamp": [
                3446.92,
                3448.62
            ],
            "text": " К этому примеру мы еще вернемся."
        },
        {
            "timestamp": [
                3449.16,
                3453.2
            ],
            "text": " Следующий принцип говорит о том, что не нужно усложнять решение задачи,"
        },
        {
            "timestamp": [
                3453.2,
                3456.36
            ],
            "text": " когда можно обойтись более простым решением."
        },
        {
            "timestamp": [
                3456.7,
                3460.6
            ],
            "text": " Одна из распространенных ошибок – это использование новых инструментов"
        },
        {
            "timestamp": [
                3460.6,
                3463.08
            ],
            "text": " исключительно из-за того, что они красивые и блестят."
        },
        {
            "timestamp": [
                3463.36,
                3469.86
            ],
            "text": " Некоторые программисты таким образом стремятся продемонстрировать знания технологии, даже если эти инструменты не совсем"
        },
        {
            "timestamp": [
                3469.86,
                3477.32
            ],
            "text": " подходят для решения задач. Этот принцип подразумевает написание понятного кода. Если код непонятен,"
        },
        {
            "timestamp": [
                3477.98,
                3486.12
            ],
            "text": " то он автоматически становится сложным для его сопровождения, как указано здесь, для понимания последующей модификации."
        },
        {
            "timestamp": [
                3486.52,
                3487.54
            ],
            "text": " Рассмотрим такой пример."
        },
        {
            "timestamp": [
                3487.8,
                3490.92
            ],
            "text": " Цель программы – посчитать сумму элементов массива."
        },
        {
            "timestamp": [
                3491.4,
                3496.96
            ],
            "text": " В ней создается массив на 5 элементов, затем переменная для хранения суммы,"
        },
        {
            "timestamp": [
                3497.56,
                3499.44
            ],
            "text": " и в нее помещается первый элемент."
        },
        {
            "timestamp": [
                3500.0,
                3507.48
            ],
            "text": " Далее организуется цикл от последнего элемента до первого, в котором осуществляется суммирование."
        },
        {
            "timestamp": [
                3507.48,
                3512.6
            ],
            "text": " Друзья, видите ли вы в этом решении что-нибудь странное и нетиповое?"
        },
        {
            "timestamp": [
                3513.44,
                3517.14
            ],
            "text": " Можно ли сказать, что это решение было искусственно усложнено?"
        },
        {
            "timestamp": [
                3517.46,
                3521.2
            ],
            "text": " Предлагаю подумать над этим вопросом самостоятельно и обсудить на семинаре."
        },
        {
            "timestamp": [
                3521.74,
                3526.22
            ],
            "text": " Резюмируя сказанное и принцип Keep it simple, stupid в целом,"
        },
        {
            "timestamp": [
                3526.64,
                3530.16
            ],
            "text": " приведу цитату уже знакомого вам автора Стива Макону."
        },
        {
            "timestamp": [
                3530.38,
                3532.3
            ],
            "text": " Он считает управление сложностью"
        },
        {
            "timestamp": [
                3532.3,
                3534.82
            ],
            "text": " самым важным техническим аспектом"
        },
        {
            "timestamp": [
                3534.82,
                3536.14
            ],
            "text": " в разработке программ."
        },
        {
            "timestamp": [
                3536.56,
                3538.9
            ],
            "text": " Более того, управление сложностью"
        },
        {
            "timestamp": [
                3538.9,
                3541.28
            ],
            "text": " Стив Макону считает главным"
        },
        {
            "timestamp": [
                3541.28,
                3543.32
            ],
            "text": " техническим императивом в разработке ПУ."
        },
        {
            "timestamp": [
                3543.9,
                3545.46
            ],
            "text": " И на протяжении всей своей книги"
        },
        {
            "timestamp": [
                3545.46,
                3548.12
            ],
            "text": " совершенный код к этому термину обращается."
        },
        {
            "timestamp": [
                3548.66,
                3553.68
            ],
            "text": " Ну и третий принцип – это отказ от избыточной и ненужной функциональности."
        },
        {
            "timestamp": [
                3553.88,
                3556.72
            ],
            "text": " Он говорит нам о том, чтобы реализовывать только то,"
        },
        {
            "timestamp": [
                3556.96,
                3558.14
            ],
            "text": " что нужно в данный момент."
        },
        {
            "timestamp": [
                3558.5,
                3561.9
            ],
            "text": " Программист не должен добавлять в функционал программы"
        },
        {
            "timestamp": [
                3561.9,
                3567.4
            ],
            "text": " те компоненты, которые не значатся в техническом задании. Перечислим"
        },
        {
            "timestamp": [
                3567.4,
                3572.3
            ],
            "text": " остальные идеи, которые лежат в основе этого принципа. Не стоит писать код, который может"
        },
        {
            "timestamp": [
                3572.3,
                3578.48
            ],
            "text": " пригодиться позже. Например, пусть стоит задача вычислить среднее арифметическое от элементов"
        },
        {
            "timestamp": [
                3578.48,
                3583.98
            ],
            "text": " массива. После реализации такой функции по вычислению среднего арифметического мы решили"
        },
        {
            "timestamp": [
                3583.98,
                3586.1
            ],
            "text": " еще реализовать и функцию по вычислению среднего гефметического, мы решили еще реализовать и функцию по вычислению"
        },
        {
            "timestamp": [
                3586.1,
                3587.68
            ],
            "text": " среднего геометрического."
        },
        {
            "timestamp": [
                3588.3,
                3589.9
            ],
            "text": " Просто так, на всякий случай."
        },
        {
            "timestamp": [
                3590.2,
                3591.84
            ],
            "text": " Так вот, друзья, от этой идеи"
        },
        {
            "timestamp": [
                3591.84,
                3593.84
            ],
            "text": " лучше отказаться, если"
        },
        {
            "timestamp": [
                3593.84,
                3595.78
            ],
            "text": " оснований для"
        },
        {
            "timestamp": [
                3595.78,
                3598.46
            ],
            "text": " использования этой функции среднего геометрического"
        },
        {
            "timestamp": [
                3598.46,
                3600.08
            ],
            "text": " нет. Не стоит бояться"
        },
        {
            "timestamp": [
                3600.08,
                3601.1
            ],
            "text": " удалять лишний код."
        },
        {
            "timestamp": [
                3601.9,
                3604.46
            ],
            "text": " Его всегда можно восстановить из репозитория."
        },
        {
            "timestamp": [
                3606.9,
                3611.88
            ],
            "text": " Конечно же, если он сохранен соответствующими коммитами. Вы, должно быть, заметили, что этот принцип Ягни, который мы"
        },
        {
            "timestamp": [
                3611.88,
                3618.42
            ],
            "text": " рассматриваем, похож на принцип Кис. Он старается делать вещи как можно проще. Но дело в том, что"
        },
        {
            "timestamp": [
                3618.42,
                3626.28
            ],
            "text": " принцип Кис старается искать более простые решения, в то время как принцип Ягни не делает никаких решений."
        },
        {
            "timestamp": [
                3626.66,
                3630.96
            ],
            "text": " Вернемся к примеру с подсчетом количества четных чисел от 1 до n."
        },
        {
            "timestamp": [
                3631.4,
                3635.38
            ],
            "text": " Обратите внимание на код в блоках if и else."
        },
        {
            "timestamp": [
                3635.72,
                3640.2
            ],
            "text": " И в первом, и во втором блоке присутствует инструкция увеличения переменной на n."
        },
        {
            "timestamp": [
                3640.88,
                3642.36
            ],
            "text": " Она увеличивается на единицу."
        },
        {
            "timestamp": [
                3642.36,
                3646.96
            ],
            "text": " Также переменная i также увеличивается на единицу. Также переменная i также увеличивается на единицу. В подобных случаях"
        },
        {
            "timestamp": [
                3646.96,
                3654.06
            ],
            "text": " повторяющийся код выносят за пределы операторов if-else. Например, размещая его сразу после них."
        },
        {
            "timestamp": [
                3654.06,
                3659.32
            ],
            "text": " Давайте применим принцип do not repeat yourself. После рефакторинга код примет следующий вид."
        },
        {
            "timestamp": [
                3659.32,
                3665.26
            ],
            "text": " Действительно, вне зависимости от того, является ли число четным или нет,"
        },
        {
            "timestamp": [
                3668.1,
                3672.98
            ],
            "text": " нам необходимо перейти к проверке следующего числа. Для этого мы вынесли указанную операцию за блок if else."
        },
        {
            "timestamp": [
                3673.5,
                3678.28
            ],
            "text": " То есть вот этот блок, переходу к следующему числу, увеличивает его на единицу."
        },
        {
            "timestamp": [
                3678.9,
                3680.2
            ],
            "text": " Затем его проверяют."
        },
        {
            "timestamp": [
                3680.56,
                3683.72
            ],
            "text": " Обратите внимание, что блок else стал пустым."
        },
        {
            "timestamp": [
                3684.7,
                3688.28
            ],
            "text": " Разумеется, от него можно избавиться, просто удалив его."
        },
        {
            "timestamp": [
                3688.62,
                3692.92
            ],
            "text": " Друзья, на этом рефакторе этого фрагмента кода не заканчивается."
        },
        {
            "timestamp": [
                3692.92,
                3697.02
            ],
            "text": " И я предлагаю вам подумать, а как здесь применить принцип Ягнида,"
        },
        {
            "timestamp": [
                3697.32,
                3700.6
            ],
            "text": " то есть избавиться от избыточной функциональности."
        },
        {
            "timestamp": [
                3701.1,
                3701.48
            ],
            "text": " Подскажу."
        },
        {
            "timestamp": [
                3702.52,
                3707.02
            ],
            "text": " В качестве личных фрагментов можно рассмотреть переменные. В качестве второго"
        },
        {
            "timestamp": [
                3707.02,
                3711.74
            ],
            "text": " примера, где я бы хотел продемонстрировать нарушение принципа Ягни, это заполнение"
        },
        {
            "timestamp": [
                3711.74,
                3718.62
            ],
            "text": " массива случайными числами. Здесь создается массив на 10 элементов. Далее в цикле for он"
        },
        {
            "timestamp": [
                3718.62,
                3729.26
            ],
            "text": " инициализируется нулями и затем, предварительно создав объекта Random, он уже инициализируется случайными числами."
        },
        {
            "timestamp": [
                3729.56,
                3733.0
            ],
            "text": " Как вы думаете, есть ли в этом примере избыточная функциональность?"
        },
        {
            "timestamp": [
                3734.06,
                3738.18
            ],
            "text": " То есть операции, от которых можно было бы избавиться."
        },
        {
            "timestamp": [
                3738.48,
                3741.24
            ],
            "text": " Необходимости в зануление массива здесь нет."
        },
        {
            "timestamp": [
                3741.54,
                3747.46
            ],
            "text": " Поскольку при его создании элементам присваивается значение по умолчанию. Если речь"
        },
        {
            "timestamp": [
                3747.46,
                3755.88
            ],
            "text": " идет о числах, то это нули. Цикл на строчках 4-7 можно полностью удалить. На поведении программы"
        },
        {
            "timestamp": [
                3755.88,
                3761.3
            ],
            "text": " это никак не скажется. Резюмируем рассмотренные принципы на приведенной картинке. В качестве фигур"
        },
        {
            "timestamp": [
                3761.3,
                3771.32
            ],
            "text": " могут выступать фрагменты кода, над которыми будем применять принципы избавиться от лишней функциональности, упростить код и, соответственно, избавиться от дублирования."
        },
        {
            "timestamp": [
                3771.48,
                3777.58
            ],
            "text": " На первом переходе мы отказываемся от избыточной функциональности, удаляя лишние фигуры."
        },
        {
            "timestamp": [
                3778.12,
                3786.42
            ],
            "text": " Второй переход упрощает оставшиеся программные сущности, применяясь принцип KeepItSimpleStupid."
        },
        {
            "timestamp": [
                3786.42,
                3793.18
            ],
            "text": " Ну и третий переход объединяет сущности одинаковые в единое целое."
        },
        {
            "timestamp": [
                3793.42,
                3798.78
            ],
            "text": " Например, одинаковые фрагменты кода могут быть заменены на вызовы функций."
        },
        {
            "timestamp": [
                3799.14,
                3804.48
            ],
            "text": " В заключение сегодняшнего занятия давайте рассмотрим несколько типовых вопросов по рекурсии,"
        },
        {
            "timestamp": [
                3804.66,
                3810.18
            ],
            "text": " которые вы можете услышать на собеседовании. Так же, как и на предыдущем занятии, рассмотрим"
        },
        {
            "timestamp": [
                3810.18,
                3814.88
            ],
            "text": " теоретические вопросы, а также вопросы, касающиеся практики. Первый вопрос"
        },
        {
            "timestamp": [
                3814.88,
                3819.08
            ],
            "text": " вероятен на собеседование джуниор-программиста. Его цель понять, может ли"
        },
        {
            "timestamp": [
                3819.08,
                3823.34
            ],
            "text": " программист объяснить, что такое рекурсия как в широком, так и в узком смысле."
        },
        {
            "timestamp": [
                3823.34,
                3826.46
            ],
            "text": " Напомню, в широком смысле рекурсия – это"
        },
        {
            "timestamp": [
                3826.46,
                3833.14
            ],
            "text": " описание объекта или процесса в рамках этого же объекта или процесса. Если речь идет о"
        },
        {
            "timestamp": [
                3833.14,
                3840.16
            ],
            "text": " программировании, то здесь уже понимается некий процесс, в котором функцию вызывает сама себя."
        },
        {
            "timestamp": [
                3840.16,
                3846.42
            ],
            "text": " Второй вопрос касается основных компонентов рекурсий. Требуется их перечислить и кратко"
        },
        {
            "timestamp": [
                3846.42,
                3852.34
            ],
            "text": " описать. Рекурсивная функция состоит из блока основной работы, рекурсивного вызова, который"
        },
        {
            "timestamp": [
                3852.34,
                3860.7
            ],
            "text": " предназначен для решения более простой задачи, а также базового случая, который предназначен для"
        },
        {
            "timestamp": [
                3860.7,
                3868.46
            ],
            "text": " остановки рекурсивных вызовов. В этом вопросе вас могут попросить привести пример рекурсивной функции"
        },
        {
            "timestamp": [
                3868.46,
                3871.32
            ],
            "text": " и показать ее составляющие части."
        },
        {
            "timestamp": [
                3871.84,
                3876.18
            ],
            "text": " Третий вопрос проверяет, есть ли у вас понимание механизма работы рекурсии."
        },
        {
            "timestamp": [
                3876.78,
                3879.84
            ],
            "text": " Его основная идея – это вызов функции в самой себе"
        },
        {
            "timestamp": [
                3879.84,
                3882.76
            ],
            "text": " для решения более простой задачи, чем текущей."
        },
        {
            "timestamp": [
                3882.76,
                3886.58
            ],
            "text": " С каждым новым вызовом задача становится проще."
        },
        {
            "timestamp": [
                3887.76,
                3890.42
            ],
            "text": " В частности, уменьшается объем вычислений."
        },
        {
            "timestamp": [
                3890.7,
                3892.56
            ],
            "text": " Эти вызовы называются рекурсивными"
        },
        {
            "timestamp": [
                3892.56,
                3894.64
            ],
            "text": " и продолжаются до тех пор,"
        },
        {
            "timestamp": [
                3895.16,
                3898.22
            ],
            "text": " пока мы не дойдем до некоторого базового случая,"
        },
        {
            "timestamp": [
                3898.92,
                3902.6
            ],
            "text": " где рекурсивный вызов уже не требуется."
        },
        {
            "timestamp": [
                3902.6,
                3907.74
            ],
            "text": " После достижения базового случая начинается процесс раскручивания рекурсии."
        },
        {
            "timestamp": [
                3908.1,
                3912.8
            ],
            "text": " Последовательность возвратов к местам вызовов функций."
        },
        {
            "timestamp": [
                3913.22,
                3916.24
            ],
            "text": " Этот процесс мы подробно рассматривали на примере с матрешками."
        },
        {
            "timestamp": [
                3916.76,
                3920.5
            ],
            "text": " Следующий вопрос охватывает не только алгоритм работы рекурсии,"
        },
        {
            "timestamp": [
                3921.04,
                3922.92
            ],
            "text": " но и особенности хранения данных в памяти."
        },
        {
            "timestamp": [
                3923.4,
                3924.84
            ],
            "text": " Вернемся к примеру с матрешками."
        },
        {
            "timestamp": [
                3925.9,
                3931.62
            ],
            "text": " Напомню, в процессе рекурсивных вызовов в памяти сохраняются места этих вызовов, как мы видели в"
        },
        {
            "timestamp": [
                3931.62,
                3939.86
            ],
            "text": " коде, а также значение параметров, с которыми они вызывались, то есть от 4 до 1. Эта область памяти"
        },
        {
            "timestamp": [
                3939.86,
                3946.76
            ],
            "text": " называется стэком. Информация о работе рекурсии, о вызовах помещается в стек"
        },
        {
            "timestamp": [
                3946.76,
                3948.36
            ],
            "text": " по мере работы рекурсии."
        },
        {
            "timestamp": [
                3948.76,
                3953.14
            ],
            "text": " Сначала помещается информация о вызове с параметром 4,"
        },
        {
            "timestamp": [
                3953.82,
                3958.26
            ],
            "text": " затем с параметром 3, 2 и последнюю очередь поместится"
        },
        {
            "timestamp": [
                3958.26,
                3961.16
            ],
            "text": " информация о вызове с параметром 1."
        },
        {
            "timestamp": [
                3961.88,
                3965.02
            ],
            "text": " При раскручивании рекурсии информация о вызове"
        },
        {
            "timestamp": [
                3965.02,
                3966.62
            ],
            "text": " будет браться именно из стека."
        },
        {
            "timestamp": [
                3967.08,
                3968.26
            ],
            "text": " Но, друзья, обратите внимание,"
        },
        {
            "timestamp": [
                3968.42,
                3969.94
            ],
            "text": " обязательно в обратном порядке."
        },
        {
            "timestamp": [
                3969.94,
                3973.76
            ],
            "text": " То есть сначала будет браться информация о первом вызове,"
        },
        {
            "timestamp": [
                3974.04,
                3976.8
            ],
            "text": " о втором, о третьем и о четвертом."
        },
        {
            "timestamp": [
                3977.38,
                3980.4
            ],
            "text": " Помните, мы с вами шли в обратном порядке"
        },
        {
            "timestamp": [
                3980.4,
                3983.68
            ],
            "text": " по местам вызова функций."
        },
        {
            "timestamp": [
                3984.0,
                3987.98
            ],
            "text": " Точно так же информация извлекается тэка в обратном порядке, начиная"
        },
        {
            "timestamp": [
                3987.98,
                3995.42
            ],
            "text": " от самого последнего вызова до самого первого. Давайте подумаем, а что произойдет, если условие"
        },
        {
            "timestamp": [
                3995.42,
                4001.18
            ],
            "text": " для остановки рекурсии написано неправильно или же отсутствует совсем. Рекурсивные вызовы будут"
        },
        {
            "timestamp": [
                4001.18,
                4006.32
            ],
            "text": " выполняться бесконечно, каждый раз с меньшим значением аргумента."
        },
        {
            "timestamp": [
                4006.32,
                4010.4
            ],
            "text": " После достижения базового случая, допустим это open"
        },
        {
            "timestamp": [
                4010.4,
                4014.6
            ],
            "text": " матрешка с аргументом 1, вызовы продолжаются, несмотря"
        },
        {
            "timestamp": [
                4014.6,
                4017.36
            ],
            "text": " на то, что аргумент уже уходит в отрицательные"
        },
        {
            "timestamp": [
                4017.36,
                4018.36
            ],
            "text": " значения."
        },
        {
            "timestamp": [
                4018.36,
                4021.96
            ],
            "text": " Это говорит о том, что условие остановки не работает."
        },
        {
            "timestamp": [
                4021.96,
                4026.78
            ],
            "text": " Но самое важное, что информация о вызовах будет также помещаться в стэк. Стэк имеет"
        },
        {
            "timestamp": [
                4026.78,
                4033.5
            ],
            "text": " фиксированный размер. Обычно он занимает порядка 1-2 мегабайт. В некоторый момент его свободное"
        },
        {
            "timestamp": [
                4033.5,
                4039.76
            ],
            "text": " место закончится и он будет заполнен. В этом случае информацию об очередном вызове попросту"
        },
        {
            "timestamp": [
                4039.76,
                4048.24
            ],
            "text": " будет некуда сохранить. В данном случае стэк у нас заполнился на количестве вызовов 5 и информацию о 6 вызове"
        },
        {
            "timestamp": [
                4048.24,
                4056.56
            ],
            "text": " его уже сохранять некуда. Друзья, здесь, конечно же, синтезированный пример с стэком небольшого размера,"
        },
        {
            "timestamp": [
                4056.56,
                4067.02
            ],
            "text": " буквально на 5 вызовов. На практике, как мы видели, число вызовов может достигать порядка десятков тысяч, после чего происходит ошибка."
        },
        {
            "timestamp": [
                4067.02,
                4072.54
            ],
            "text": " При совершении очередного рекурсивного вызова программа попытается сохранить в стеке информацию"
        },
        {
            "timestamp": [
                4072.54,
                4080.28
            ],
            "text": " о нем. В данном примере это вызов с аргументом минус 1, однако места там уже свободного нет."
        },
        {
            "timestamp": [
                4080.28,
                4088.04
            ],
            "text": " Как раз таки здесь, друзья, мы увидим информацию о том, что стэк переполнен. Чтобы"
        },
        {
            "timestamp": [
                4088.04,
                4094.04
            ],
            "text": " это не допустить, мы используем базовый случай, при достижении которого рекурсивные вызовы вот"
        },
        {
            "timestamp": [
                4094.04,
                4101.36
            ],
            "text": " здесь мы останавливали. Еще раз. Под переполнением стэка мы понимаем ситуацию, при которой его"
        },
        {
            "timestamp": [
                4101.36,
                4107.08
            ],
            "text": " свободный объем полностью исчерпан и предпринимается попытка добавить в него данные."
        },
        {
            "timestamp": [
                4107.36,
                4109.0
            ],
            "text": " На этом лекция подходит к концу."
        },
        {
            "timestamp": [
                4109.26,
                4110.84
            ],
            "text": " Давайте подведем ее итоги."
        },
        {
            "timestamp": [
                4110.86,
                4112.36
            ],
            "text": " Если мы говорим про рекурсию,"
        },
        {
            "timestamp": [
                4112.56,
                4115.92
            ],
            "text": " то стоит помнить про определение в широком смысле"
        },
        {
            "timestamp": [
                4115.92,
                4117.86
            ],
            "text": " и более узком,"
        },
        {
            "timestamp": [
                4117.96,
                4120.84
            ],
            "text": " которое уже относится непосредственно к программированию."
        },
        {
            "timestamp": [
                4120.84,
                4129.32
            ],
            "text": " Напомню, что рекурсия состоит из рекурсивного вызова, основных вычислений, некого простейшего"
        },
        {
            "timestamp": [
                4129.32,
                4133.82
            ],
            "text": " или базового случая, который служит для остановки рекурсии."
        },
        {
            "timestamp": [
                4133.82,
                4137.44
            ],
            "text": " Наиболее популярные области применения рекурсии – это"
        },
        {
            "timestamp": [
                4137.44,
                4144.36
            ],
            "text": " обходы деревьев, сортировки, а также поиск файлов и подкаталогов"
        },
        {
            "timestamp": [
                4144.36,
                4145.88
            ],
            "text": " в каких-либо директориях."
        },
        {
            "timestamp": [
                4146.26,
                4148.2
            ],
            "text": " Рекурсию следует применять с осторожностью,"
        },
        {
            "timestamp": [
                4148.8,
                4153.12
            ],
            "text": " в тех случаях, когда она действительно оправдывает свое применение"
        },
        {
            "timestamp": [
                4153.12,
                4157.44
            ],
            "text": " и упрощает алгоритмы или делает их более компактными."
        },
        {
            "timestamp": [
                4157.66,
                4162.48
            ],
            "text": " После блога задач на рекурсию мы с вами рассмотрели два способа отладки программ."
        },
        {
            "timestamp": [
                4163.02,
                4167.26
            ],
            "text": " Это с использованием отладочной печати на консоль или файл,"
        },
        {
            "timestamp": [
                4167.26,
                4173.18
            ],
            "text": " а также с использованием особого инструмента. В заключении лекции мы обсудили"
        },
        {
            "timestamp": [
                4173.18,
                4178.12
            ],
            "text": " принципы создания хороших программ и рассмотрели несколько возможных вопросов в собеседовании"
        },
        {
            "timestamp": [
                4178.12,
                4183.88
            ],
            "text": " на тематику рекурсии. Ну что, друзья, на этом теоретическая часть курса заканчивается. Впереди"
        },
        {
            "timestamp": [
                4183.88,
                4185.0
            ],
            "text": " у нас семинар."
        },
        {
            "timestamp": [
                4186.86,
                4187.64
            ],
            "text": " Несмотря на небольшое количество лекций,"
        },
        {
            "timestamp": [
                4190.6,
                4191.08
            ],
            "text": " мы с командой Geekbrains, помимо базовых тематик,"
        },
        {
            "timestamp": [
                4197.7,
                4197.76
            ],
            "text": " таких как арифметика, условные операторы, циклы, массивы, функции,"
        },
        {
            "timestamp": [
                4201.32,
                4201.5
            ],
            "text": " постарались поместить туда и дополнительные разделы."
        },
        {
            "timestamp": [
                4204.64,
                4207.42
            ],
            "text": " Такие как рекомендации по написанию хорошего кода, особенности работы с текстовым"
        },
        {
            "timestamp": [
                4207.42,
                4212.36
            ],
            "text": " типом данных, отладка программ, блок вопросов с собеседованием"
        },
        {
            "timestamp": [
                4212.36,
                4213.92
            ],
            "text": " и несколько других."
        },
        {
            "timestamp": [
                4213.92,
                4216.8
            ],
            "text": " Если какие-то тематики остались непонятными,"
        },
        {
            "timestamp": [
                4216.8,
                4220.18
            ],
            "text": " то я рекомендую ознакомиться с дополнительной литературой."
        },
        {
            "timestamp": [
                4220.18,
                4223.2
            ],
            "text": " Дополнительными источниками я рекомендую пользоваться"
        },
        {
            "timestamp": [
                4223.2,
                4227.44
            ],
            "text": " для закрепления материала, а также для более глубокого его изучения."
        },
        {
            "timestamp": [
                4227.66,
                4233.78
            ],
            "text": " Позвольте пожелать вам успехов в дальнейшем освоении профессии, грамотных преподавателей и интересных задач."
        },
        {
            "timestamp": [
                4234.16,
                4237.6
            ],
            "text": " На этом, друзья, курс знакомства с языками программирования завершается."
        },
        {
            "timestamp": [
                4238.28,
                null
            ],
            "text": " Всем большое спасибо за работу и внимание. И до новых встреч! you"
        }
    ]
}